"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Infrahub-API
 * Leverage the Infrahub API and Hyperstack platform to easily create, manage, and scale powerful GPU virtual machines and their associated resources.   Access this SDK to automate the deployment of your workloads and streamline your infrastructure management.  To contribute, please raise an issue with a bug report, feature request, feedback, or general inquiry.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComplianceApiAxiosParamCreator = exports.ClustersApi = exports.ClustersApiFactory = exports.ClustersApiFp = exports.ClustersApiAxiosParamCreator = exports.ClusterEventsApi = exports.ClusterEventsApiFactory = exports.ClusterEventsApiFp = exports.ClusterEventsApiAxiosParamCreator = exports.CallbacksApi = exports.CallbacksApiFactory = exports.CallbacksApiFp = exports.CallbacksApiAxiosParamCreator = exports.CalculateApi = exports.CalculateApiFactory = exports.CalculateApiFp = exports.CalculateApiAxiosParamCreator = exports.BillingApi = exports.BillingApiFactory = exports.BillingApiFp = exports.BillingApiAxiosParamCreator = exports.BetaAccessApi = exports.BetaAccessApiFactory = exports.BetaAccessApiFp = exports.BetaAccessApiAxiosParamCreator = exports.AuthApi = exports.AuthApiFactory = exports.AuthApiFp = exports.AuthApiAxiosParamCreator = exports.AssigningMemberRoleApi = exports.AssigningMemberRoleApiFactory = exports.AssigningMemberRoleApiFp = exports.AssigningMemberRoleApiAxiosParamCreator = exports.ApiKeyApi = exports.ApiKeyApiFactory = exports.ApiKeyApiFp = exports.ApiKeyApiAxiosParamCreator = exports.AliveApi = exports.AliveApiFactory = exports.AliveApiFp = exports.AliveApiAxiosParamCreator = exports.RegionFieldsGreenStatusEnum = exports.KeypairEnvironmentFeaturesGreenStatusEnum = exports.EnvironmentFeaturesGreenStatusEnum = exports.CreateSecurityRulePayloadProtocolEnum = exports.CreateFirewallRulePayloadProtocolEnum = exports.CreateClusterPayloadDeploymentModeEnum = exports.CreateClusterNodeFieldsRoleEnum = exports.BetaAccessStatusItemStatusEnum = exports.BetaAccessRequestFieldsStatusEnum = void 0;
exports.InviteApiFactory = exports.InviteApiFp = exports.InviteApiAxiosParamCreator = exports.ImageApi = exports.ImageApiFactory = exports.ImageApiFp = exports.ImageApiAxiosParamCreator = exports.GpuApi = exports.GpuApiFactory = exports.GpuApiFp = exports.GpuApiAxiosParamCreator = exports.FloatingIpApi = exports.FloatingIpApiFactory = exports.FloatingIpApiFp = exports.FloatingIpApiAxiosParamCreator = exports.FlavorApi = exports.FlavorApiFactory = exports.FlavorApiFp = exports.FlavorApiAxiosParamCreator = exports.FirewallsApi = exports.FirewallsApiFactory = exports.FirewallsApiFp = exports.FirewallsApiAxiosParamCreator = exports.FirewallAttachmentApi = exports.FirewallAttachmentApiFactory = exports.FirewallAttachmentApiFp = exports.FirewallAttachmentApiAxiosParamCreator = exports.EnvironmentApi = exports.EnvironmentApiFactory = exports.EnvironmentApiFp = exports.EnvironmentApiAxiosParamCreator = exports.DeploymentApi = exports.DeploymentApiFactory = exports.DeploymentApiFp = exports.DeploymentApiAxiosParamCreator = exports.DashboardApi = exports.DashboardApiFactory = exports.DashboardApiFp = exports.DashboardApiAxiosParamCreator = exports.CustomerContractApi = exports.CustomerContractApiFactory = exports.CustomerContractApiFp = exports.CustomerContractApiAxiosParamCreator = exports.CreditApi = exports.CreditApiFactory = exports.CreditApiFp = exports.CreditApiAxiosParamCreator = exports.ComplianceApi = exports.ComplianceApiFactory = exports.ComplianceApiFp = void 0;
exports.SnapshotsApiAxiosParamCreator = exports.SnapshotEventsApi = exports.SnapshotEventsApiFactory = exports.SnapshotEventsApiFp = exports.SnapshotEventsApiAxiosParamCreator = exports.SecurityRulesApi = exports.SecurityRulesApiFactory = exports.SecurityRulesApiFp = exports.SecurityRulesApiAxiosParamCreator = exports.RegionApi = exports.RegionApiFactory = exports.RegionApiFp = exports.RegionApiAxiosParamCreator = exports.RbacRoleApi = exports.RbacRoleApiFactory = exports.RbacRoleApiFp = exports.RbacRoleApiAxiosParamCreator = exports.ProfileApi = exports.ProfileApiFactory = exports.ProfileApiFp = exports.ProfileApiAxiosParamCreator = exports.PricebookApi = exports.PricebookApiFactory = exports.PricebookApiFp = exports.PricebookApiAxiosParamCreator = exports.PolicyApi = exports.PolicyApiFactory = exports.PolicyApiFp = exports.PolicyApiAxiosParamCreator = exports.PermissionApi = exports.PermissionApiFactory = exports.PermissionApiFp = exports.PermissionApiAxiosParamCreator = exports.PaymentApi = exports.PaymentApiFactory = exports.PaymentApiFp = exports.PaymentApiAxiosParamCreator = exports.PartnerConfigApi = exports.PartnerConfigApiFactory = exports.PartnerConfigApiFp = exports.PartnerConfigApiAxiosParamCreator = exports.OrganizationApi = exports.OrganizationApiFactory = exports.OrganizationApiFp = exports.OrganizationApiAxiosParamCreator = exports.KeypairApi = exports.KeypairApiFactory = exports.KeypairApiFp = exports.KeypairApiAxiosParamCreator = exports.InviteApi = void 0;
exports.VolumeAttachmentApi = exports.VolumeAttachmentApiFactory = exports.VolumeAttachmentApiFp = exports.VolumeAttachmentApiAxiosParamCreator = exports.VolumeApi = exports.VolumeApiFactory = exports.VolumeApiFp = exports.VolumeApiAxiosParamCreator = exports.VncUrlApi = exports.VncUrlApiFactory = exports.VncUrlApiFp = exports.VncUrlApiAxiosParamCreator = exports.VirtualMachineEventsApi = exports.VirtualMachineEventsApiFactory = exports.VirtualMachineEventsApiFp = exports.VirtualMachineEventsApiAxiosParamCreator = exports.GetInstanceMetricsDurationEnum = exports.VirtualMachineApi = exports.VirtualMachineApiFactory = exports.VirtualMachineApiFp = exports.VirtualMachineApiAxiosParamCreator = exports.UserPermissionApi = exports.UserPermissionApiFactory = exports.UserPermissionApiFp = exports.UserPermissionApiAxiosParamCreator = exports.UserDetailChoiceApi = exports.UserDetailChoiceApiFactory = exports.UserDetailChoiceApiFp = exports.UserDetailChoiceApiAxiosParamCreator = exports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = exports.TemplateApi = exports.TemplateApiFactory = exports.TemplateApiFp = exports.TemplateApiAxiosParamCreator = exports.StockApi = exports.StockApiFactory = exports.StockApiFp = exports.StockApiAxiosParamCreator = exports.SnapshotsApi = exports.SnapshotsApiFactory = exports.SnapshotsApiFp = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.BetaAccessRequestFieldsStatusEnum = {
    Requested: 'requested',
    Approved: 'approved',
    Denied: 'denied',
    Revoked: 'revoked'
};
exports.BetaAccessStatusItemStatusEnum = {
    Requested: 'requested',
    Approved: 'approved',
    Denied: 'denied',
    Revoked: 'revoked'
};
exports.CreateClusterNodeFieldsRoleEnum = {
    Worker: 'worker',
    Master: 'master'
};
exports.CreateClusterPayloadDeploymentModeEnum = {
    Full: 'full',
    Standard: 'standard'
};
exports.CreateFirewallRulePayloadProtocolEnum = {
    Any: 'any',
    Ah: 'ah',
    Dccp: 'dccp',
    Egp: 'egp',
    Esp: 'esp',
    Gre: 'gre',
    Hopopt: 'hopopt',
    Icmp: 'icmp',
    Igmp: 'igmp',
    Ip: 'ip',
    Ipip: 'ipip',
    Ipv6Encap: 'ipv6-encap',
    Ipv6Frag: 'ipv6-frag',
    Ipv6Icmp: 'ipv6-icmp',
    Icmpv6: 'icmpv6',
    Ipv6Nonxt: 'ipv6-nonxt',
    Ipv6Opts: 'ipv6-opts',
    Ipv6Route: 'ipv6-route',
    Ospf: 'ospf',
    Pgm: 'pgm',
    Rsvp: 'rsvp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp',
    Udplite: 'udplite',
    Vrrp: 'vrrp'
};
exports.CreateSecurityRulePayloadProtocolEnum = {
    Any: 'any',
    Ah: 'ah',
    Dccp: 'dccp',
    Egp: 'egp',
    Esp: 'esp',
    Gre: 'gre',
    Hopopt: 'hopopt',
    Icmp: 'icmp',
    Igmp: 'igmp',
    Ip: 'ip',
    Ipip: 'ipip',
    Ipv6Encap: 'ipv6-encap',
    Ipv6Frag: 'ipv6-frag',
    Ipv6Icmp: 'ipv6-icmp',
    Icmpv6: 'icmpv6',
    Ipv6Nonxt: 'ipv6-nonxt',
    Ipv6Opts: 'ipv6-opts',
    Ipv6Route: 'ipv6-route',
    Ospf: 'ospf',
    Pgm: 'pgm',
    Rsvp: 'rsvp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp',
    Udplite: 'udplite',
    Vrrp: 'vrrp'
};
exports.EnvironmentFeaturesGreenStatusEnum = {
    Green: 'GREEN',
    PartiallyGreen: 'PARTIALLY_GREEN',
    NotGreen: 'NOT_GREEN'
};
exports.KeypairEnvironmentFeaturesGreenStatusEnum = {
    Green: 'GREEN',
    PartiallyGreen: 'PARTIALLY_GREEN',
    NotGreen: 'NOT_GREEN'
};
exports.RegionFieldsGreenStatusEnum = {
    Green: 'GREEN',
    PartiallyGreen: 'PARTIALLY_GREEN',
    NotGreen: 'NOT_GREEN'
};
/**
 * AliveApi - axios parameter creator
 * @export
 */
const AliveApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the billing status of your account to ensure that it is active. An active billing status ensures uninterrupted service. For additional information [**click here**](None/docs/api-reference/billing-resources/alive/).
         * @summary GET: Alive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlive: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/billing/alive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDoc: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/billing/alive/doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AliveApiAxiosParamCreator = AliveApiAxiosParamCreator;
/**
 * AliveApi - functional programming interface
 * @export
 */
const AliveApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AliveApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve the billing status of your account to ensure that it is active. An active billing status ensures uninterrupted service. For additional information [**click here**](None/docs/api-reference/billing-resources/alive/).
         * @summary GET: Alive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlive(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAlive(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AliveApi.getAlive']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDoc(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDoc(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AliveApi.getDoc']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AliveApiFp = AliveApiFp;
/**
 * AliveApi - factory interface
 * @export
 */
const AliveApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AliveApiFp)(configuration);
    return {
        /**
         * Retrieve the billing status of your account to ensure that it is active. An active billing status ensures uninterrupted service. For additional information [**click here**](None/docs/api-reference/billing-resources/alive/).
         * @summary GET: Alive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlive(options) {
            return localVarFp.getAlive(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDoc(options) {
            return localVarFp.getDoc(options).then((request) => request(axios, basePath));
        },
    };
};
exports.AliveApiFactory = AliveApiFactory;
/**
 * AliveApi - object-oriented interface
 * @export
 * @class AliveApi
 * @extends {BaseAPI}
 */
class AliveApi extends base_1.BaseAPI {
    /**
     * Retrieve the billing status of your account to ensure that it is active. An active billing status ensures uninterrupted service. For additional information [**click here**](None/docs/api-reference/billing-resources/alive/).
     * @summary GET: Alive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliveApi
     */
    getAlive(options) {
        return (0, exports.AliveApiFp)(this.configuration).getAlive(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliveApi
     */
    getDoc(options) {
        return (0, exports.AliveApiFp)(this.configuration).getDoc(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AliveApi = AliveApi;
/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
const ApiKeyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a specified API key by including the ID of the API key in the path.
         * @summary Delete API Key
         * @param {number} apiKeyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPIKey: (apiKeyId_1, ...args_1) => __awaiter(this, [apiKeyId_1, ...args_1], void 0, function* (apiKeyId, options = {}) {
            // verify required parameter 'apiKeyId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAPIKey', 'apiKeyId', apiKeyId);
            const localVarPath = `/api-key/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generates your API key, providing access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/generate-api-key).
         * @summary Generate API Key
         * @param {GenerateUpdateApiKeyPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAPIKey: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('generateAPIKey', 'payload', payload);
            const localVarPath = `/api-key/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves your API keys, granting access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/retrieve-api-key).
         * @summary Retrieve API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAPIKey: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the name and optionally the description of a specified API key. Include the ID of the API key in the path and the new name and optional description in the body of the request.
         * @summary Update API Key
         * @param {number} apiKeyId
         * @param {GenerateUpdateApiKeyPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPIKey: (apiKeyId_1, payload_1, ...args_1) => __awaiter(this, [apiKeyId_1, payload_1, ...args_1], void 0, function* (apiKeyId, payload, options = {}) {
            // verify required parameter 'apiKeyId' is not null or undefined
            (0, common_1.assertParamExists)('updateAPIKey', 'apiKeyId', apiKeyId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateAPIKey', 'payload', payload);
            const localVarPath = `/api-key/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ApiKeyApiAxiosParamCreator = ApiKeyApiAxiosParamCreator;
/**
 * ApiKeyApi - functional programming interface
 * @export
 */
const ApiKeyApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ApiKeyApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete a specified API key by including the ID of the API key in the path.
         * @summary Delete API Key
         * @param {number} apiKeyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPIKey(apiKeyId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAPIKey(apiKeyId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ApiKeyApi.deleteAPIKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generates your API key, providing access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/generate-api-key).
         * @summary Generate API Key
         * @param {GenerateUpdateApiKeyPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAPIKey(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateAPIKey(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ApiKeyApi.generateAPIKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves your API keys, granting access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/retrieve-api-key).
         * @summary Retrieve API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAPIKey(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveAPIKey(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ApiKeyApi.retrieveAPIKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the name and optionally the description of a specified API key. Include the ID of the API key in the path and the new name and optional description in the body of the request.
         * @summary Update API Key
         * @param {number} apiKeyId
         * @param {GenerateUpdateApiKeyPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPIKey(apiKeyId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAPIKey(apiKeyId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ApiKeyApi.updateAPIKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ApiKeyApiFp = ApiKeyApiFp;
/**
 * ApiKeyApi - factory interface
 * @export
 */
const ApiKeyApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ApiKeyApiFp)(configuration);
    return {
        /**
         * Delete a specified API key by including the ID of the API key in the path.
         * @summary Delete API Key
         * @param {number} apiKeyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPIKey(apiKeyId, options) {
            return localVarFp.deleteAPIKey(apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates your API key, providing access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/generate-api-key).
         * @summary Generate API Key
         * @param {GenerateUpdateApiKeyPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAPIKey(payload, options) {
            return localVarFp.generateAPIKey(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves your API keys, granting access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/retrieve-api-key).
         * @summary Retrieve API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAPIKey(options) {
            return localVarFp.retrieveAPIKey(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the name and optionally the description of a specified API key. Include the ID of the API key in the path and the new name and optional description in the body of the request.
         * @summary Update API Key
         * @param {number} apiKeyId
         * @param {GenerateUpdateApiKeyPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPIKey(apiKeyId, payload, options) {
            return localVarFp.updateAPIKey(apiKeyId, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ApiKeyApiFactory = ApiKeyApiFactory;
/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
class ApiKeyApi extends base_1.BaseAPI {
    /**
     * Delete a specified API key by including the ID of the API key in the path.
     * @summary Delete API Key
     * @param {number} apiKeyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    deleteAPIKey(apiKeyId, options) {
        return (0, exports.ApiKeyApiFp)(this.configuration).deleteAPIKey(apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates your API key, providing access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/generate-api-key).
     * @summary Generate API Key
     * @param {GenerateUpdateApiKeyPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    generateAPIKey(payload, options) {
        return (0, exports.ApiKeyApiFp)(this.configuration).generateAPIKey(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves your API keys, granting access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/retrieve-api-key).
     * @summary Retrieve API Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    retrieveAPIKey(options) {
        return (0, exports.ApiKeyApiFp)(this.configuration).retrieveAPIKey(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the name and optionally the description of a specified API key. Include the ID of the API key in the path and the new name and optional description in the body of the request.
     * @summary Update API Key
     * @param {number} apiKeyId
     * @param {GenerateUpdateApiKeyPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    updateAPIKey(apiKeyId, payload, options) {
        return (0, exports.ApiKeyApiFp)(this.configuration).updateAPIKey(apiKeyId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ApiKeyApi = ApiKeyApi;
/**
 * AssigningMemberRoleApi - axios parameter creator
 * @export
 */
const AssigningMemberRoleApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Assigns a specific RBAC role to a user within your organization, granting them access to the resource actions permitted by the role. Provide the user ID in the path and the role ID in the request body. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/assign-rbac-role).
         * @summary Assign RBAC Role
         * @param {number} userId
         * @param {AssignRbacRolePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRBACRoleToUser: (userId_1, payload_1, ...args_1) => __awaiter(this, [userId_1, payload_1, ...args_1], void 0, function* (userId, payload, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('assignRBACRoleToUser', 'userId', userId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('assignRBACRoleToUser', 'payload', payload);
            const localVarPath = `/auth/users/{user_id}/assign-roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes an RBAC role from a user within your organization, revoking the resource permissions they had access to. Provide the user ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/revoke-rbac-role).
         * @summary Remove RBAC Role From User
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRBACRoleFromUser: (userId_1, ...args_1) => __awaiter(this, [userId_1, ...args_1], void 0, function* (userId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('removeRBACRoleFromUser', 'userId', userId);
            const localVarPath = `/auth/users/{user_id}/roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AssigningMemberRoleApiAxiosParamCreator = AssigningMemberRoleApiAxiosParamCreator;
/**
 * AssigningMemberRoleApi - functional programming interface
 * @export
 */
const AssigningMemberRoleApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AssigningMemberRoleApiAxiosParamCreator)(configuration);
    return {
        /**
         * Assigns a specific RBAC role to a user within your organization, granting them access to the resource actions permitted by the role. Provide the user ID in the path and the role ID in the request body. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/assign-rbac-role).
         * @summary Assign RBAC Role
         * @param {number} userId
         * @param {AssignRbacRolePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRBACRoleToUser(userId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.assignRBACRoleToUser(userId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AssigningMemberRoleApi.assignRBACRoleToUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Removes an RBAC role from a user within your organization, revoking the resource permissions they had access to. Provide the user ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/revoke-rbac-role).
         * @summary Remove RBAC Role From User
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRBACRoleFromUser(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.removeRBACRoleFromUser(userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AssigningMemberRoleApi.removeRBACRoleFromUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AssigningMemberRoleApiFp = AssigningMemberRoleApiFp;
/**
 * AssigningMemberRoleApi - factory interface
 * @export
 */
const AssigningMemberRoleApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AssigningMemberRoleApiFp)(configuration);
    return {
        /**
         * Assigns a specific RBAC role to a user within your organization, granting them access to the resource actions permitted by the role. Provide the user ID in the path and the role ID in the request body. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/assign-rbac-role).
         * @summary Assign RBAC Role
         * @param {number} userId
         * @param {AssignRbacRolePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRBACRoleToUser(userId, payload, options) {
            return localVarFp.assignRBACRoleToUser(userId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an RBAC role from a user within your organization, revoking the resource permissions they had access to. Provide the user ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/revoke-rbac-role).
         * @summary Remove RBAC Role From User
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRBACRoleFromUser(userId, options) {
            return localVarFp.removeRBACRoleFromUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AssigningMemberRoleApiFactory = AssigningMemberRoleApiFactory;
/**
 * AssigningMemberRoleApi - object-oriented interface
 * @export
 * @class AssigningMemberRoleApi
 * @extends {BaseAPI}
 */
class AssigningMemberRoleApi extends base_1.BaseAPI {
    /**
     * Assigns a specific RBAC role to a user within your organization, granting them access to the resource actions permitted by the role. Provide the user ID in the path and the role ID in the request body. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/assign-rbac-role).
     * @summary Assign RBAC Role
     * @param {number} userId
     * @param {AssignRbacRolePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssigningMemberRoleApi
     */
    assignRBACRoleToUser(userId, payload, options) {
        return (0, exports.AssigningMemberRoleApiFp)(this.configuration).assignRBACRoleToUser(userId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes an RBAC role from a user within your organization, revoking the resource permissions they had access to. Provide the user ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/revoke-rbac-role).
     * @summary Remove RBAC Role From User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssigningMemberRoleApi
     */
    removeRBACRoleFromUser(userId, options) {
        return (0, exports.AssigningMemberRoleApiFp)(this.configuration).removeRBACRoleFromUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AssigningMemberRoleApi = AssigningMemberRoleApi;
/**
 * AuthApi - axios parameter creator
 * @export
 */
const AuthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Change the organization associated with the current token. This is useful for users who have access to multiple organizations.
         * @param {number} orgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOrganizationForToken: (orgId_1, ...args_1) => __awaiter(this, [orgId_1, ...args_1], void 0, function* (orgId, options = {}) {
            // verify required parameter 'orgId' is not null or undefined
            (0, common_1.assertParamExists)('changeOrganizationForToken', 'orgId', orgId);
            const localVarPath = `/auth/token/change-org/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Disable Multi-Factor Authentication (MFA) for the currently authenticated user. This endpoint is used to turn off MFA.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/me/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve the Multi-Factor Authentication (MFA) status for the currentlyauthenticated user. Includes whether MFA is enabled.
         * @summary Get MFA status for authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMFAStatus: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/me/mfa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve the organizations associated with a user by their user ID. This endpoint is useful for understanding the user\'s organizational affiliations.
         * @summary Get User Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrganizations: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/me/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves detailed information about the currently authenticated user. For additional information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/auth).
         * @summary Retrieve Authenticated User Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAuthenticatedUserDetails: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AuthApiAxiosParamCreator = AuthApiAxiosParamCreator;
/**
 * AuthApi - functional programming interface
 * @export
 */
const AuthApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AuthApiAxiosParamCreator)(configuration);
    return {
        /**
         * Change the organization associated with the current token. This is useful for users who have access to multiple organizations.
         * @param {number} orgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOrganizationForToken(orgId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changeOrganizationForToken(orgId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AuthApi.changeOrganizationForToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Disable Multi-Factor Authentication (MFA) for the currently authenticated user. This endpoint is used to turn off MFA.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.disableMFA(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AuthApi.disableMFA']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve the Multi-Factor Authentication (MFA) status for the currentlyauthenticated user. Includes whether MFA is enabled.
         * @summary Get MFA status for authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMFAStatus(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserMFAStatus(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AuthApi.getUserMFAStatus']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve the organizations associated with a user by their user ID. This endpoint is useful for understanding the user\'s organizational affiliations.
         * @summary Get User Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrganizations(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserOrganizations(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AuthApi.getUserOrganizations']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves detailed information about the currently authenticated user. For additional information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/auth).
         * @summary Retrieve Authenticated User Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAuthenticatedUserDetails(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveAuthenticatedUserDetails(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AuthApi.retrieveAuthenticatedUserDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AuthApiFp = AuthApiFp;
/**
 * AuthApi - factory interface
 * @export
 */
const AuthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AuthApiFp)(configuration);
    return {
        /**
         * Change the organization associated with the current token. This is useful for users who have access to multiple organizations.
         * @param {number} orgId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOrganizationForToken(orgId, options) {
            return localVarFp.changeOrganizationForToken(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable Multi-Factor Authentication (MFA) for the currently authenticated user. This endpoint is used to turn off MFA.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(options) {
            return localVarFp.disableMFA(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Multi-Factor Authentication (MFA) status for the currentlyauthenticated user. Includes whether MFA is enabled.
         * @summary Get MFA status for authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMFAStatus(options) {
            return localVarFp.getUserMFAStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the organizations associated with a user by their user ID. This endpoint is useful for understanding the user\'s organizational affiliations.
         * @summary Get User Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrganizations(options) {
            return localVarFp.getUserOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about the currently authenticated user. For additional information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/auth).
         * @summary Retrieve Authenticated User Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAuthenticatedUserDetails(options) {
            return localVarFp.retrieveAuthenticatedUserDetails(options).then((request) => request(axios, basePath));
        },
    };
};
exports.AuthApiFactory = AuthApiFactory;
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
class AuthApi extends base_1.BaseAPI {
    /**
     * Change the organization associated with the current token. This is useful for users who have access to multiple organizations.
     * @param {number} orgId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    changeOrganizationForToken(orgId, options) {
        return (0, exports.AuthApiFp)(this.configuration).changeOrganizationForToken(orgId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disable Multi-Factor Authentication (MFA) for the currently authenticated user. This endpoint is used to turn off MFA.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    disableMFA(options) {
        return (0, exports.AuthApiFp)(this.configuration).disableMFA(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the Multi-Factor Authentication (MFA) status for the currentlyauthenticated user. Includes whether MFA is enabled.
     * @summary Get MFA status for authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    getUserMFAStatus(options) {
        return (0, exports.AuthApiFp)(this.configuration).getUserMFAStatus(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the organizations associated with a user by their user ID. This endpoint is useful for understanding the user\'s organizational affiliations.
     * @summary Get User Organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    getUserOrganizations(options) {
        return (0, exports.AuthApiFp)(this.configuration).getUserOrganizations(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves detailed information about the currently authenticated user. For additional information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/auth).
     * @summary Retrieve Authenticated User Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    retrieveAuthenticatedUserDetails(options) {
        return (0, exports.AuthApiFp)(this.configuration).retrieveAuthenticatedUserDetails(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AuthApi = AuthApi;
/**
 * BetaAccessApi - axios parameter creator
 * @export
 */
const BetaAccessApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new beta access request for the current user
         * @summary Create a new beta access request
         * @param {BetaAccessRequestPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createABetaAccessRequest: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createABetaAccessRequest', 'payload', payload);
            const localVarPath = `/auth/beta-access/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check the status of all beta access requests.
         * @summary Check the status of all beta access requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessStatus: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/beta-access/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check the status of a particular beta access requests.
         * @summary Check the status of beta access requests
         * @param {string} program
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessStatus2: (program_1, ...args_1) => __awaiter(this, [program_1, ...args_1], void 0, function* (program, options = {}) {
            // verify required parameter 'program' is not null or undefined
            (0, common_1.assertParamExists)('getBetaAccessStatus2', 'program', program);
            const localVarPath = `/auth/beta-access/requests/{program}`
                .replace(`{${"program"}}`, encodeURIComponent(String(program)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BetaAccessApiAxiosParamCreator = BetaAccessApiAxiosParamCreator;
/**
 * BetaAccessApi - functional programming interface
 * @export
 */
const BetaAccessApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BetaAccessApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a new beta access request for the current user
         * @summary Create a new beta access request
         * @param {BetaAccessRequestPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createABetaAccessRequest(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createABetaAccessRequest(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BetaAccessApi.createABetaAccessRequest']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check the status of all beta access requests.
         * @summary Check the status of all beta access requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessStatus(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBetaAccessStatus(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BetaAccessApi.getBetaAccessStatus']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check the status of a particular beta access requests.
         * @summary Check the status of beta access requests
         * @param {string} program
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessStatus2(program, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBetaAccessStatus2(program, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BetaAccessApi.getBetaAccessStatus2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.BetaAccessApiFp = BetaAccessApiFp;
/**
 * BetaAccessApi - factory interface
 * @export
 */
const BetaAccessApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BetaAccessApiFp)(configuration);
    return {
        /**
         * Creates a new beta access request for the current user
         * @summary Create a new beta access request
         * @param {BetaAccessRequestPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createABetaAccessRequest(payload, options) {
            return localVarFp.createABetaAccessRequest(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the status of all beta access requests.
         * @summary Check the status of all beta access requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessStatus(options) {
            return localVarFp.getBetaAccessStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the status of a particular beta access requests.
         * @summary Check the status of beta access requests
         * @param {string} program
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessStatus2(program, options) {
            return localVarFp.getBetaAccessStatus2(program, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BetaAccessApiFactory = BetaAccessApiFactory;
/**
 * BetaAccessApi - object-oriented interface
 * @export
 * @class BetaAccessApi
 * @extends {BaseAPI}
 */
class BetaAccessApi extends base_1.BaseAPI {
    /**
     * Creates a new beta access request for the current user
     * @summary Create a new beta access request
     * @param {BetaAccessRequestPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BetaAccessApi
     */
    createABetaAccessRequest(payload, options) {
        return (0, exports.BetaAccessApiFp)(this.configuration).createABetaAccessRequest(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check the status of all beta access requests.
     * @summary Check the status of all beta access requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BetaAccessApi
     */
    getBetaAccessStatus(options) {
        return (0, exports.BetaAccessApiFp)(this.configuration).getBetaAccessStatus(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check the status of a particular beta access requests.
     * @summary Check the status of beta access requests
     * @param {string} program
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BetaAccessApi
     */
    getBetaAccessStatus2(program, options) {
        return (0, exports.BetaAccessApiFp)(this.configuration).getBetaAccessStatus2(program, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BetaAccessApi = BetaAccessApi;
/**
 * BillingApi - axios parameter creator
 * @export
 */
const BillingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the previous day\'s costs for instances, volumes, and clusters. Returns a breakdown of  the costs and the total cost for the last day. For additional information on Retrieve Previous Day Usage Costs, [**click here**](None/docs/api-reference/billing-resources/last-day-usage/)
         * @summary GET: Last Day Cost
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastDayCost: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/billing/billing/last-day-cost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve all the notification thresholds for an organization.
         * @summary GET: All Thresholds for Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationThreshold: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/billing/billing/threshold`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve active billing metrics for the organization\'s resources, including pricing, uptime, and total cost. Returns usage details for each active resource by defualt(`deleted=false` will return active resources). Additionally, adding `deleted=true` in query parameter will return inactive resources. For additional information on view usage costs for all resources, [**click here**](None/docs/billing/pricebook/)
         * @summary GET: Billing usage
         * @param {string} [deleted] &#x60;true&#x60; will return inactive resources and &#x60;false&#x60; will return active resources. By defualt(&#x60;deleted&#x3D;false&#x60;)
         * @param {string} [environment] Filter resources by environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage2: (deleted_1, environment_1, ...args_1) => __awaiter(this, [deleted_1, environment_1, ...args_1], void 0, function* (deleted, environment, options = {}) {
            const localVarPath = `/billing/billing/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }
            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve hourly cost datapoints for a Bucket for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Bucket for a specific billing cycle
         * @param {number} bucketId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingBucketDetailsGraph: (bucketId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [bucketId_1, startDate_1, endDate_1, ...args_1], void 0, function* (bucketId, startDate, endDate, options = {}) {
            // verify required parameter 'bucketId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingBucketDetailsGraph', 'bucketId', bucketId);
            const localVarPath = `/billing/billing/history/bucket/{bucket_id}/graph`
                .replace(`{${"bucket_id"}}`, encodeURIComponent(String(bucketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will receive hourly cost datapoints for a Cluster for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a specific Cluster for a specific billing cycle
         * @param {number} clusterId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingClusterDetailsGraph: (clusterId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [clusterId_1, startDate_1, endDate_1, ...args_1], void 0, function* (clusterId, startDate, endDate, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingClusterDetailsGraph', 'clusterId', clusterId);
            const localVarPath = `/billing/billing/history/cluster/{cluster_id}/graph`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will receive hourly cost datapoints for a data synthesis job for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Data Synthesis for a specific
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingDataSynthesisDetailsGraph: (resourceId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [resourceId_1, startDate_1, endDate_1, ...args_1], void 0, function* (resourceId, startDate, endDate, options = {}) {
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingDataSynthesisDetailsGraph', 'resourceId', resourceId);
            const localVarPath = `/billing/billing/history/data_synthesis/{resource_id}/graph`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve hourly cost datapoints for a Fine Tunings for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Fine Tuning for a specific billing cycle
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingFineTuningDetailsGraph: (resourceId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [resourceId_1, startDate_1, endDate_1, ...args_1], void 0, function* (resourceId, startDate, endDate, options = {}) {
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingFineTuningDetailsGraph', 'resourceId', resourceId);
            const localVarPath = `/billing/billing/history/fine_tuning/{resource_id}/graph`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history for the specified billing cycle. This data will include \'incurred_bill\', \'non_discounted_bill\', \'vm_cost\', \'volume_cost\'
         * @summary Retrieve Billing History for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [graph] Set this value to \&quot;true\&quot; for getting graph value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistory2: (startDate_1, endDate_1, graph_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, graph_1, ...args_1], void 0, function* (startDate, endDate, graph, options = {}) {
            const localVarPath = `/billing/billing/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (graph !== undefined) {
                localVarQueryParameter['graph'] = graph;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of buckets for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Volume for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryBucket2: (startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1], void 0, function* (startDate, endDate, search, perPage, page, options = {}) {
            const localVarPath = `/billing/billing/history/bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve billing history of a specific Bucket for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} bucketId
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryBucketDetails: (bucketId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [bucketId_1, startDate_1, endDate_1, ...args_1], void 0, function* (bucketId, startDate, endDate, options = {}) {
            // verify required parameter 'bucketId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryBucketDetails', 'bucketId', bucketId);
            const localVarPath = `/billing/billing/history/bucket/{bucket_id}`
                .replace(`{${"bucket_id"}}`, encodeURIComponent(String(bucketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will receive billing history of clusters for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Clusters for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryCluster: (startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1], void 0, function* (startDate, endDate, search, perPage, page, options = {}) {
            const localVarPath = `/billing/billing/history/cluster`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will receive billing history of a specific Cluster for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'.
         * @summary Retrieve Billing History of a Specific Cluster for a specific Billing Cycle
         * @param {number} clusterId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryClusterDetails: (clusterId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [clusterId_1, startDate_1, endDate_1, ...args_1], void 0, function* (clusterId, startDate, endDate, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryClusterDetails', 'clusterId', clusterId);
            const localVarPath = `/billing/billing/history/cluster/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of contracts for the specified billing cycle. This data will include \'description\', gpu_type\',\'infrahub_id\', \'status\', \'incurred_bill\', \'price_per_hour\'
         * @summary Retrieve Billing History of Contract for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by Contract \&quot;Description\&quot; or \&quot;ID\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryContract: (startDate_1, endDate_1, search_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, ...args_1], void 0, function* (startDate, endDate, search, options = {}) {
            const localVarPath = `/billing/billing/history/contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of data_synthesis for the specified billing cycle.
         * @summary Retrieve Billing History of data synthesis for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryDataSynthesis: (startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1], void 0, function* (startDate, endDate, search, perPage, page, options = {}) {
            const localVarPath = `/billing/billing/history/data_synthesis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve billing history for a specific Data Synthesis resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryDataSynthesisDetails: (resourceId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [resourceId_1, startDate_1, endDate_1, ...args_1], void 0, function* (resourceId, startDate, endDate, options = {}) {
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryDataSynthesisDetails', 'resourceId', resourceId);
            const localVarPath = `/billing/billing/history/data_synthesis/{resource_id}`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of fine_tuning for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryFineTuning: (startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1], void 0, function* (startDate, endDate, search, perPage, page, options = {}) {
            const localVarPath = `/billing/billing/history/fine_tuning`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve billing history of a specific Fine tunning for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Fine Tuning for a specific Billing Cycle
         * @param {number} resourceId
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryFineTuningDetails: (resourceId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [resourceId_1, startDate_1, endDate_1, ...args_1], void 0, function* (resourceId, startDate, endDate, options = {}) {
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryFineTuningDetails', 'resourceId', resourceId);
            const localVarPath = `/billing/billing/history/fine_tuning/{resource_id}`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of model_evaluation for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryModelEvaluation: (startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1], void 0, function* (startDate, endDate, search, perPage, page, options = {}) {
            const localVarPath = `/billing/billing/history/model_evaluation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve billing history for a specific Model Evaluation resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryModelEvaluationDetails: (resourceId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [resourceId_1, startDate_1, endDate_1, ...args_1], void 0, function* (resourceId, startDate, endDate, options = {}) {
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryModelEvaluationDetails', 'resourceId', resourceId);
            const localVarPath = `/billing/billing/history/model_evaluation/{resource_id}`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of serverless_inference for the specified billing cycle.
         * @summary Retrieve Billing History of serverless inference for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryServerlessInference: (startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1], void 0, function* (startDate, endDate, search, perPage, page, options = {}) {
            const localVarPath = `/billing/billing/history/serverless_inference`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve billing history for a specific Serverless Inference resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryServerlessInferenceDetails: (resourceId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [resourceId_1, startDate_1, endDate_1, ...args_1], void 0, function* (resourceId, startDate, endDate, options = {}) {
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryServerlessInferenceDetails', 'resourceId', resourceId);
            const localVarPath = `/billing/billing/history/serverless_inference/{resource_id}`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of snapshots for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Snapshot for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistorySnapshot: (startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1], void 0, function* (startDate, endDate, search, perPage, page, options = {}) {
            const localVarPath = `/billing/billing/history/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve billing history of a specific Snapshot for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} snapshotId
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistorySnapshotDetails: (snapshotId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [snapshotId_1, startDate_1, endDate_1, ...args_1], void 0, function* (snapshotId, startDate, endDate, options = {}) {
            // verify required parameter 'snapshotId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistorySnapshotDetails', 'snapshotId', snapshotId);
            const localVarPath = `/billing/billing/history/snapshot/{snapshot_id}`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of virtual machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Virtual Machine for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVm2: (startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1], void 0, function* (startDate, endDate, search, perPage, page, options = {}) {
            const localVarPath = `/billing/billing/history/virtual-machine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of a specific Virtual Machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'
         * @summary Retrieve Billing History of a Specific Virtual Machine for a specific Billing Cycle
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVmDetails2: (vmId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [vmId_1, startDate_1, endDate_1, ...args_1], void 0, function* (vmId, startDate, endDate, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryVmDetails2', 'vmId', vmId);
            const localVarPath = `/billing/billing/history/virtual-machine/{vm_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve sub-resources historical cost datapoints for a VM sub resources for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. Machine sub resources for a specific billing cycle
         * @summary Retrieve Sub-Resources Historical Cost datapoints of a Virtual
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVmSubResourceGraph2: (vmId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [vmId_1, startDate_1, endDate_1, ...args_1], void 0, function* (vmId, startDate, endDate, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryVmSubResourceGraph2', 'vmId', vmId);
            const localVarPath = `/billing/billing/virtual-machine/{vm_id}/sub-resource/graph`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will get total costs and non_discount costs of sub resources on a specific Virtual Machine for the specified billing cycle. on a Specific VM for the Specified Billing Cycle
         * @summary Retrieve Total Costs and Non Discount Costs for Sub Resources
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVmTotalCosts: (vmId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [vmId_1, startDate_1, endDate_1, ...args_1], void 0, function* (vmId, startDate, endDate, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryVmTotalCosts', 'vmId', vmId);
            const localVarPath = `/billing/billing/virtual-machine/{vm_id}/sub-resource`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve billing history of volumes for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Volume for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVolume2: (startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1) => __awaiter(this, [startDate_1, endDate_1, search_1, perPage_1, page_1, ...args_1], void 0, function* (startDate, endDate, search, perPage, page, options = {}) {
            const localVarPath = `/billing/billing/history/volume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve billing history of a specific Volume for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Volume for a specific Billing Cycle
         * @param {number} volumeId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVolumeDetails2: (volumeId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [volumeId_1, startDate_1, endDate_1, ...args_1], void 0, function* (volumeId, startDate, endDate, options = {}) {
            // verify required parameter 'volumeId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingHistoryVolumeDetails2', 'volumeId', volumeId);
            const localVarPath = `/billing/billing/history/volume/{volume_id}`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will receive hourly cost datapoints for a model evaluation for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Model Evaluation for a specific
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingModelEvaluationDetailsGraph: (resourceId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [resourceId_1, startDate_1, endDate_1, ...args_1], void 0, function* (resourceId, startDate, endDate, options = {}) {
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingModelEvaluationDetailsGraph', 'resourceId', resourceId);
            const localVarPath = `/billing/billing/history/model_evaluation/{resource_id}/graph`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve hourly cost datapoints for a serverles inference for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Serverless Inference for a specific
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingServerlessInferenceDetailsGraph: (resourceId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [resourceId_1, startDate_1, endDate_1, ...args_1], void 0, function* (resourceId, startDate, endDate, options = {}) {
            // verify required parameter 'resourceId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingServerlessInferenceDetailsGraph', 'resourceId', resourceId);
            const localVarPath = `/billing/billing/history/serverless_inference/{resource_id}/graph`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve hourly cost datapoints for a Snapshot for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Snapshot for a specific billing cycle
         * @param {number} snapshotId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingSnapshotDetailsGraph: (snapshotId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [snapshotId_1, startDate_1, endDate_1, ...args_1], void 0, function* (snapshotId, startDate, endDate, options = {}) {
            // verify required parameter 'snapshotId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingSnapshotDetailsGraph', 'snapshotId', snapshotId);
            const localVarPath = `/billing/billing/history/snapshot/{snapshot_id}/graph`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve hourly cost datapoints for a VM for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Virtual Machine for a specific billing cycle
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingVmDetailsGraph2: (vmId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [vmId_1, startDate_1, endDate_1, ...args_1], void 0, function* (vmId, startDate, endDate, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingVmDetailsGraph2', 'vmId', vmId);
            const localVarPath = `/billing/billing/history/virtual-machine/{vm_id}/graph`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will recieve hourly cost datapoints for a Volume for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Volume for a specific billing cycle
         * @param {number} volumeId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingVolumeDetailsGraph: (volumeId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [volumeId_1, startDate_1, endDate_1, ...args_1], void 0, function* (volumeId, startDate, endDate, options = {}) {
            // verify required parameter 'volumeId' is not null or undefined
            (0, common_1.assertParamExists)('getUserBillingVolumeDetailsGraph', 'volumeId', volumeId);
            const localVarPath = `/billing/billing/history/volume/{volume_id}/graph`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will receive vm billing events history
         * @summary Retrieve VM billing events history
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVmBillingEvents: (vmId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [vmId_1, startDate_1, endDate_1, ...args_1], void 0, function* (vmId, startDate, endDate, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getUserVmBillingEvents', 'vmId', vmId);
            const localVarPath = `/billing/billing/virtual-machine/{vm_id}/billing-events`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User will receive volume billing events history
         * @summary Retrieve Volume billing events history
         * @param {number} volumeId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVolumeBillingEvents: (volumeId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [volumeId_1, startDate_1, endDate_1, ...args_1], void 0, function* (volumeId, startDate, endDate, options = {}) {
            // verify required parameter 'volumeId' is not null or undefined
            (0, common_1.assertParamExists)('getUserVolumeBillingEvents', 'volumeId', volumeId);
            const localVarPath = `/billing/billing/volume/{volume_id}/billing-events`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * By default, you are subscribed to all the threshold values and you will be receiving the email notification for these default thresholds values. `false` indicates that the user will no longer receive notifications for this specific threshold, whereas `true` signifies that the user will receive notification emails.
         * @summary Update: Subscribe or Unsubscribe Notification Threshold
         * @param {number} thresholdId
         * @param {SubscribeOrUnsubscribeUpdatePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrganizationThreshold: (thresholdId_1, payload_1, ...args_1) => __awaiter(this, [thresholdId_1, payload_1, ...args_1], void 0, function* (thresholdId, payload, options = {}) {
            // verify required parameter 'thresholdId' is not null or undefined
            (0, common_1.assertParamExists)('putOrganizationThreshold', 'thresholdId', thresholdId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('putOrganizationThreshold', 'payload', payload);
            const localVarPath = `/billing/billing/threshold/{threshold_id}`
                .replace(`{${"threshold_id"}}`, encodeURIComponent(String(thresholdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BillingApiAxiosParamCreator = BillingApiAxiosParamCreator;
/**
 * BillingApi - functional programming interface
 * @export
 */
const BillingApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BillingApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve the previous day\'s costs for instances, volumes, and clusters. Returns a breakdown of  the costs and the total cost for the last day. For additional information on Retrieve Previous Day Usage Costs, [**click here**](None/docs/api-reference/billing-resources/last-day-usage/)
         * @summary GET: Last Day Cost
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastDayCost(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLastDayCost(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getLastDayCost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve all the notification thresholds for an organization.
         * @summary GET: All Thresholds for Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationThreshold(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationThreshold(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getOrganizationThreshold']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve active billing metrics for the organization\'s resources, including pricing, uptime, and total cost. Returns usage details for each active resource by defualt(`deleted=false` will return active resources). Additionally, adding `deleted=true` in query parameter will return inactive resources. For additional information on view usage costs for all resources, [**click here**](None/docs/billing/pricebook/)
         * @summary GET: Billing usage
         * @param {string} [deleted] &#x60;true&#x60; will return inactive resources and &#x60;false&#x60; will return active resources. By defualt(&#x60;deleted&#x3D;false&#x60;)
         * @param {string} [environment] Filter resources by environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage2(deleted, environment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsage2(deleted, environment, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUsage2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve hourly cost datapoints for a Bucket for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Bucket for a specific billing cycle
         * @param {number} bucketId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingBucketDetailsGraph(bucketId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingBucketDetailsGraph(bucketId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingBucketDetailsGraph']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will receive hourly cost datapoints for a Cluster for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a specific Cluster for a specific billing cycle
         * @param {number} clusterId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingClusterDetailsGraph(clusterId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingClusterDetailsGraph(clusterId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingClusterDetailsGraph']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will receive hourly cost datapoints for a data synthesis job for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Data Synthesis for a specific
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingDataSynthesisDetailsGraph(resourceId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingDataSynthesisDetailsGraph(resourceId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingDataSynthesisDetailsGraph']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve hourly cost datapoints for a Fine Tunings for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Fine Tuning for a specific billing cycle
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingFineTuningDetailsGraph(resourceId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingFineTuningDetailsGraph(resourceId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingFineTuningDetailsGraph']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history for the specified billing cycle. This data will include \'incurred_bill\', \'non_discounted_bill\', \'vm_cost\', \'volume_cost\'
         * @summary Retrieve Billing History for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [graph] Set this value to \&quot;true\&quot; for getting graph value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistory2(startDate, endDate, graph, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistory2(startDate, endDate, graph, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistory2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of buckets for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Volume for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryBucket2(startDate, endDate, search, perPage, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryBucket2(startDate, endDate, search, perPage, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryBucket2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve billing history of a specific Bucket for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} bucketId
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryBucketDetails(bucketId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryBucketDetails(bucketId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryBucketDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will receive billing history of clusters for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Clusters for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryCluster(startDate, endDate, search, perPage, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryCluster(startDate, endDate, search, perPage, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryCluster']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will receive billing history of a specific Cluster for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'.
         * @summary Retrieve Billing History of a Specific Cluster for a specific Billing Cycle
         * @param {number} clusterId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryClusterDetails(clusterId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryClusterDetails(clusterId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryClusterDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of contracts for the specified billing cycle. This data will include \'description\', gpu_type\',\'infrahub_id\', \'status\', \'incurred_bill\', \'price_per_hour\'
         * @summary Retrieve Billing History of Contract for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by Contract \&quot;Description\&quot; or \&quot;ID\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryContract(startDate, endDate, search, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryContract(startDate, endDate, search, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryContract']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of data_synthesis for the specified billing cycle.
         * @summary Retrieve Billing History of data synthesis for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryDataSynthesis(startDate, endDate, search, perPage, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryDataSynthesis(startDate, endDate, search, perPage, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryDataSynthesis']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve billing history for a specific Data Synthesis resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryDataSynthesisDetails(resourceId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryDataSynthesisDetails(resourceId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryDataSynthesisDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of fine_tuning for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryFineTuning(startDate, endDate, search, perPage, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryFineTuning(startDate, endDate, search, perPage, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryFineTuning']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve billing history of a specific Fine tunning for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Fine Tuning for a specific Billing Cycle
         * @param {number} resourceId
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryFineTuningDetails(resourceId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryFineTuningDetails(resourceId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryFineTuningDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of model_evaluation for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryModelEvaluation(startDate, endDate, search, perPage, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryModelEvaluation(startDate, endDate, search, perPage, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryModelEvaluation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve billing history for a specific Model Evaluation resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryModelEvaluationDetails(resourceId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryModelEvaluationDetails(resourceId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryModelEvaluationDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of serverless_inference for the specified billing cycle.
         * @summary Retrieve Billing History of serverless inference for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryServerlessInference(startDate, endDate, search, perPage, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryServerlessInference(startDate, endDate, search, perPage, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryServerlessInference']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve billing history for a specific Serverless Inference resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryServerlessInferenceDetails(resourceId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryServerlessInferenceDetails(resourceId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryServerlessInferenceDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of snapshots for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Snapshot for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistorySnapshot(startDate, endDate, search, perPage, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistorySnapshot(startDate, endDate, search, perPage, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistorySnapshot']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve billing history of a specific Snapshot for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} snapshotId
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistorySnapshotDetails(snapshotId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistorySnapshotDetails(snapshotId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistorySnapshotDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of virtual machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Virtual Machine for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVm2(startDate, endDate, search, perPage, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryVm2(startDate, endDate, search, perPage, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryVm2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of a specific Virtual Machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'
         * @summary Retrieve Billing History of a Specific Virtual Machine for a specific Billing Cycle
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVmDetails2(vmId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryVmDetails2(vmId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryVmDetails2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve sub-resources historical cost datapoints for a VM sub resources for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. Machine sub resources for a specific billing cycle
         * @summary Retrieve Sub-Resources Historical Cost datapoints of a Virtual
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVmSubResourceGraph2(vmId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryVmSubResourceGraph2(vmId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryVmSubResourceGraph2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will get total costs and non_discount costs of sub resources on a specific Virtual Machine for the specified billing cycle. on a Specific VM for the Specified Billing Cycle
         * @summary Retrieve Total Costs and Non Discount Costs for Sub Resources
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVmTotalCosts(vmId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryVmTotalCosts(vmId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryVmTotalCosts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve billing history of volumes for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Volume for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVolume2(startDate, endDate, search, perPage, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryVolume2(startDate, endDate, search, perPage, page, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryVolume2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve billing history of a specific Volume for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Volume for a specific Billing Cycle
         * @param {number} volumeId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVolumeDetails2(volumeId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingHistoryVolumeDetails2(volumeId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingHistoryVolumeDetails2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will receive hourly cost datapoints for a model evaluation for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Model Evaluation for a specific
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingModelEvaluationDetailsGraph(resourceId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingModelEvaluationDetailsGraph(resourceId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingModelEvaluationDetailsGraph']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve hourly cost datapoints for a serverles inference for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Serverless Inference for a specific
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingServerlessInferenceDetailsGraph(resourceId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingServerlessInferenceDetailsGraph(resourceId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingServerlessInferenceDetailsGraph']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve hourly cost datapoints for a Snapshot for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Snapshot for a specific billing cycle
         * @param {number} snapshotId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingSnapshotDetailsGraph(snapshotId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingSnapshotDetailsGraph(snapshotId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingSnapshotDetailsGraph']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve hourly cost datapoints for a VM for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Virtual Machine for a specific billing cycle
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingVmDetailsGraph2(vmId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingVmDetailsGraph2(vmId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingVmDetailsGraph2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will recieve hourly cost datapoints for a Volume for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Volume for a specific billing cycle
         * @param {number} volumeId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingVolumeDetailsGraph(volumeId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserBillingVolumeDetailsGraph(volumeId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserBillingVolumeDetailsGraph']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will receive vm billing events history
         * @summary Retrieve VM billing events history
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVmBillingEvents(vmId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserVmBillingEvents(vmId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserVmBillingEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * User will receive volume billing events history
         * @summary Retrieve Volume billing events history
         * @param {number} volumeId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVolumeBillingEvents(volumeId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserVolumeBillingEvents(volumeId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.getUserVolumeBillingEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * By default, you are subscribed to all the threshold values and you will be receiving the email notification for these default thresholds values. `false` indicates that the user will no longer receive notifications for this specific threshold, whereas `true` signifies that the user will receive notification emails.
         * @summary Update: Subscribe or Unsubscribe Notification Threshold
         * @param {number} thresholdId
         * @param {SubscribeOrUnsubscribeUpdatePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrganizationThreshold(thresholdId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.putOrganizationThreshold(thresholdId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BillingApi.putOrganizationThreshold']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.BillingApiFp = BillingApiFp;
/**
 * BillingApi - factory interface
 * @export
 */
const BillingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BillingApiFp)(configuration);
    return {
        /**
         * Retrieve the previous day\'s costs for instances, volumes, and clusters. Returns a breakdown of  the costs and the total cost for the last day. For additional information on Retrieve Previous Day Usage Costs, [**click here**](None/docs/api-reference/billing-resources/last-day-usage/)
         * @summary GET: Last Day Cost
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastDayCost(options) {
            return localVarFp.getLastDayCost(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all the notification thresholds for an organization.
         * @summary GET: All Thresholds for Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationThreshold(options) {
            return localVarFp.getOrganizationThreshold(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve active billing metrics for the organization\'s resources, including pricing, uptime, and total cost. Returns usage details for each active resource by defualt(`deleted=false` will return active resources). Additionally, adding `deleted=true` in query parameter will return inactive resources. For additional information on view usage costs for all resources, [**click here**](None/docs/billing/pricebook/)
         * @summary GET: Billing usage
         * @param {string} [deleted] &#x60;true&#x60; will return inactive resources and &#x60;false&#x60; will return active resources. By defualt(&#x60;deleted&#x3D;false&#x60;)
         * @param {string} [environment] Filter resources by environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage2(deleted, environment, options) {
            return localVarFp.getUsage2(deleted, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve hourly cost datapoints for a Bucket for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Bucket for a specific billing cycle
         * @param {number} bucketId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingBucketDetailsGraph(bucketId, startDate, endDate, options) {
            return localVarFp.getUserBillingBucketDetailsGraph(bucketId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a Cluster for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a specific Cluster for a specific billing cycle
         * @param {number} clusterId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingClusterDetailsGraph(clusterId, startDate, endDate, options) {
            return localVarFp.getUserBillingClusterDetailsGraph(clusterId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a data synthesis job for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Data Synthesis for a specific
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingDataSynthesisDetailsGraph(resourceId, startDate, endDate, options) {
            return localVarFp.getUserBillingDataSynthesisDetailsGraph(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve hourly cost datapoints for a Fine Tunings for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Fine Tuning for a specific billing cycle
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingFineTuningDetailsGraph(resourceId, startDate, endDate, options) {
            return localVarFp.getUserBillingFineTuningDetailsGraph(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history for the specified billing cycle. This data will include \'incurred_bill\', \'non_discounted_bill\', \'vm_cost\', \'volume_cost\'
         * @summary Retrieve Billing History for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [graph] Set this value to \&quot;true\&quot; for getting graph value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistory2(startDate, endDate, graph, options) {
            return localVarFp.getUserBillingHistory2(startDate, endDate, graph, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of buckets for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Volume for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryBucket2(startDate, endDate, search, perPage, page, options) {
            return localVarFp.getUserBillingHistoryBucket2(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history of a specific Bucket for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} bucketId
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryBucketDetails(bucketId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryBucketDetails(bucketId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of clusters for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Clusters for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryCluster(startDate, endDate, search, perPage, page, options) {
            return localVarFp.getUserBillingHistoryCluster(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of a specific Cluster for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'.
         * @summary Retrieve Billing History of a Specific Cluster for a specific Billing Cycle
         * @param {number} clusterId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryClusterDetails(clusterId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryClusterDetails(clusterId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of contracts for the specified billing cycle. This data will include \'description\', gpu_type\',\'infrahub_id\', \'status\', \'incurred_bill\', \'price_per_hour\'
         * @summary Retrieve Billing History of Contract for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by Contract \&quot;Description\&quot; or \&quot;ID\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryContract(startDate, endDate, search, options) {
            return localVarFp.getUserBillingHistoryContract(startDate, endDate, search, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of data_synthesis for the specified billing cycle.
         * @summary Retrieve Billing History of data synthesis for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryDataSynthesis(startDate, endDate, search, perPage, page, options) {
            return localVarFp.getUserBillingHistoryDataSynthesis(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history for a specific Data Synthesis resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryDataSynthesisDetails(resourceId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryDataSynthesisDetails(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of fine_tuning for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryFineTuning(startDate, endDate, search, perPage, page, options) {
            return localVarFp.getUserBillingHistoryFineTuning(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history of a specific Fine tunning for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Fine Tuning for a specific Billing Cycle
         * @param {number} resourceId
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryFineTuningDetails(resourceId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryFineTuningDetails(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of model_evaluation for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryModelEvaluation(startDate, endDate, search, perPage, page, options) {
            return localVarFp.getUserBillingHistoryModelEvaluation(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history for a specific Model Evaluation resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryModelEvaluationDetails(resourceId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryModelEvaluationDetails(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of serverless_inference for the specified billing cycle.
         * @summary Retrieve Billing History of serverless inference for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryServerlessInference(startDate, endDate, search, perPage, page, options) {
            return localVarFp.getUserBillingHistoryServerlessInference(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history for a specific Serverless Inference resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryServerlessInferenceDetails(resourceId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryServerlessInferenceDetails(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of snapshots for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Snapshot for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistorySnapshot(startDate, endDate, search, perPage, page, options) {
            return localVarFp.getUserBillingHistorySnapshot(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history of a specific Snapshot for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} snapshotId
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistorySnapshotDetails(snapshotId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistorySnapshotDetails(snapshotId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of virtual machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Virtual Machine for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVm2(startDate, endDate, search, perPage, page, options) {
            return localVarFp.getUserBillingHistoryVm2(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of a specific Virtual Machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'
         * @summary Retrieve Billing History of a Specific Virtual Machine for a specific Billing Cycle
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVmDetails2(vmId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryVmDetails2(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve sub-resources historical cost datapoints for a VM sub resources for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. Machine sub resources for a specific billing cycle
         * @summary Retrieve Sub-Resources Historical Cost datapoints of a Virtual
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVmSubResourceGraph2(vmId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryVmSubResourceGraph2(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will get total costs and non_discount costs of sub resources on a specific Virtual Machine for the specified billing cycle. on a Specific VM for the Specified Billing Cycle
         * @summary Retrieve Total Costs and Non Discount Costs for Sub Resources
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVmTotalCosts(vmId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryVmTotalCosts(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve billing history of volumes for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Volume for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVolume2(startDate, endDate, search, perPage, page, options) {
            return localVarFp.getUserBillingHistoryVolume2(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history of a specific Volume for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Volume for a specific Billing Cycle
         * @param {number} volumeId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistoryVolumeDetails2(volumeId, startDate, endDate, options) {
            return localVarFp.getUserBillingHistoryVolumeDetails2(volumeId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a model evaluation for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Model Evaluation for a specific
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingModelEvaluationDetailsGraph(resourceId, startDate, endDate, options) {
            return localVarFp.getUserBillingModelEvaluationDetailsGraph(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve hourly cost datapoints for a serverles inference for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Serverless Inference for a specific
         * @param {number} resourceId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingServerlessInferenceDetailsGraph(resourceId, startDate, endDate, options) {
            return localVarFp.getUserBillingServerlessInferenceDetailsGraph(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve hourly cost datapoints for a Snapshot for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Snapshot for a specific billing cycle
         * @param {number} snapshotId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingSnapshotDetailsGraph(snapshotId, startDate, endDate, options) {
            return localVarFp.getUserBillingSnapshotDetailsGraph(snapshotId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve hourly cost datapoints for a VM for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Virtual Machine for a specific billing cycle
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingVmDetailsGraph2(vmId, startDate, endDate, options) {
            return localVarFp.getUserBillingVmDetailsGraph2(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will recieve hourly cost datapoints for a Volume for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Volume for a specific billing cycle
         * @param {number} volumeId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingVolumeDetailsGraph(volumeId, startDate, endDate, options) {
            return localVarFp.getUserBillingVolumeDetailsGraph(volumeId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive vm billing events history
         * @summary Retrieve VM billing events history
         * @param {number} vmId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVmBillingEvents(vmId, startDate, endDate, options) {
            return localVarFp.getUserVmBillingEvents(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive volume billing events history
         * @summary Retrieve Volume billing events history
         * @param {number} volumeId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserVolumeBillingEvents(volumeId, startDate, endDate, options) {
            return localVarFp.getUserVolumeBillingEvents(volumeId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, you are subscribed to all the threshold values and you will be receiving the email notification for these default thresholds values. `false` indicates that the user will no longer receive notifications for this specific threshold, whereas `true` signifies that the user will receive notification emails.
         * @summary Update: Subscribe or Unsubscribe Notification Threshold
         * @param {number} thresholdId
         * @param {SubscribeOrUnsubscribeUpdatePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrganizationThreshold(thresholdId, payload, options) {
            return localVarFp.putOrganizationThreshold(thresholdId, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BillingApiFactory = BillingApiFactory;
/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
class BillingApi extends base_1.BaseAPI {
    /**
     * Retrieve the previous day\'s costs for instances, volumes, and clusters. Returns a breakdown of  the costs and the total cost for the last day. For additional information on Retrieve Previous Day Usage Costs, [**click here**](None/docs/api-reference/billing-resources/last-day-usage/)
     * @summary GET: Last Day Cost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getLastDayCost(options) {
        return (0, exports.BillingApiFp)(this.configuration).getLastDayCost(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all the notification thresholds for an organization.
     * @summary GET: All Thresholds for Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getOrganizationThreshold(options) {
        return (0, exports.BillingApiFp)(this.configuration).getOrganizationThreshold(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve active billing metrics for the organization\'s resources, including pricing, uptime, and total cost. Returns usage details for each active resource by defualt(`deleted=false` will return active resources). Additionally, adding `deleted=true` in query parameter will return inactive resources. For additional information on view usage costs for all resources, [**click here**](None/docs/billing/pricebook/)
     * @summary GET: Billing usage
     * @param {string} [deleted] &#x60;true&#x60; will return inactive resources and &#x60;false&#x60; will return active resources. By defualt(&#x60;deleted&#x3D;false&#x60;)
     * @param {string} [environment] Filter resources by environment ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUsage2(deleted, environment, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUsage2(deleted, environment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve hourly cost datapoints for a Bucket for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Bucket for a specific billing cycle
     * @param {number} bucketId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingBucketDetailsGraph(bucketId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingBucketDetailsGraph(bucketId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will receive hourly cost datapoints for a Cluster for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a specific Cluster for a specific billing cycle
     * @param {number} clusterId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingClusterDetailsGraph(clusterId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingClusterDetailsGraph(clusterId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will receive hourly cost datapoints for a data synthesis job for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
     * @summary Retrieve hourly cost datapoints of a Specific Data Synthesis for a specific
     * @param {number} resourceId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingDataSynthesisDetailsGraph(resourceId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingDataSynthesisDetailsGraph(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve hourly cost datapoints for a Fine Tunings for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Fine Tuning for a specific billing cycle
     * @param {number} resourceId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingFineTuningDetailsGraph(resourceId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingFineTuningDetailsGraph(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history for the specified billing cycle. This data will include \'incurred_bill\', \'non_discounted_bill\', \'vm_cost\', \'volume_cost\'
     * @summary Retrieve Billing History for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [graph] Set this value to \&quot;true\&quot; for getting graph value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistory2(startDate, endDate, graph, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistory2(startDate, endDate, graph, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of buckets for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of Volume for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryBucket2(startDate, endDate, search, perPage, page, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryBucket2(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve billing history of a specific Bucket for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
     * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
     * @param {number} bucketId
     * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryBucketDetails(bucketId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryBucketDetails(bucketId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will receive billing history of clusters for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of Clusters for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryCluster(startDate, endDate, search, perPage, page, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryCluster(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will receive billing history of a specific Cluster for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'.
     * @summary Retrieve Billing History of a Specific Cluster for a specific Billing Cycle
     * @param {number} clusterId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryClusterDetails(clusterId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryClusterDetails(clusterId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of contracts for the specified billing cycle. This data will include \'description\', gpu_type\',\'infrahub_id\', \'status\', \'incurred_bill\', \'price_per_hour\'
     * @summary Retrieve Billing History of Contract for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by Contract \&quot;Description\&quot; or \&quot;ID\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryContract(startDate, endDate, search, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryContract(startDate, endDate, search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of data_synthesis for the specified billing cycle.
     * @summary Retrieve Billing History of data synthesis for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryDataSynthesis(startDate, endDate, search, perPage, page, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryDataSynthesis(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve billing history for a specific Data Synthesis resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
     * @param {number} resourceId
     * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryDataSynthesisDetails(resourceId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryDataSynthesisDetails(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of fine_tuning for the specified billing cycle.
     * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryFineTuning(startDate, endDate, search, perPage, page, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryFineTuning(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve billing history of a specific Fine tunning for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
     * @summary Retrieve Billing History of a Specific Fine Tuning for a specific Billing Cycle
     * @param {number} resourceId
     * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryFineTuningDetails(resourceId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryFineTuningDetails(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of model_evaluation for the specified billing cycle.
     * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryModelEvaluation(startDate, endDate, search, perPage, page, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryModelEvaluation(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve billing history for a specific Model Evaluation resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
     * @param {number} resourceId
     * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryModelEvaluationDetails(resourceId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryModelEvaluationDetails(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of serverless_inference for the specified billing cycle.
     * @summary Retrieve Billing History of serverless inference for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryServerlessInference(startDate, endDate, search, perPage, page, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryServerlessInference(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve billing history for a specific Serverless Inference resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
     * @param {number} resourceId
     * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryServerlessInferenceDetails(resourceId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryServerlessInferenceDetails(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of snapshots for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of Snapshot for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistorySnapshot(startDate, endDate, search, perPage, page, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistorySnapshot(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve billing history of a specific Snapshot for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
     * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
     * @param {number} snapshotId
     * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistorySnapshotDetails(snapshotId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistorySnapshotDetails(snapshotId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of virtual machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of Virtual Machine for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryVm2(startDate, endDate, search, perPage, page, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryVm2(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of a specific Virtual Machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'
     * @summary Retrieve Billing History of a Specific Virtual Machine for a specific Billing Cycle
     * @param {number} vmId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryVmDetails2(vmId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryVmDetails2(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve sub-resources historical cost datapoints for a VM sub resources for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. Machine sub resources for a specific billing cycle
     * @summary Retrieve Sub-Resources Historical Cost datapoints of a Virtual
     * @param {number} vmId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryVmSubResourceGraph2(vmId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryVmSubResourceGraph2(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will get total costs and non_discount costs of sub resources on a specific Virtual Machine for the specified billing cycle. on a Specific VM for the Specified Billing Cycle
     * @summary Retrieve Total Costs and Non Discount Costs for Sub Resources
     * @param {number} vmId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryVmTotalCosts(vmId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryVmTotalCosts(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve billing history of volumes for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of Volume for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryVolume2(startDate, endDate, search, perPage, page, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryVolume2(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve billing history of a specific Volume for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
     * @summary Retrieve Billing History of a Specific Volume for a specific Billing Cycle
     * @param {number} volumeId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingHistoryVolumeDetails2(volumeId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingHistoryVolumeDetails2(volumeId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will receive hourly cost datapoints for a model evaluation for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
     * @summary Retrieve hourly cost datapoints of a Specific Model Evaluation for a specific
     * @param {number} resourceId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingModelEvaluationDetailsGraph(resourceId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingModelEvaluationDetailsGraph(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve hourly cost datapoints for a serverles inference for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
     * @summary Retrieve hourly cost datapoints of a Specific Serverless Inference for a specific
     * @param {number} resourceId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingServerlessInferenceDetailsGraph(resourceId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingServerlessInferenceDetailsGraph(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve hourly cost datapoints for a Snapshot for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Snapshot for a specific billing cycle
     * @param {number} snapshotId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingSnapshotDetailsGraph(snapshotId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingSnapshotDetailsGraph(snapshotId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve hourly cost datapoints for a VM for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Virtual Machine for a specific billing cycle
     * @param {number} vmId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingVmDetailsGraph2(vmId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingVmDetailsGraph2(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will recieve hourly cost datapoints for a Volume for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Volume for a specific billing cycle
     * @param {number} volumeId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserBillingVolumeDetailsGraph(volumeId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserBillingVolumeDetailsGraph(volumeId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will receive vm billing events history
     * @summary Retrieve VM billing events history
     * @param {number} vmId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserVmBillingEvents(vmId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserVmBillingEvents(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User will receive volume billing events history
     * @summary Retrieve Volume billing events history
     * @param {number} volumeId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    getUserVolumeBillingEvents(volumeId, startDate, endDate, options) {
        return (0, exports.BillingApiFp)(this.configuration).getUserVolumeBillingEvents(volumeId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * By default, you are subscribed to all the threshold values and you will be receiving the email notification for these default thresholds values. `false` indicates that the user will no longer receive notifications for this specific threshold, whereas `true` signifies that the user will receive notification emails.
     * @summary Update: Subscribe or Unsubscribe Notification Threshold
     * @param {number} thresholdId
     * @param {SubscribeOrUnsubscribeUpdatePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    putOrganizationThreshold(thresholdId, payload, options) {
        return (0, exports.BillingApiFp)(this.configuration).putOrganizationThreshold(thresholdId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BillingApi = BillingApi;
/**
 * CalculateApi - axios parameter creator
 * @export
 */
const CalculateApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Calculate the hourly billing rate of a specified resource by including the resource ID in the path.
         * @summary Retrieve Billing Rate for Resource
         * @param {string} resourceType
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculate2: (resourceType_1, id_1, ...args_1) => __awaiter(this, [resourceType_1, id_1, ...args_1], void 0, function* (resourceType, id, options = {}) {
            // verify required parameter 'resourceType' is not null or undefined
            (0, common_1.assertParamExists)('getCalculate2', 'resourceType', resourceType);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getCalculate2', 'id', id);
            const localVarPath = `/pricebook/calculate/resource/{resource_type}/{id}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CalculateApiAxiosParamCreator = CalculateApiAxiosParamCreator;
/**
 * CalculateApi - functional programming interface
 * @export
 */
const CalculateApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CalculateApiAxiosParamCreator)(configuration);
    return {
        /**
         * Calculate the hourly billing rate of a specified resource by including the resource ID in the path.
         * @summary Retrieve Billing Rate for Resource
         * @param {string} resourceType
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculate2(resourceType, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCalculate2(resourceType, id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CalculateApi.getCalculate2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.CalculateApiFp = CalculateApiFp;
/**
 * CalculateApi - factory interface
 * @export
 */
const CalculateApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CalculateApiFp)(configuration);
    return {
        /**
         * Calculate the hourly billing rate of a specified resource by including the resource ID in the path.
         * @summary Retrieve Billing Rate for Resource
         * @param {string} resourceType
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculate2(resourceType, id, options) {
            return localVarFp.getCalculate2(resourceType, id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CalculateApiFactory = CalculateApiFactory;
/**
 * CalculateApi - object-oriented interface
 * @export
 * @class CalculateApi
 * @extends {BaseAPI}
 */
class CalculateApi extends base_1.BaseAPI {
    /**
     * Calculate the hourly billing rate of a specified resource by including the resource ID in the path.
     * @summary Retrieve Billing Rate for Resource
     * @param {string} resourceType
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalculateApi
     */
    getCalculate2(resourceType, id, options) {
        return (0, exports.CalculateApiFp)(this.configuration).getCalculate2(resourceType, id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CalculateApi = CalculateApi;
/**
 * CallbacksApi - axios parameter creator
 * @export
 */
const CallbacksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a callback URL for a specified virtual machine, enabling the posting of action events executed on the virtual machine to the specified URL. Provide the callback URL in the request body and the ID of the virtual machine to which it is being attached in the path. For more details on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/attach-callback-vm).
         * @summary Attach callback to virtual machine
         * @param {number} vmId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVirtualMachine: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('attachCallbackToVirtualMachine', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('attachCallbackToVirtualMachine', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/attach-callback`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a callback URL for a specified volume, enabling the posting of action events executed on the volume to the specified URL. Provide the callback URL in the request body and the ID of the volume to which it is being attached in the path. For more details on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/attach-callback-volume).
         * @summary Attach callback to volume
         * @param {number} volumeId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVolume: (volumeId_1, payload_1, ...args_1) => __awaiter(this, [volumeId_1, payload_1, ...args_1], void 0, function* (volumeId, payload, options = {}) {
            // verify required parameter 'volumeId' is not null or undefined
            (0, common_1.assertParamExists)('attachCallbackToVolume', 'volumeId', volumeId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('attachCallbackToVolume', 'payload', payload);
            const localVarPath = `/core/volumes/{volume_id}/attach-callback`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Permanently deletes the callback URL associated with a specified virtual machine by providing the virtual machine ID in the request path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/delete-callback-vm).
         * @summary Delete virtual machine callback
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualMachineCallback: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('deleteVirtualMachineCallback', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/delete-callback`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Permanently deletes the callback URL associated with a specified volume by providing the volume ID in the request path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/delete-callback-volume).
         * @summary Delete volume callback
         * @param {number} volumeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolumeCallback: (volumeId_1, ...args_1) => __awaiter(this, [volumeId_1, ...args_1], void 0, function* (volumeId, options = {}) {
            // verify required parameter 'volumeId' is not null or undefined
            (0, common_1.assertParamExists)('deleteVolumeCallback', 'volumeId', volumeId);
            const localVarPath = `/core/volumes/{volume_id}/delete-callback`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the callback URL for a specified virtual machine. Provide the new callback URL in the request body, along with the ID of the associated virtual machine in the path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms).
         * @summary Update virtual machine callback
         * @param {number} vmId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualMachineCallback: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('updateVirtualMachineCallback', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateVirtualMachineCallback', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/update-callback`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the callback URL for a specified volume. Provide the new callback URL in the request body, along with the ID of the associated volume in the path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/update-callback-volume/).
         * @summary Update volume callback
         * @param {number} volumeId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolumeCallback: (volumeId_1, payload_1, ...args_1) => __awaiter(this, [volumeId_1, payload_1, ...args_1], void 0, function* (volumeId, payload, options = {}) {
            // verify required parameter 'volumeId' is not null or undefined
            (0, common_1.assertParamExists)('updateVolumeCallback', 'volumeId', volumeId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateVolumeCallback', 'payload', payload);
            const localVarPath = `/core/volumes/{volume_id}/update-callback`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CallbacksApiAxiosParamCreator = CallbacksApiAxiosParamCreator;
/**
 * CallbacksApi - functional programming interface
 * @export
 */
const CallbacksApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CallbacksApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a callback URL for a specified virtual machine, enabling the posting of action events executed on the virtual machine to the specified URL. Provide the callback URL in the request body and the ID of the virtual machine to which it is being attached in the path. For more details on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/attach-callback-vm).
         * @summary Attach callback to virtual machine
         * @param {number} vmId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVirtualMachine(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.attachCallbackToVirtualMachine(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CallbacksApi.attachCallbackToVirtualMachine']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a callback URL for a specified volume, enabling the posting of action events executed on the volume to the specified URL. Provide the callback URL in the request body and the ID of the volume to which it is being attached in the path. For more details on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/attach-callback-volume).
         * @summary Attach callback to volume
         * @param {number} volumeId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVolume(volumeId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.attachCallbackToVolume(volumeId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CallbacksApi.attachCallbackToVolume']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Permanently deletes the callback URL associated with a specified virtual machine by providing the virtual machine ID in the request path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/delete-callback-vm).
         * @summary Delete virtual machine callback
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualMachineCallback(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteVirtualMachineCallback(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CallbacksApi.deleteVirtualMachineCallback']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Permanently deletes the callback URL associated with a specified volume by providing the volume ID in the request path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/delete-callback-volume).
         * @summary Delete volume callback
         * @param {number} volumeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolumeCallback(volumeId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteVolumeCallback(volumeId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CallbacksApi.deleteVolumeCallback']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the callback URL for a specified virtual machine. Provide the new callback URL in the request body, along with the ID of the associated virtual machine in the path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms).
         * @summary Update virtual machine callback
         * @param {number} vmId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualMachineCallback(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateVirtualMachineCallback(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CallbacksApi.updateVirtualMachineCallback']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the callback URL for a specified volume. Provide the new callback URL in the request body, along with the ID of the associated volume in the path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/update-callback-volume/).
         * @summary Update volume callback
         * @param {number} volumeId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolumeCallback(volumeId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateVolumeCallback(volumeId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CallbacksApi.updateVolumeCallback']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.CallbacksApiFp = CallbacksApiFp;
/**
 * CallbacksApi - factory interface
 * @export
 */
const CallbacksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CallbacksApiFp)(configuration);
    return {
        /**
         * Creates a callback URL for a specified virtual machine, enabling the posting of action events executed on the virtual machine to the specified URL. Provide the callback URL in the request body and the ID of the virtual machine to which it is being attached in the path. For more details on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/attach-callback-vm).
         * @summary Attach callback to virtual machine
         * @param {number} vmId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVirtualMachine(vmId, payload, options) {
            return localVarFp.attachCallbackToVirtualMachine(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a callback URL for a specified volume, enabling the posting of action events executed on the volume to the specified URL. Provide the callback URL in the request body and the ID of the volume to which it is being attached in the path. For more details on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/attach-callback-volume).
         * @summary Attach callback to volume
         * @param {number} volumeId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVolume(volumeId, payload, options) {
            return localVarFp.attachCallbackToVolume(volumeId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes the callback URL associated with a specified virtual machine by providing the virtual machine ID in the request path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/delete-callback-vm).
         * @summary Delete virtual machine callback
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualMachineCallback(vmId, options) {
            return localVarFp.deleteVirtualMachineCallback(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes the callback URL associated with a specified volume by providing the volume ID in the request path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/delete-callback-volume).
         * @summary Delete volume callback
         * @param {number} volumeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolumeCallback(volumeId, options) {
            return localVarFp.deleteVolumeCallback(volumeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the callback URL for a specified virtual machine. Provide the new callback URL in the request body, along with the ID of the associated virtual machine in the path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms).
         * @summary Update virtual machine callback
         * @param {number} vmId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualMachineCallback(vmId, payload, options) {
            return localVarFp.updateVirtualMachineCallback(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the callback URL for a specified volume. Provide the new callback URL in the request body, along with the ID of the associated volume in the path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/update-callback-volume/).
         * @summary Update volume callback
         * @param {number} volumeId
         * @param {AttachCallbackPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolumeCallback(volumeId, payload, options) {
            return localVarFp.updateVolumeCallback(volumeId, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CallbacksApiFactory = CallbacksApiFactory;
/**
 * CallbacksApi - object-oriented interface
 * @export
 * @class CallbacksApi
 * @extends {BaseAPI}
 */
class CallbacksApi extends base_1.BaseAPI {
    /**
     * Creates a callback URL for a specified virtual machine, enabling the posting of action events executed on the virtual machine to the specified URL. Provide the callback URL in the request body and the ID of the virtual machine to which it is being attached in the path. For more details on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/attach-callback-vm).
     * @summary Attach callback to virtual machine
     * @param {number} vmId
     * @param {AttachCallbackPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    attachCallbackToVirtualMachine(vmId, payload, options) {
        return (0, exports.CallbacksApiFp)(this.configuration).attachCallbackToVirtualMachine(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a callback URL for a specified volume, enabling the posting of action events executed on the volume to the specified URL. Provide the callback URL in the request body and the ID of the volume to which it is being attached in the path. For more details on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/attach-callback-volume).
     * @summary Attach callback to volume
     * @param {number} volumeId
     * @param {AttachCallbackPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    attachCallbackToVolume(volumeId, payload, options) {
        return (0, exports.CallbacksApiFp)(this.configuration).attachCallbackToVolume(volumeId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Permanently deletes the callback URL associated with a specified virtual machine by providing the virtual machine ID in the request path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/delete-callback-vm).
     * @summary Delete virtual machine callback
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    deleteVirtualMachineCallback(vmId, options) {
        return (0, exports.CallbacksApiFp)(this.configuration).deleteVirtualMachineCallback(vmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Permanently deletes the callback URL associated with a specified volume by providing the volume ID in the request path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/delete-callback-volume).
     * @summary Delete volume callback
     * @param {number} volumeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    deleteVolumeCallback(volumeId, options) {
        return (0, exports.CallbacksApiFp)(this.configuration).deleteVolumeCallback(volumeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the callback URL for a specified virtual machine. Provide the new callback URL in the request body, along with the ID of the associated virtual machine in the path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms).
     * @summary Update virtual machine callback
     * @param {number} vmId
     * @param {AttachCallbackPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    updateVirtualMachineCallback(vmId, payload, options) {
        return (0, exports.CallbacksApiFp)(this.configuration).updateVirtualMachineCallback(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the callback URL for a specified volume. Provide the new callback URL in the request body, along with the ID of the associated volume in the path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/update-callback-volume/).
     * @summary Update volume callback
     * @param {number} volumeId
     * @param {AttachCallbackPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    updateVolumeCallback(volumeId, payload, options) {
        return (0, exports.CallbacksApiFp)(this.configuration).updateVolumeCallback(volumeId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CallbacksApi = CallbacksApi;
/**
 * ClusterEventsApi - axios parameter creator
 * @export
 */
const ClusterEventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Fetch all of a cluster events
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllOfAClusterEvents: (clusterId_1, ...args_1) => __awaiter(this, [clusterId_1, ...args_1], void 0, function* (clusterId, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('fetchAllOfAClusterEvents', 'clusterId', clusterId);
            const localVarPath = `/core/clusters/{cluster_id}/events`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ClusterEventsApiAxiosParamCreator = ClusterEventsApiAxiosParamCreator;
/**
 * ClusterEventsApi - functional programming interface
 * @export
 */
const ClusterEventsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ClusterEventsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Fetch all of a cluster events
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllOfAClusterEvents(clusterId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchAllOfAClusterEvents(clusterId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClusterEventsApi.fetchAllOfAClusterEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ClusterEventsApiFp = ClusterEventsApiFp;
/**
 * ClusterEventsApi - factory interface
 * @export
 */
const ClusterEventsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ClusterEventsApiFp)(configuration);
    return {
        /**
         *
         * @summary Fetch all of a cluster events
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllOfAClusterEvents(clusterId, options) {
            return localVarFp.fetchAllOfAClusterEvents(clusterId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ClusterEventsApiFactory = ClusterEventsApiFactory;
/**
 * ClusterEventsApi - object-oriented interface
 * @export
 * @class ClusterEventsApi
 * @extends {BaseAPI}
 */
class ClusterEventsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Fetch all of a cluster events
     * @param {string} clusterId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterEventsApi
     */
    fetchAllOfAClusterEvents(clusterId, options) {
        return (0, exports.ClusterEventsApiFp)(this.configuration).fetchAllOfAClusterEvents(clusterId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ClusterEventsApi = ClusterEventsApi;
/**
 * ClustersApi - axios parameter creator
 * @export
 */
const ClustersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Reconcile a cluster
         * @param {number} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attemptToManuallyReconcileACluster: (clusterId_1, ...args_1) => __awaiter(this, [clusterId_1, ...args_1], void 0, function* (clusterId, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('attemptToManuallyReconcileACluster', 'clusterId', clusterId);
            const localVarPath = `/core/clusters/{cluster_id}/reconcile`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create Cluster
         * @param {CreateClusterPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createCluster', 'payload', payload);
            const localVarPath = `/core/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create Node
         * @param {number} clusterId
         * @param {CreateClusterNodeFields} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode: (clusterId_1, payload_1, ...args_1) => __awaiter(this, [clusterId_1, payload_1, ...args_1], void 0, function* (clusterId, payload, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('createNode', 'clusterId', clusterId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createNode', 'payload', payload);
            const localVarPath = `/core/clusters/{cluster_id}/nodes`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a node group in a cluster
         * @param {number} clusterId
         * @param {CreateClusterNodeGroupPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNodeGroup: (clusterId_1, payload_1, ...args_1) => __awaiter(this, [clusterId_1, payload_1, ...args_1], void 0, function* (clusterId, payload, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('createNodeGroup', 'clusterId', clusterId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createNodeGroup', 'payload', payload);
            const localVarPath = `/core/clusters/{cluster_id}/node-groups`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a cluster
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACluster: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteACluster', 'id', id);
            const localVarPath = `/core/clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a node group
         * @param {number} clusterId
         * @param {number} nodeGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteANodeGroup: (clusterId_1, nodeGroupId_1, ...args_1) => __awaiter(this, [clusterId_1, nodeGroupId_1, ...args_1], void 0, function* (clusterId, nodeGroupId, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('deleteANodeGroup', 'clusterId', clusterId);
            // verify required parameter 'nodeGroupId' is not null or undefined
            (0, common_1.assertParamExists)('deleteANodeGroup', 'nodeGroupId', nodeGroupId);
            const localVarPath = `/core/clusters/{cluster_id}/node-groups/{node_group_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_group_id"}}`, encodeURIComponent(String(nodeGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete Cluster Node
         * @param {number} clusterId
         * @param {number} nodeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterNode: (clusterId_1, nodeId_1, ...args_1) => __awaiter(this, [clusterId_1, nodeId_1, ...args_1], void 0, function* (clusterId, nodeId, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('deleteClusterNode', 'clusterId', clusterId);
            // verify required parameter 'nodeId' is not null or undefined
            (0, common_1.assertParamExists)('deleteClusterNode', 'nodeId', nodeId);
            const localVarPath = `/core/clusters/{cluster_id}/nodes/{node_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if a Cluster name is available
         * @summary Fetch cluster name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterNameAvailability: (name_1, ...args_1) => __awaiter(this, [name_1, ...args_1], void 0, function* (name, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('fetchClusterNameAvailability', 'name', name);
            const localVarPath = `/core/clusters/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Cluster Master Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMasterFlavors: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/clusters/master-flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Cluster Nodes
         * @param {number} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterNodes: (clusterId_1, ...args_1) => __awaiter(this, [clusterId_1, ...args_1], void 0, function* (clusterId, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('getClusterNodes', 'clusterId', clusterId);
            const localVarPath = `/core/clusters/{cluster_id}/nodes`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists available Kubernetes versions, optionally filtered by region.
         * @summary List Cluster Versions
         * @param {string} [region] Filter versions by region name (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterVersions: (region_1, ...args_1) => __awaiter(this, [region_1, ...args_1], void 0, function* (region, options = {}) {
            const localVarPath = `/core/clusters/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Getting Cluster Detail
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gettingClusterDetail: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('gettingClusterDetail', 'id', id);
            const localVarPath = `/core/clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Clusters
         * @param {number} [page] Page number for pagination
         * @param {number} [pageSize] Number of items per page
         * @param {string} [environment] Environment Filter
         * @param {string} [search] Search query to filter cluster by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters: (page_1, pageSize_1, environment_1, search_1, ...args_1) => __awaiter(this, [page_1, pageSize_1, environment_1, search_1, ...args_1], void 0, function* (page, pageSize, environment, search, options = {}) {
            const localVarPath = `/core/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List node groups for a cluster
         * @param {number} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeGroups: (clusterId_1, ...args_1) => __awaiter(this, [clusterId_1, ...args_1], void 0, function* (clusterId, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('listNodeGroups', 'clusterId', clusterId);
            const localVarPath = `/core/clusters/{cluster_id}/node-groups`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a node group in a cluster
         * @param {number} clusterId
         * @param {number} nodeGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveANodeGroup: (clusterId_1, nodeGroupId_1, ...args_1) => __awaiter(this, [clusterId_1, nodeGroupId_1, ...args_1], void 0, function* (clusterId, nodeGroupId, options = {}) {
            // verify required parameter 'clusterId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveANodeGroup', 'clusterId', clusterId);
            // verify required parameter 'nodeGroupId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveANodeGroup', 'nodeGroupId', nodeGroupId);
            const localVarPath = `/core/clusters/{cluster_id}/node-groups/{node_group_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_group_id"}}`, encodeURIComponent(String(nodeGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ClustersApiAxiosParamCreator = ClustersApiAxiosParamCreator;
/**
 * ClustersApi - functional programming interface
 * @export
 */
const ClustersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ClustersApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Reconcile a cluster
         * @param {number} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attemptToManuallyReconcileACluster(clusterId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.attemptToManuallyReconcileACluster(clusterId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.attemptToManuallyReconcileACluster']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create Cluster
         * @param {CreateClusterPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCluster(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.createCluster']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create Node
         * @param {number} clusterId
         * @param {CreateClusterNodeFields} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(clusterId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createNode(clusterId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.createNode']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create a node group in a cluster
         * @param {number} clusterId
         * @param {CreateClusterNodeGroupPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNodeGroup(clusterId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createNodeGroup(clusterId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.createNodeGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete a cluster
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACluster(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteACluster(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.deleteACluster']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete a node group
         * @param {number} clusterId
         * @param {number} nodeGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteANodeGroup(clusterId, nodeGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteANodeGroup(clusterId, nodeGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.deleteANodeGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete Cluster Node
         * @param {number} clusterId
         * @param {number} nodeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterNode(clusterId, nodeId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteClusterNode(clusterId, nodeId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.deleteClusterNode']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check if a Cluster name is available
         * @summary Fetch cluster name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterNameAvailability(name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchClusterNameAvailability(name, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.fetchClusterNameAvailability']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Cluster Master Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMasterFlavors(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getClusterMasterFlavors(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.getClusterMasterFlavors']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Cluster Nodes
         * @param {number} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterNodes(clusterId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getClusterNodes(clusterId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.getClusterNodes']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists available Kubernetes versions, optionally filtered by region.
         * @summary List Cluster Versions
         * @param {string} [region] Filter versions by region name (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterVersions(region, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getClusterVersions(region, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.getClusterVersions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Getting Cluster Detail
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gettingClusterDetail(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.gettingClusterDetail(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.gettingClusterDetail']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Clusters
         * @param {number} [page] Page number for pagination
         * @param {number} [pageSize] Number of items per page
         * @param {string} [environment] Environment Filter
         * @param {string} [search] Search query to filter cluster by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(page, pageSize, environment, search, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listClusters(page, pageSize, environment, search, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.listClusters']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List node groups for a cluster
         * @param {number} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeGroups(clusterId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listNodeGroups(clusterId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.listNodeGroups']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Retrieve a node group in a cluster
         * @param {number} clusterId
         * @param {number} nodeGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveANodeGroup(clusterId, nodeGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveANodeGroup(clusterId, nodeGroupId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ClustersApi.retrieveANodeGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ClustersApiFp = ClustersApiFp;
/**
 * ClustersApi - factory interface
 * @export
 */
const ClustersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ClustersApiFp)(configuration);
    return {
        /**
         *
         * @summary Reconcile a cluster
         * @param {number} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attemptToManuallyReconcileACluster(clusterId, options) {
            return localVarFp.attemptToManuallyReconcileACluster(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Cluster
         * @param {CreateClusterPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(payload, options) {
            return localVarFp.createCluster(payload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Node
         * @param {number} clusterId
         * @param {CreateClusterNodeFields} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(clusterId, payload, options) {
            return localVarFp.createNode(clusterId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a node group in a cluster
         * @param {number} clusterId
         * @param {CreateClusterNodeGroupPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNodeGroup(clusterId, payload, options) {
            return localVarFp.createNodeGroup(clusterId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a cluster
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACluster(id, options) {
            return localVarFp.deleteACluster(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a node group
         * @param {number} clusterId
         * @param {number} nodeGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteANodeGroup(clusterId, nodeGroupId, options) {
            return localVarFp.deleteANodeGroup(clusterId, nodeGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Cluster Node
         * @param {number} clusterId
         * @param {number} nodeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterNode(clusterId, nodeId, options) {
            return localVarFp.deleteClusterNode(clusterId, nodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Cluster name is available
         * @summary Fetch cluster name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterNameAvailability(name, options) {
            return localVarFp.fetchClusterNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Cluster Master Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMasterFlavors(options) {
            return localVarFp.getClusterMasterFlavors(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Cluster Nodes
         * @param {number} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterNodes(clusterId, options) {
            return localVarFp.getClusterNodes(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists available Kubernetes versions, optionally filtered by region.
         * @summary List Cluster Versions
         * @param {string} [region] Filter versions by region name (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterVersions(region, options) {
            return localVarFp.getClusterVersions(region, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getting Cluster Detail
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gettingClusterDetail(id, options) {
            return localVarFp.gettingClusterDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Clusters
         * @param {number} [page] Page number for pagination
         * @param {number} [pageSize] Number of items per page
         * @param {string} [environment] Environment Filter
         * @param {string} [search] Search query to filter cluster by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(page, pageSize, environment, search, options) {
            return localVarFp.listClusters(page, pageSize, environment, search, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List node groups for a cluster
         * @param {number} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeGroups(clusterId, options) {
            return localVarFp.listNodeGroups(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a node group in a cluster
         * @param {number} clusterId
         * @param {number} nodeGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveANodeGroup(clusterId, nodeGroupId, options) {
            return localVarFp.retrieveANodeGroup(clusterId, nodeGroupId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ClustersApiFactory = ClustersApiFactory;
/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
class ClustersApi extends base_1.BaseAPI {
    /**
     *
     * @summary Reconcile a cluster
     * @param {number} clusterId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    attemptToManuallyReconcileACluster(clusterId, options) {
        return (0, exports.ClustersApiFp)(this.configuration).attemptToManuallyReconcileACluster(clusterId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create Cluster
     * @param {CreateClusterPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    createCluster(payload, options) {
        return (0, exports.ClustersApiFp)(this.configuration).createCluster(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create Node
     * @param {number} clusterId
     * @param {CreateClusterNodeFields} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    createNode(clusterId, payload, options) {
        return (0, exports.ClustersApiFp)(this.configuration).createNode(clusterId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a node group in a cluster
     * @param {number} clusterId
     * @param {CreateClusterNodeGroupPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    createNodeGroup(clusterId, payload, options) {
        return (0, exports.ClustersApiFp)(this.configuration).createNodeGroup(clusterId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a cluster
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    deleteACluster(id, options) {
        return (0, exports.ClustersApiFp)(this.configuration).deleteACluster(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a node group
     * @param {number} clusterId
     * @param {number} nodeGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    deleteANodeGroup(clusterId, nodeGroupId, options) {
        return (0, exports.ClustersApiFp)(this.configuration).deleteANodeGroup(clusterId, nodeGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Cluster Node
     * @param {number} clusterId
     * @param {number} nodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    deleteClusterNode(clusterId, nodeId, options) {
        return (0, exports.ClustersApiFp)(this.configuration).deleteClusterNode(clusterId, nodeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if a Cluster name is available
     * @summary Fetch cluster name availability
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    fetchClusterNameAvailability(name, options) {
        return (0, exports.ClustersApiFp)(this.configuration).fetchClusterNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Cluster Master Flavors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    getClusterMasterFlavors(options) {
        return (0, exports.ClustersApiFp)(this.configuration).getClusterMasterFlavors(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Cluster Nodes
     * @param {number} clusterId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    getClusterNodes(clusterId, options) {
        return (0, exports.ClustersApiFp)(this.configuration).getClusterNodes(clusterId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists available Kubernetes versions, optionally filtered by region.
     * @summary List Cluster Versions
     * @param {string} [region] Filter versions by region name (optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    getClusterVersions(region, options) {
        return (0, exports.ClustersApiFp)(this.configuration).getClusterVersions(region, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Getting Cluster Detail
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    gettingClusterDetail(id, options) {
        return (0, exports.ClustersApiFp)(this.configuration).gettingClusterDetail(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Clusters
     * @param {number} [page] Page number for pagination
     * @param {number} [pageSize] Number of items per page
     * @param {string} [environment] Environment Filter
     * @param {string} [search] Search query to filter cluster by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    listClusters(page, pageSize, environment, search, options) {
        return (0, exports.ClustersApiFp)(this.configuration).listClusters(page, pageSize, environment, search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List node groups for a cluster
     * @param {number} clusterId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    listNodeGroups(clusterId, options) {
        return (0, exports.ClustersApiFp)(this.configuration).listNodeGroups(clusterId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a node group in a cluster
     * @param {number} clusterId
     * @param {number} nodeGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    retrieveANodeGroup(clusterId, nodeGroupId, options) {
        return (0, exports.ClustersApiFp)(this.configuration).retrieveANodeGroup(clusterId, nodeGroupId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ClustersApi = ClustersApi;
/**
 * ComplianceApi - axios parameter creator
 * @export
 */
const ComplianceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create compliance
         * @param {CompliancePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompliance: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createCompliance', 'payload', payload);
            const localVarPath = `/core/compliance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a compliance
         * @param {string} gpuModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACompliance: (gpuModel_1, ...args_1) => __awaiter(this, [gpuModel_1, ...args_1], void 0, function* (gpuModel, options = {}) {
            // verify required parameter 'gpuModel' is not null or undefined
            (0, common_1.assertParamExists)('deleteACompliance', 'gpuModel', gpuModel);
            const localVarPath = `/core/compliance/{gpu_model}`
                .replace(`{${"gpu_model"}}`, encodeURIComponent(String(gpuModel)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of compliance objects each corresponding to available GPU models. These compliance objects contain minimum and maximum values for RAM in GB, number of vCPUs, and system disk capacity in GB. Use the optional `gpu` model parameter in the query string to filter responses by GPU model. For additional details on GPU compliance, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#adhering-to-gpu-compliance).
         * @summary Retrieve GPU compliance
         * @param {string} [gpu] This is for gpu model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCompliance: (gpu_1, ...args_1) => __awaiter(this, [gpu_1, ...args_1], void 0, function* (gpu, options = {}) {
            const localVarPath = `/core/compliance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (gpu !== undefined) {
                localVarQueryParameter['gpu'] = gpu;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a compliance
         * @param {CompliancePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateACompliance: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateACompliance', 'payload', payload);
            const localVarPath = `/core/compliance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ComplianceApiAxiosParamCreator = ComplianceApiAxiosParamCreator;
/**
 * ComplianceApi - functional programming interface
 * @export
 */
const ComplianceApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ComplianceApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create compliance
         * @param {CompliancePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompliance(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCompliance(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ComplianceApi.createCompliance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete a compliance
         * @param {string} gpuModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACompliance(gpuModel, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteACompliance(gpuModel, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ComplianceApi.deleteACompliance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a list of compliance objects each corresponding to available GPU models. These compliance objects contain minimum and maximum values for RAM in GB, number of vCPUs, and system disk capacity in GB. Use the optional `gpu` model parameter in the query string to filter responses by GPU model. For additional details on GPU compliance, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#adhering-to-gpu-compliance).
         * @summary Retrieve GPU compliance
         * @param {string} [gpu] This is for gpu model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCompliance(gpu, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveCompliance(gpu, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ComplianceApi.retrieveCompliance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update a compliance
         * @param {CompliancePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateACompliance(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateACompliance(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ComplianceApi.updateACompliance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ComplianceApiFp = ComplianceApiFp;
/**
 * ComplianceApi - factory interface
 * @export
 */
const ComplianceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ComplianceApiFp)(configuration);
    return {
        /**
         *
         * @summary Create compliance
         * @param {CompliancePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompliance(payload, options) {
            return localVarFp.createCompliance(payload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a compliance
         * @param {string} gpuModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACompliance(gpuModel, options) {
            return localVarFp.deleteACompliance(gpuModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of compliance objects each corresponding to available GPU models. These compliance objects contain minimum and maximum values for RAM in GB, number of vCPUs, and system disk capacity in GB. Use the optional `gpu` model parameter in the query string to filter responses by GPU model. For additional details on GPU compliance, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#adhering-to-gpu-compliance).
         * @summary Retrieve GPU compliance
         * @param {string} [gpu] This is for gpu model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCompliance(gpu, options) {
            return localVarFp.retrieveCompliance(gpu, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a compliance
         * @param {CompliancePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateACompliance(payload, options) {
            return localVarFp.updateACompliance(payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ComplianceApiFactory = ComplianceApiFactory;
/**
 * ComplianceApi - object-oriented interface
 * @export
 * @class ComplianceApi
 * @extends {BaseAPI}
 */
class ComplianceApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create compliance
     * @param {CompliancePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    createCompliance(payload, options) {
        return (0, exports.ComplianceApiFp)(this.configuration).createCompliance(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a compliance
     * @param {string} gpuModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    deleteACompliance(gpuModel, options) {
        return (0, exports.ComplianceApiFp)(this.configuration).deleteACompliance(gpuModel, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of compliance objects each corresponding to available GPU models. These compliance objects contain minimum and maximum values for RAM in GB, number of vCPUs, and system disk capacity in GB. Use the optional `gpu` model parameter in the query string to filter responses by GPU model. For additional details on GPU compliance, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#adhering-to-gpu-compliance).
     * @summary Retrieve GPU compliance
     * @param {string} [gpu] This is for gpu model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    retrieveCompliance(gpu, options) {
        return (0, exports.ComplianceApiFp)(this.configuration).retrieveCompliance(gpu, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a compliance
     * @param {CompliancePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    updateACompliance(payload, options) {
        return (0, exports.ComplianceApiFp)(this.configuration).updateACompliance(payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ComplianceApi = ComplianceApi;
/**
 * CreditApi - axios parameter creator
 * @export
 */
const CreditApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the current credit balance for your [**organization**](/docs/rbac/organization). Ensuring a positive credit balance allows you to create resources. However, for prepaid accounts, if the credit balance falls below $0, all associated resources will be temporarily suspended until a [**payment**](/docs/api-reference/billing-resources/create-payment) is made. For additional information, [**click here**](None/docs/api-reference/billing-resources/retrieve-credit-balance/).
         * @summary GET: View credit and threshold
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit2: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/billing/user-credit/credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CreditApiAxiosParamCreator = CreditApiAxiosParamCreator;
/**
 * CreditApi - functional programming interface
 * @export
 */
const CreditApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CreditApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves the current credit balance for your [**organization**](/docs/rbac/organization). Ensuring a positive credit balance allows you to create resources. However, for prepaid accounts, if the credit balance falls below $0, all associated resources will be temporarily suspended until a [**payment**](/docs/api-reference/billing-resources/create-payment) is made. For additional information, [**click here**](None/docs/api-reference/billing-resources/retrieve-credit-balance/).
         * @summary GET: View credit and threshold
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit2(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCredit2(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CreditApi.getCredit2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.CreditApiFp = CreditApiFp;
/**
 * CreditApi - factory interface
 * @export
 */
const CreditApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CreditApiFp)(configuration);
    return {
        /**
         * Retrieves the current credit balance for your [**organization**](/docs/rbac/organization). Ensuring a positive credit balance allows you to create resources. However, for prepaid accounts, if the credit balance falls below $0, all associated resources will be temporarily suspended until a [**payment**](/docs/api-reference/billing-resources/create-payment) is made. For additional information, [**click here**](None/docs/api-reference/billing-resources/retrieve-credit-balance/).
         * @summary GET: View credit and threshold
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit2(options) {
            return localVarFp.getCredit2(options).then((request) => request(axios, basePath));
        },
    };
};
exports.CreditApiFactory = CreditApiFactory;
/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
class CreditApi extends base_1.BaseAPI {
    /**
     * Retrieves the current credit balance for your [**organization**](/docs/rbac/organization). Ensuring a positive credit balance allows you to create resources. However, for prepaid accounts, if the credit balance falls below $0, all associated resources will be temporarily suspended until a [**payment**](/docs/api-reference/billing-resources/create-payment) is made. For additional information, [**click here**](None/docs/api-reference/billing-resources/retrieve-credit-balance/).
     * @summary GET: View credit and threshold
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    getCredit2(options) {
        return (0, exports.CreditApiFp)(this.configuration).getCredit2(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CreditApi = CreditApi;
/**
 * CustomerContractApi - axios parameter creator
 * @export
 */
const CustomerContractApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of contracts and their details, including the terms of each contract and the discounts applied to all resources under each contract. Pagination can be controlled using the `page` and `per_page` query parameters. For additional information about contracts, click [**here**](None/docs/billing-and-payment/contracts).
         * @summary List Contracts
         * @param {number} [page]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerContract: (page_1, perPage_1, ...args_1) => __awaiter(this, [page_1, perPage_1, ...args_1], void 0, function* (page, perPage, options = {}) {
            const localVarPath = `/pricebook/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve details of a specific contract by providing the contract ID in the path. The endpoint returns the contract object along with its associated discount plans. For more information, [**click here**](None/docs/api-reference/pricebook-resources/retrieve-contract-details).
         * @summary Retrieve Contract Details
         * @param {number} contractId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerContractDetails: (contractId_1, ...args_1) => __awaiter(this, [contractId_1, ...args_1], void 0, function* (contractId, options = {}) {
            // verify required parameter 'contractId' is not null or undefined
            (0, common_1.assertParamExists)('getCustomerContractDetails', 'contractId', contractId);
            const localVarPath = `/pricebook/contracts/{contract_id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve GPU allocation count graph for a specific contract by providing the contract ID in the path. The endpoint returns the GPU allocation count graph for the contract within the specified date range.
         * @summary Retrieve GPU Allocation Graph for Contract
         * @param {number} contractId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerContractGpuAllocationGraph: (contractId_1, startDate_1, endDate_1, ...args_1) => __awaiter(this, [contractId_1, startDate_1, endDate_1, ...args_1], void 0, function* (contractId, startDate, endDate, options = {}) {
            // verify required parameter 'contractId' is not null or undefined
            (0, common_1.assertParamExists)('getCustomerContractGpuAllocationGraph', 'contractId', contractId);
            const localVarPath = `/pricebook/contracts/{contract_id}/gpu_allocation_graph`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CustomerContractApiAxiosParamCreator = CustomerContractApiAxiosParamCreator;
/**
 * CustomerContractApi - functional programming interface
 * @export
 */
const CustomerContractApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CustomerContractApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of contracts and their details, including the terms of each contract and the discounts applied to all resources under each contract. Pagination can be controlled using the `page` and `per_page` query parameters. For additional information about contracts, click [**here**](None/docs/billing-and-payment/contracts).
         * @summary List Contracts
         * @param {number} [page]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerContract(page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomerContract(page, perPage, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerContractApi.getCustomerContract']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve details of a specific contract by providing the contract ID in the path. The endpoint returns the contract object along with its associated discount plans. For more information, [**click here**](None/docs/api-reference/pricebook-resources/retrieve-contract-details).
         * @summary Retrieve Contract Details
         * @param {number} contractId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerContractDetails(contractId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomerContractDetails(contractId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerContractApi.getCustomerContractDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve GPU allocation count graph for a specific contract by providing the contract ID in the path. The endpoint returns the GPU allocation count graph for the contract within the specified date range.
         * @summary Retrieve GPU Allocation Graph for Contract
         * @param {number} contractId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerContractGpuAllocationGraph(contractId, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomerContractGpuAllocationGraph(contractId, startDate, endDate, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CustomerContractApi.getCustomerContractGpuAllocationGraph']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.CustomerContractApiFp = CustomerContractApiFp;
/**
 * CustomerContractApi - factory interface
 * @export
 */
const CustomerContractApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CustomerContractApiFp)(configuration);
    return {
        /**
         * Retrieves a list of contracts and their details, including the terms of each contract and the discounts applied to all resources under each contract. Pagination can be controlled using the `page` and `per_page` query parameters. For additional information about contracts, click [**here**](None/docs/billing-and-payment/contracts).
         * @summary List Contracts
         * @param {number} [page]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerContract(page, perPage, options) {
            return localVarFp.getCustomerContract(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific contract by providing the contract ID in the path. The endpoint returns the contract object along with its associated discount plans. For more information, [**click here**](None/docs/api-reference/pricebook-resources/retrieve-contract-details).
         * @summary Retrieve Contract Details
         * @param {number} contractId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerContractDetails(contractId, options) {
            return localVarFp.getCustomerContractDetails(contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve GPU allocation count graph for a specific contract by providing the contract ID in the path. The endpoint returns the GPU allocation count graph for the contract within the specified date range.
         * @summary Retrieve GPU Allocation Graph for Contract
         * @param {number} contractId
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerContractGpuAllocationGraph(contractId, startDate, endDate, options) {
            return localVarFp.getCustomerContractGpuAllocationGraph(contractId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CustomerContractApiFactory = CustomerContractApiFactory;
/**
 * CustomerContractApi - object-oriented interface
 * @export
 * @class CustomerContractApi
 * @extends {BaseAPI}
 */
class CustomerContractApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of contracts and their details, including the terms of each contract and the discounts applied to all resources under each contract. Pagination can be controlled using the `page` and `per_page` query parameters. For additional information about contracts, click [**here**](None/docs/billing-and-payment/contracts).
     * @summary List Contracts
     * @param {number} [page]
     * @param {number} [perPage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerContractApi
     */
    getCustomerContract(page, perPage, options) {
        return (0, exports.CustomerContractApiFp)(this.configuration).getCustomerContract(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve details of a specific contract by providing the contract ID in the path. The endpoint returns the contract object along with its associated discount plans. For more information, [**click here**](None/docs/api-reference/pricebook-resources/retrieve-contract-details).
     * @summary Retrieve Contract Details
     * @param {number} contractId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerContractApi
     */
    getCustomerContractDetails(contractId, options) {
        return (0, exports.CustomerContractApiFp)(this.configuration).getCustomerContractDetails(contractId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve GPU allocation count graph for a specific contract by providing the contract ID in the path. The endpoint returns the GPU allocation count graph for the contract within the specified date range.
     * @summary Retrieve GPU Allocation Graph for Contract
     * @param {number} contractId
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerContractApi
     */
    getCustomerContractGpuAllocationGraph(contractId, startDate, endDate, options) {
        return (0, exports.CustomerContractApiFp)(this.configuration).getCustomerContractGpuAllocationGraph(contractId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CustomerContractApi = CustomerContractApi;
/**
 * DashboardApi - axios parameter creator
 * @export
 */
const DashboardApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns hardware and pricing overview for your active resources, includingvirtual machines, containers, and volumes. For more details on the Dashboard feature, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/dashboard/).
         * @summary Retrieve Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDashboard: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DashboardApiAxiosParamCreator = DashboardApiAxiosParamCreator;
/**
 * DashboardApi - functional programming interface
 * @export
 */
const DashboardApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DashboardApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns hardware and pricing overview for your active resources, includingvirtual machines, containers, and volumes. For more details on the Dashboard feature, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/dashboard/).
         * @summary Retrieve Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDashboard(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveDashboard(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DashboardApi.retrieveDashboard']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.DashboardApiFp = DashboardApiFp;
/**
 * DashboardApi - factory interface
 * @export
 */
const DashboardApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DashboardApiFp)(configuration);
    return {
        /**
         * Returns hardware and pricing overview for your active resources, includingvirtual machines, containers, and volumes. For more details on the Dashboard feature, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/dashboard/).
         * @summary Retrieve Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDashboard(options) {
            return localVarFp.retrieveDashboard(options).then((request) => request(axios, basePath));
        },
    };
};
exports.DashboardApiFactory = DashboardApiFactory;
/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
class DashboardApi extends base_1.BaseAPI {
    /**
     * Returns hardware and pricing overview for your active resources, includingvirtual machines, containers, and volumes. For more details on the Dashboard feature, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/dashboard/).
     * @summary Retrieve Dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    retrieveDashboard(options) {
        return (0, exports.DashboardApiFp)(this.configuration).retrieveDashboard(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DashboardApi = DashboardApi;
/**
 * DeploymentApi - axios parameter creator
 * @export
 */
const DeploymentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Delete Deployment
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteDeployment', 'id', id);
            const localVarPath = `/core/marketplace/deployments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Details of Deployment by ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailsOfDeploymentByID: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('detailsOfDeploymentByID', 'id', id);
            const localVarPath = `/core/marketplace/deployments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List Deployments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeployments: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/marketplace/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Start Deployment
         * @param {StartDeploymentPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startDeployment: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('startDeployment', 'payload', payload);
            const localVarPath = `/core/marketplace/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DeploymentApiAxiosParamCreator = DeploymentApiAxiosParamCreator;
/**
 * DeploymentApi - functional programming interface
 * @export
 */
const DeploymentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DeploymentApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Delete Deployment
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDeployment(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DeploymentApi.deleteDeployment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Details of Deployment by ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailsOfDeploymentByID(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.detailsOfDeploymentByID(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DeploymentApi.detailsOfDeploymentByID']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary List Deployments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeployments(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDeployments(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DeploymentApi.listDeployments']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Start Deployment
         * @param {StartDeploymentPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startDeployment(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.startDeployment(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DeploymentApi.startDeployment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.DeploymentApiFp = DeploymentApiFp;
/**
 * DeploymentApi - factory interface
 * @export
 */
const DeploymentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DeploymentApiFp)(configuration);
    return {
        /**
         *
         * @summary Delete Deployment
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment(id, options) {
            return localVarFp.deleteDeployment(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Details of Deployment by ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailsOfDeploymentByID(id, options) {
            return localVarFp.detailsOfDeploymentByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Deployments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeployments(options) {
            return localVarFp.listDeployments(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Start Deployment
         * @param {StartDeploymentPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startDeployment(payload, options) {
            return localVarFp.startDeployment(payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DeploymentApiFactory = DeploymentApiFactory;
/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
class DeploymentApi extends base_1.BaseAPI {
    /**
     *
     * @summary Delete Deployment
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    deleteDeployment(id, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).deleteDeployment(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Details of Deployment by ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    detailsOfDeploymentByID(id, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).detailsOfDeploymentByID(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Deployments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    listDeployments(options) {
        return (0, exports.DeploymentApiFp)(this.configuration).listDeployments(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Start Deployment
     * @param {StartDeploymentPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    startDeployment(payload, options) {
        return (0, exports.DeploymentApiFp)(this.configuration).startDeployment(payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DeploymentApi = DeploymentApi;
/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
const EnvironmentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates an environment—a container to organize your resources, including SSH key pairs, virtual machines, and volumes. To create your environment, provide your desired environment name, and [**region**](https://docs.hyperstack.cloud/docs/resource-management/regions/) in the request body.
         * @summary Create environment
         * @param {CreateEnvironment} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createEnvironment', 'payload', payload);
            const localVarPath = `/core/environments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes an environment permanently. Provide the environment ID in the path to remove the specified environment.
         * @summary Delete environment
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteEnvironment', 'id', id);
            const localVarPath = `/core/environments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if a Environment name is available
         * @summary Fetch environment name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchEnvironmentNameAvailability: (name_1, ...args_1) => __awaiter(this, [name_1, ...args_1], void 0, function* (name, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('fetchEnvironmentNameAvailability', 'name', name);
            const localVarPath = `/core/environments/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of your existing environments, providing the following details for each; environment ID, name, [**region**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/), and the date and time of creation. For more information on environments, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/).
         * @summary List environments
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By ID or Name or Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments: (page_1, pageSize_1, search_1, ...args_1) => __awaiter(this, [page_1, pageSize_1, search_1, ...args_1], void 0, function* (page, pageSize, search, options = {}) {
            const localVarPath = `/core/environments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves details about a specific environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Retrieve environment
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEnvironment: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('retrieveEnvironment', 'id', id);
            const localVarPath = `/core/environments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the name of an existing environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Update environment
         * @param {number} id
         * @param {UpdateEnvironment} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment: (id_1, payload_1, ...args_1) => __awaiter(this, [id_1, payload_1, ...args_1], void 0, function* (id, payload, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateEnvironment', 'id', id);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateEnvironment', 'payload', payload);
            const localVarPath = `/core/environments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.EnvironmentApiAxiosParamCreator = EnvironmentApiAxiosParamCreator;
/**
 * EnvironmentApi - functional programming interface
 * @export
 */
const EnvironmentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.EnvironmentApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates an environment—a container to organize your resources, including SSH key pairs, virtual machines, and volumes. To create your environment, provide your desired environment name, and [**region**](https://docs.hyperstack.cloud/docs/resource-management/regions/) in the request body.
         * @summary Create environment
         * @param {CreateEnvironment} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createEnvironment(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EnvironmentApi.createEnvironment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes an environment permanently. Provide the environment ID in the path to remove the specified environment.
         * @summary Delete environment
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteEnvironment(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EnvironmentApi.deleteEnvironment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check if a Environment name is available
         * @summary Fetch environment name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchEnvironmentNameAvailability(name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchEnvironmentNameAvailability(name, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EnvironmentApi.fetchEnvironmentNameAvailability']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a list of your existing environments, providing the following details for each; environment ID, name, [**region**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/), and the date and time of creation. For more information on environments, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/).
         * @summary List environments
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By ID or Name or Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments(page, pageSize, search, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listEnvironments(page, pageSize, search, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EnvironmentApi.listEnvironments']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves details about a specific environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Retrieve environment
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEnvironment(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveEnvironment(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EnvironmentApi.retrieveEnvironment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the name of an existing environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Update environment
         * @param {number} id
         * @param {UpdateEnvironment} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment(id, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateEnvironment(id, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EnvironmentApi.updateEnvironment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.EnvironmentApiFp = EnvironmentApiFp;
/**
 * EnvironmentApi - factory interface
 * @export
 */
const EnvironmentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.EnvironmentApiFp)(configuration);
    return {
        /**
         * Creates an environment—a container to organize your resources, including SSH key pairs, virtual machines, and volumes. To create your environment, provide your desired environment name, and [**region**](https://docs.hyperstack.cloud/docs/resource-management/regions/) in the request body.
         * @summary Create environment
         * @param {CreateEnvironment} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(payload, options) {
            return localVarFp.createEnvironment(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an environment permanently. Provide the environment ID in the path to remove the specified environment.
         * @summary Delete environment
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(id, options) {
            return localVarFp.deleteEnvironment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Environment name is available
         * @summary Fetch environment name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchEnvironmentNameAvailability(name, options) {
            return localVarFp.fetchEnvironmentNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your existing environments, providing the following details for each; environment ID, name, [**region**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/), and the date and time of creation. For more information on environments, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/).
         * @summary List environments
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By ID or Name or Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments(page, pageSize, search, options) {
            return localVarFp.listEnvironments(page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details about a specific environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Retrieve environment
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEnvironment(id, options) {
            return localVarFp.retrieveEnvironment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the name of an existing environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Update environment
         * @param {number} id
         * @param {UpdateEnvironment} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment(id, payload, options) {
            return localVarFp.updateEnvironment(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.EnvironmentApiFactory = EnvironmentApiFactory;
/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
class EnvironmentApi extends base_1.BaseAPI {
    /**
     * Creates an environment—a container to organize your resources, including SSH key pairs, virtual machines, and volumes. To create your environment, provide your desired environment name, and [**region**](https://docs.hyperstack.cloud/docs/resource-management/regions/) in the request body.
     * @summary Create environment
     * @param {CreateEnvironment} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    createEnvironment(payload, options) {
        return (0, exports.EnvironmentApiFp)(this.configuration).createEnvironment(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an environment permanently. Provide the environment ID in the path to remove the specified environment.
     * @summary Delete environment
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    deleteEnvironment(id, options) {
        return (0, exports.EnvironmentApiFp)(this.configuration).deleteEnvironment(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if a Environment name is available
     * @summary Fetch environment name availability
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    fetchEnvironmentNameAvailability(name, options) {
        return (0, exports.EnvironmentApiFp)(this.configuration).fetchEnvironmentNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of your existing environments, providing the following details for each; environment ID, name, [**region**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/), and the date and time of creation. For more information on environments, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/).
     * @summary List environments
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search] Search By ID or Name or Region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    listEnvironments(page, pageSize, search, options) {
        return (0, exports.EnvironmentApiFp)(this.configuration).listEnvironments(page, pageSize, search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves details about a specific environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
     * @summary Retrieve environment
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    retrieveEnvironment(id, options) {
        return (0, exports.EnvironmentApiFp)(this.configuration).retrieveEnvironment(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the name of an existing environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
     * @summary Update environment
     * @param {number} id
     * @param {UpdateEnvironment} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    updateEnvironment(id, payload, options) {
        return (0, exports.EnvironmentApiFp)(this.configuration).updateEnvironment(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EnvironmentApi = EnvironmentApi;
/**
 * FirewallAttachmentApi - axios parameter creator
 * @export
 */
const FirewallAttachmentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Attach a firewall to one or more virtual machines by providing the virtual machine IDs in the request body and the firewall ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/attach-firewall-to-vms).
         * @summary Attach Firewalls to VMs
         * @param {number} firewallId
         * @param {AttachFirewallWithVM} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttachSecurityGroups: (firewallId_1, payload_1, ...args_1) => __awaiter(this, [firewallId_1, payload_1, ...args_1], void 0, function* (firewallId, payload, options = {}) {
            // verify required parameter 'firewallId' is not null or undefined
            (0, common_1.assertParamExists)('postAttachSecurityGroups', 'firewallId', firewallId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postAttachSecurityGroups', 'payload', payload);
            const localVarPath = `/core/firewalls/{firewall_id}/update-attachments`
                .replace(`{${"firewall_id"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FirewallAttachmentApiAxiosParamCreator = FirewallAttachmentApiAxiosParamCreator;
/**
 * FirewallAttachmentApi - functional programming interface
 * @export
 */
const FirewallAttachmentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FirewallAttachmentApiAxiosParamCreator)(configuration);
    return {
        /**
         * Attach a firewall to one or more virtual machines by providing the virtual machine IDs in the request body and the firewall ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/attach-firewall-to-vms).
         * @summary Attach Firewalls to VMs
         * @param {number} firewallId
         * @param {AttachFirewallWithVM} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttachSecurityGroups(firewallId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postAttachSecurityGroups(firewallId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FirewallAttachmentApi.postAttachSecurityGroups']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.FirewallAttachmentApiFp = FirewallAttachmentApiFp;
/**
 * FirewallAttachmentApi - factory interface
 * @export
 */
const FirewallAttachmentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FirewallAttachmentApiFp)(configuration);
    return {
        /**
         * Attach a firewall to one or more virtual machines by providing the virtual machine IDs in the request body and the firewall ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/attach-firewall-to-vms).
         * @summary Attach Firewalls to VMs
         * @param {number} firewallId
         * @param {AttachFirewallWithVM} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttachSecurityGroups(firewallId, payload, options) {
            return localVarFp.postAttachSecurityGroups(firewallId, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FirewallAttachmentApiFactory = FirewallAttachmentApiFactory;
/**
 * FirewallAttachmentApi - object-oriented interface
 * @export
 * @class FirewallAttachmentApi
 * @extends {BaseAPI}
 */
class FirewallAttachmentApi extends base_1.BaseAPI {
    /**
     * Attach a firewall to one or more virtual machines by providing the virtual machine IDs in the request body and the firewall ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/attach-firewall-to-vms).
     * @summary Attach Firewalls to VMs
     * @param {number} firewallId
     * @param {AttachFirewallWithVM} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallAttachmentApi
     */
    postAttachSecurityGroups(firewallId, payload, options) {
        return (0, exports.FirewallAttachmentApiFp)(this.configuration).postAttachSecurityGroups(firewallId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FirewallAttachmentApi = FirewallAttachmentApi;
/**
 * FirewallsApi - axios parameter creator
 * @export
 */
const FirewallsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes a firewall by specifying the firewall ID in the path. If the firewall is currently attached to a virtual machine, it must be detached before deletion. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/delete-firewall).
         * @summary Delete firewall
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecurityGroupDetails: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteSecurityGroupDetails', 'id', id);
            const localVarPath = `/core/firewalls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes a firewall rule from firewall by providing the firewall ID and firewall rule ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/remove-firewall-rule-from-firewall).
         * @summary Delete firewall rules from firewall
         * @param {number} firewallId
         * @param {number} firewallRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecurityGroupRuleDelete: (firewallId_1, firewallRuleId_1, ...args_1) => __awaiter(this, [firewallId_1, firewallRuleId_1, ...args_1], void 0, function* (firewallId, firewallRuleId, options = {}) {
            // verify required parameter 'firewallId' is not null or undefined
            (0, common_1.assertParamExists)('deleteSecurityGroupRuleDelete', 'firewallId', firewallId);
            // verify required parameter 'firewallRuleId' is not null or undefined
            (0, common_1.assertParamExists)('deleteSecurityGroupRuleDelete', 'firewallRuleId', firewallRuleId);
            const localVarPath = `/core/firewalls/{firewall_id}/firewall-rules/{firewall_rule_id}`
                .replace(`{${"firewall_id"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"firewall_rule_id"}}`, encodeURIComponent(String(firewallRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a list of existing firewalls and their details, including the security rules they contain and information about the virtual machines to which they are attached. For more information about the firewalls features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/network-security/security-groups).
         * @summary List firewalls
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [search]
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityGroup: (page_1, pageSize_1, search_1, environment_1, ...args_1) => __awaiter(this, [page_1, pageSize_1, search_1, environment_1, ...args_1], void 0, function* (page, pageSize, search, environment, options = {}) {
            const localVarPath = `/core/firewalls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the details of an existing firewall, including the security rules it contains and information about the virtual machines to which it is attached.
         * @summary Retrieve firewall details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityGroupDetails: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSecurityGroupDetails', 'id', id);
            const localVarPath = `/core/firewalls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a firewall to which firewall rules can be added. A firewall can be attached to one or more virtual machines to control inbound and outbound traffic. In the body of the request, include the name of the firewall, the ID of the environment within which the firewall will be created, and an optional description. To obtain the ID of the environment, make a request to the [**list environments**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/list-environments) endpoint.
         * @summary Create firewall
         * @param {CreateFirewallPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSecurityGroup: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postSecurityGroup', 'payload', payload);
            const localVarPath = `/core/firewalls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a [**firewall rule**](https://docs.hyperstack.cloud/docs/network-security/security-rules) and adds it to an existing firewall. Include the firewall ID in the path, and provide the firewall rule configuration in the request body.
         * @summary Add firewall rule to firewall
         * @param {number} firewallId
         * @param {CreateFirewallRulePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSecurityGroupRules: (firewallId_1, payload_1, ...args_1) => __awaiter(this, [firewallId_1, payload_1, ...args_1], void 0, function* (firewallId, payload, options = {}) {
            // verify required parameter 'firewallId' is not null or undefined
            (0, common_1.assertParamExists)('postSecurityGroupRules', 'firewallId', firewallId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postSecurityGroupRules', 'payload', payload);
            const localVarPath = `/core/firewalls/{firewall_id}/firewall-rules`
                .replace(`{${"firewall_id"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FirewallsApiAxiosParamCreator = FirewallsApiAxiosParamCreator;
/**
 * FirewallsApi - functional programming interface
 * @export
 */
const FirewallsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FirewallsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Deletes a firewall by specifying the firewall ID in the path. If the firewall is currently attached to a virtual machine, it must be detached before deletion. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/delete-firewall).
         * @summary Delete firewall
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecurityGroupDetails(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSecurityGroupDetails(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FirewallsApi.deleteSecurityGroupDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Removes a firewall rule from firewall by providing the firewall ID and firewall rule ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/remove-firewall-rule-from-firewall).
         * @summary Delete firewall rules from firewall
         * @param {number} firewallId
         * @param {number} firewallRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecurityGroupRuleDelete(firewallId, firewallRuleId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSecurityGroupRuleDelete(firewallId, firewallRuleId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FirewallsApi.deleteSecurityGroupRuleDelete']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a list of existing firewalls and their details, including the security rules they contain and information about the virtual machines to which they are attached. For more information about the firewalls features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/network-security/security-groups).
         * @summary List firewalls
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [search]
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityGroup(page, pageSize, search, environment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSecurityGroup(page, pageSize, search, environment, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FirewallsApi.getSecurityGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the details of an existing firewall, including the security rules it contains and information about the virtual machines to which it is attached.
         * @summary Retrieve firewall details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityGroupDetails(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSecurityGroupDetails(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FirewallsApi.getSecurityGroupDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a firewall to which firewall rules can be added. A firewall can be attached to one or more virtual machines to control inbound and outbound traffic. In the body of the request, include the name of the firewall, the ID of the environment within which the firewall will be created, and an optional description. To obtain the ID of the environment, make a request to the [**list environments**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/list-environments) endpoint.
         * @summary Create firewall
         * @param {CreateFirewallPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSecurityGroup(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postSecurityGroup(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FirewallsApi.postSecurityGroup']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a [**firewall rule**](https://docs.hyperstack.cloud/docs/network-security/security-rules) and adds it to an existing firewall. Include the firewall ID in the path, and provide the firewall rule configuration in the request body.
         * @summary Add firewall rule to firewall
         * @param {number} firewallId
         * @param {CreateFirewallRulePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSecurityGroupRules(firewallId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postSecurityGroupRules(firewallId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FirewallsApi.postSecurityGroupRules']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.FirewallsApiFp = FirewallsApiFp;
/**
 * FirewallsApi - factory interface
 * @export
 */
const FirewallsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FirewallsApiFp)(configuration);
    return {
        /**
         * Deletes a firewall by specifying the firewall ID in the path. If the firewall is currently attached to a virtual machine, it must be detached before deletion. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/delete-firewall).
         * @summary Delete firewall
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecurityGroupDetails(id, options) {
            return localVarFp.deleteSecurityGroupDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a firewall rule from firewall by providing the firewall ID and firewall rule ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/remove-firewall-rule-from-firewall).
         * @summary Delete firewall rules from firewall
         * @param {number} firewallId
         * @param {number} firewallRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecurityGroupRuleDelete(firewallId, firewallRuleId, options) {
            return localVarFp.deleteSecurityGroupRuleDelete(firewallId, firewallRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of existing firewalls and their details, including the security rules they contain and information about the virtual machines to which they are attached. For more information about the firewalls features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/network-security/security-groups).
         * @summary List firewalls
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [search]
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityGroup(page, pageSize, search, environment, options) {
            return localVarFp.getSecurityGroup(page, pageSize, search, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing firewall, including the security rules it contains and information about the virtual machines to which it is attached.
         * @summary Retrieve firewall details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityGroupDetails(id, options) {
            return localVarFp.getSecurityGroupDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a firewall to which firewall rules can be added. A firewall can be attached to one or more virtual machines to control inbound and outbound traffic. In the body of the request, include the name of the firewall, the ID of the environment within which the firewall will be created, and an optional description. To obtain the ID of the environment, make a request to the [**list environments**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/list-environments) endpoint.
         * @summary Create firewall
         * @param {CreateFirewallPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSecurityGroup(payload, options) {
            return localVarFp.postSecurityGroup(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a [**firewall rule**](https://docs.hyperstack.cloud/docs/network-security/security-rules) and adds it to an existing firewall. Include the firewall ID in the path, and provide the firewall rule configuration in the request body.
         * @summary Add firewall rule to firewall
         * @param {number} firewallId
         * @param {CreateFirewallRulePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSecurityGroupRules(firewallId, payload, options) {
            return localVarFp.postSecurityGroupRules(firewallId, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FirewallsApiFactory = FirewallsApiFactory;
/**
 * FirewallsApi - object-oriented interface
 * @export
 * @class FirewallsApi
 * @extends {BaseAPI}
 */
class FirewallsApi extends base_1.BaseAPI {
    /**
     * Deletes a firewall by specifying the firewall ID in the path. If the firewall is currently attached to a virtual machine, it must be detached before deletion. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/delete-firewall).
     * @summary Delete firewall
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    deleteSecurityGroupDetails(id, options) {
        return (0, exports.FirewallsApiFp)(this.configuration).deleteSecurityGroupDetails(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes a firewall rule from firewall by providing the firewall ID and firewall rule ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/remove-firewall-rule-from-firewall).
     * @summary Delete firewall rules from firewall
     * @param {number} firewallId
     * @param {number} firewallRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    deleteSecurityGroupRuleDelete(firewallId, firewallRuleId, options) {
        return (0, exports.FirewallsApiFp)(this.configuration).deleteSecurityGroupRuleDelete(firewallId, firewallRuleId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of existing firewalls and their details, including the security rules they contain and information about the virtual machines to which they are attached. For more information about the firewalls features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/network-security/security-groups).
     * @summary List firewalls
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [search]
     * @param {string} [environment] Filter Environment ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    getSecurityGroup(page, pageSize, search, environment, options) {
        return (0, exports.FirewallsApiFp)(this.configuration).getSecurityGroup(page, pageSize, search, environment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the details of an existing firewall, including the security rules it contains and information about the virtual machines to which it is attached.
     * @summary Retrieve firewall details
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    getSecurityGroupDetails(id, options) {
        return (0, exports.FirewallsApiFp)(this.configuration).getSecurityGroupDetails(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a firewall to which firewall rules can be added. A firewall can be attached to one or more virtual machines to control inbound and outbound traffic. In the body of the request, include the name of the firewall, the ID of the environment within which the firewall will be created, and an optional description. To obtain the ID of the environment, make a request to the [**list environments**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/list-environments) endpoint.
     * @summary Create firewall
     * @param {CreateFirewallPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    postSecurityGroup(payload, options) {
        return (0, exports.FirewallsApiFp)(this.configuration).postSecurityGroup(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a [**firewall rule**](https://docs.hyperstack.cloud/docs/network-security/security-rules) and adds it to an existing firewall. Include the firewall ID in the path, and provide the firewall rule configuration in the request body.
     * @summary Add firewall rule to firewall
     * @param {number} firewallId
     * @param {CreateFirewallRulePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    postSecurityGroupRules(firewallId, payload, options) {
        return (0, exports.FirewallsApiFp)(this.configuration).postSecurityGroupRules(firewallId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FirewallsApi = FirewallsApi;
/**
 * FlavorApi - axios parameter creator
 * @export
 */
const FlavorApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of available virtual machine hardware configurations, known as**flavors**. You can specify a `region_name` in the query string of the request toretrieve flavors available only in the specified region; by default, it returnsflavors available in all regions. For more details on flavors,[**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors).
         * @summary List Flavors
         * @param {string} [region] Region Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors: (region_1, ...args_1) => __awaiter(this, [region_1, ...args_1], void 0, function* (region, options = {}) {
            const localVarPath = `/core/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FlavorApiAxiosParamCreator = FlavorApiAxiosParamCreator;
/**
 * FlavorApi - functional programming interface
 * @export
 */
const FlavorApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FlavorApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of available virtual machine hardware configurations, known as**flavors**. You can specify a `region_name` in the query string of the request toretrieve flavors available only in the specified region; by default, it returnsflavors available in all regions. For more details on flavors,[**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors).
         * @summary List Flavors
         * @param {string} [region] Region Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors(region, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFlavors(region, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FlavorApi.listFlavors']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.FlavorApiFp = FlavorApiFp;
/**
 * FlavorApi - factory interface
 * @export
 */
const FlavorApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FlavorApiFp)(configuration);
    return {
        /**
         * Returns a list of available virtual machine hardware configurations, known as**flavors**. You can specify a `region_name` in the query string of the request toretrieve flavors available only in the specified region; by default, it returnsflavors available in all regions. For more details on flavors,[**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors).
         * @summary List Flavors
         * @param {string} [region] Region Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors(region, options) {
            return localVarFp.listFlavors(region, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FlavorApiFactory = FlavorApiFactory;
/**
 * FlavorApi - object-oriented interface
 * @export
 * @class FlavorApi
 * @extends {BaseAPI}
 */
class FlavorApi extends base_1.BaseAPI {
    /**
     * Returns a list of available virtual machine hardware configurations, known as**flavors**. You can specify a `region_name` in the query string of the request toretrieve flavors available only in the specified region; by default, it returnsflavors available in all regions. For more details on flavors,[**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors).
     * @summary List Flavors
     * @param {string} [region] Region Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorApi
     */
    listFlavors(region, options) {
        return (0, exports.FlavorApiFp)(this.configuration).listFlavors(region, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FlavorApi = FlavorApi;
/**
 * FloatingIpApi - axios parameter creator
 * @export
 */
const FloatingIpApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Initiates the creation of a public IP address and attaches it to an existing virtual machine, making it accessible through the internet. Include the virtual machine ID in the path to attach a public IP to the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/attach-floating-ip/).
         * @summary Attach public IP to virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPublicIPToVirtualMachine: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('attachPublicIPToVirtualMachine', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/attach-floatingip`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes a public IP address from an existing virtual machine, disabling internet accessibility to the VM. Include the virtual machine ID in the path to detach the public IP from the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/public-ip).
         * @summary Detach public IP from virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPublicIPFromVirtualMachine: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('detachPublicIPFromVirtualMachine', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/detach-floatingip`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FloatingIpApiAxiosParamCreator = FloatingIpApiAxiosParamCreator;
/**
 * FloatingIpApi - functional programming interface
 * @export
 */
const FloatingIpApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FloatingIpApiAxiosParamCreator)(configuration);
    return {
        /**
         * Initiates the creation of a public IP address and attaches it to an existing virtual machine, making it accessible through the internet. Include the virtual machine ID in the path to attach a public IP to the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/attach-floating-ip/).
         * @summary Attach public IP to virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPublicIPToVirtualMachine(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.attachPublicIPToVirtualMachine(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FloatingIpApi.attachPublicIPToVirtualMachine']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Removes a public IP address from an existing virtual machine, disabling internet accessibility to the VM. Include the virtual machine ID in the path to detach the public IP from the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/public-ip).
         * @summary Detach public IP from virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPublicIPFromVirtualMachine(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.detachPublicIPFromVirtualMachine(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FloatingIpApi.detachPublicIPFromVirtualMachine']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.FloatingIpApiFp = FloatingIpApiFp;
/**
 * FloatingIpApi - factory interface
 * @export
 */
const FloatingIpApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FloatingIpApiFp)(configuration);
    return {
        /**
         * Initiates the creation of a public IP address and attaches it to an existing virtual machine, making it accessible through the internet. Include the virtual machine ID in the path to attach a public IP to the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/attach-floating-ip/).
         * @summary Attach public IP to virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPublicIPToVirtualMachine(vmId, options) {
            return localVarFp.attachPublicIPToVirtualMachine(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a public IP address from an existing virtual machine, disabling internet accessibility to the VM. Include the virtual machine ID in the path to detach the public IP from the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/public-ip).
         * @summary Detach public IP from virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPublicIPFromVirtualMachine(vmId, options) {
            return localVarFp.detachPublicIPFromVirtualMachine(vmId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FloatingIpApiFactory = FloatingIpApiFactory;
/**
 * FloatingIpApi - object-oriented interface
 * @export
 * @class FloatingIpApi
 * @extends {BaseAPI}
 */
class FloatingIpApi extends base_1.BaseAPI {
    /**
     * Initiates the creation of a public IP address and attaches it to an existing virtual machine, making it accessible through the internet. Include the virtual machine ID in the path to attach a public IP to the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/attach-floating-ip/).
     * @summary Attach public IP to virtual machine
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingIpApi
     */
    attachPublicIPToVirtualMachine(vmId, options) {
        return (0, exports.FloatingIpApiFp)(this.configuration).attachPublicIPToVirtualMachine(vmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes a public IP address from an existing virtual machine, disabling internet accessibility to the VM. Include the virtual machine ID in the path to detach the public IP from the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/public-ip).
     * @summary Detach public IP from virtual machine
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingIpApi
     */
    detachPublicIPFromVirtualMachine(vmId, options) {
        return (0, exports.FloatingIpApiFp)(this.configuration).detachPublicIPFromVirtualMachine(vmId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FloatingIpApi = FloatingIpApi;
/**
 * GpuApi - axios parameter creator
 * @export
 */
const GpuApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of all available GPUs that can be utilized in the creation of custom virtual machine configurations.
         * @summary List GPUs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGPUs: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/gpus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.GpuApiAxiosParamCreator = GpuApiAxiosParamCreator;
/**
 * GpuApi - functional programming interface
 * @export
 */
const GpuApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.GpuApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of all available GPUs that can be utilized in the creation of custom virtual machine configurations.
         * @summary List GPUs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGPUs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listGPUs(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['GpuApi.listGPUs']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.GpuApiFp = GpuApiFp;
/**
 * GpuApi - factory interface
 * @export
 */
const GpuApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.GpuApiFp)(configuration);
    return {
        /**
         * Returns a list of all available GPUs that can be utilized in the creation of custom virtual machine configurations.
         * @summary List GPUs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGPUs(options) {
            return localVarFp.listGPUs(options).then((request) => request(axios, basePath));
        },
    };
};
exports.GpuApiFactory = GpuApiFactory;
/**
 * GpuApi - object-oriented interface
 * @export
 * @class GpuApi
 * @extends {BaseAPI}
 */
class GpuApi extends base_1.BaseAPI {
    /**
     * Returns a list of all available GPUs that can be utilized in the creation of custom virtual machine configurations.
     * @summary List GPUs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GpuApi
     */
    listGPUs(options) {
        return (0, exports.GpuApiFp)(this.configuration).listGPUs(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.GpuApi = GpuApi;
/**
 * ImageApi - axios parameter creator
 * @export
 */
const ImageApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes an image permanently. Provide the image ID in the path to specify the image to be deleted.
         * @summary Delete an image
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteImage', 'id', id);
            const localVarPath = `/core/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if an Image name is available
         * @summary Fetch name availability for Images
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchImageNameAvailability: (name_1, ...args_1) => __awaiter(this, [name_1, ...args_1], void 0, function* (name, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('fetchImageNameAvailability', 'name', name);
            const localVarPath = `/core/image/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve details of a specific image by providing the image ID.
         * @summary Get Private Image Details
         * @param {number} id
         * @param {boolean} [includeRelatedVms]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageDetails: (id_1, includeRelatedVms_1, ...args_1) => __awaiter(this, [id_1, includeRelatedVms_1, ...args_1], void 0, function* (id, includeRelatedVms, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getImageDetails', 'id', id);
            const localVarPath = `/core/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (includeRelatedVms !== undefined) {
                localVarQueryParameter['include_related_vms'] = includeRelatedVms;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of all available operating system (OS) images, providing details about each image\'s corresponding virtual machine operating system. You can include the optional `region` parameter in the query string of the request to specifically return OS images from the designated region. Additionally, use the `include_public` parameter to specify whether to include public images in the response. For more information onOS images, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/images).
         * @summary List Images
         * @param {string} [region] Region Name
         * @param {boolean} [includePublic] Flag to include public images in the response (true/false). Default is true.
         * @param {string} [search] Search query to filter images by name
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of Images per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages2: (region_1, includePublic_1, search_1, page_1, perPage_1, ...args_1) => __awaiter(this, [region_1, includePublic_1, search_1, page_1, perPage_1, ...args_1], void 0, function* (region, includePublic, search, page, perPage, options = {}) {
            const localVarPath = `/core/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }
            if (includePublic !== undefined) {
                localVarQueryParameter['include_public'] = includePublic;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ImageApiAxiosParamCreator = ImageApiAxiosParamCreator;
/**
 * ImageApi - functional programming interface
 * @export
 */
const ImageApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ImageApiAxiosParamCreator)(configuration);
    return {
        /**
         * Deletes an image permanently. Provide the image ID in the path to specify the image to be deleted.
         * @summary Delete an image
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteImage(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ImageApi.deleteImage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check if an Image name is available
         * @summary Fetch name availability for Images
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchImageNameAvailability(name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchImageNameAvailability(name, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ImageApi.fetchImageNameAvailability']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve details of a specific image by providing the image ID.
         * @summary Get Private Image Details
         * @param {number} id
         * @param {boolean} [includeRelatedVms]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageDetails(id, includeRelatedVms, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getImageDetails(id, includeRelatedVms, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ImageApi.getImageDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a list of all available operating system (OS) images, providing details about each image\'s corresponding virtual machine operating system. You can include the optional `region` parameter in the query string of the request to specifically return OS images from the designated region. Additionally, use the `include_public` parameter to specify whether to include public images in the response. For more information onOS images, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/images).
         * @summary List Images
         * @param {string} [region] Region Name
         * @param {boolean} [includePublic] Flag to include public images in the response (true/false). Default is true.
         * @param {string} [search] Search query to filter images by name
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of Images per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages2(region, includePublic, search, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listImages2(region, includePublic, search, page, perPage, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ImageApi.listImages2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ImageApiFp = ImageApiFp;
/**
 * ImageApi - factory interface
 * @export
 */
const ImageApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ImageApiFp)(configuration);
    return {
        /**
         * Deletes an image permanently. Provide the image ID in the path to specify the image to be deleted.
         * @summary Delete an image
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage(id, options) {
            return localVarFp.deleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if an Image name is available
         * @summary Fetch name availability for Images
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchImageNameAvailability(name, options) {
            return localVarFp.fetchImageNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific image by providing the image ID.
         * @summary Get Private Image Details
         * @param {number} id
         * @param {boolean} [includeRelatedVms]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageDetails(id, includeRelatedVms, options) {
            return localVarFp.getImageDetails(id, includeRelatedVms, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all available operating system (OS) images, providing details about each image\'s corresponding virtual machine operating system. You can include the optional `region` parameter in the query string of the request to specifically return OS images from the designated region. Additionally, use the `include_public` parameter to specify whether to include public images in the response. For more information onOS images, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/images).
         * @summary List Images
         * @param {string} [region] Region Name
         * @param {boolean} [includePublic] Flag to include public images in the response (true/false). Default is true.
         * @param {string} [search] Search query to filter images by name
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of Images per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages2(region, includePublic, search, page, perPage, options) {
            return localVarFp.listImages2(region, includePublic, search, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ImageApiFactory = ImageApiFactory;
/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
class ImageApi extends base_1.BaseAPI {
    /**
     * Deletes an image permanently. Provide the image ID in the path to specify the image to be deleted.
     * @summary Delete an image
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    deleteImage(id, options) {
        return (0, exports.ImageApiFp)(this.configuration).deleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if an Image name is available
     * @summary Fetch name availability for Images
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    fetchImageNameAvailability(name, options) {
        return (0, exports.ImageApiFp)(this.configuration).fetchImageNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve details of a specific image by providing the image ID.
     * @summary Get Private Image Details
     * @param {number} id
     * @param {boolean} [includeRelatedVms]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    getImageDetails(id, includeRelatedVms, options) {
        return (0, exports.ImageApiFp)(this.configuration).getImageDetails(id, includeRelatedVms, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of all available operating system (OS) images, providing details about each image\'s corresponding virtual machine operating system. You can include the optional `region` parameter in the query string of the request to specifically return OS images from the designated region. Additionally, use the `include_public` parameter to specify whether to include public images in the response. For more information onOS images, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/images).
     * @summary List Images
     * @param {string} [region] Region Name
     * @param {boolean} [includePublic] Flag to include public images in the response (true/false). Default is true.
     * @param {string} [search] Search query to filter images by name
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of Images per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    listImages2(region, includePublic, search, page, perPage, options) {
        return (0, exports.ImageApiFp)(this.configuration).listImages2(region, includePublic, search, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ImageApi = ImageApi;
/**
 * InviteApi - axios parameter creator
 * @export
 */
const InviteApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accept an invitation for a user to join your organization.
         * @summary Accept Invite
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('acceptInvite', 'id', id);
            const localVarPath = `/auth/invites/{id}/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes an invitation for a user to join your organization. For additional information on deleting an invitation, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/delete-invite).
         * @summary Accept Invite
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvite', 'id', id);
            const localVarPath = `/auth/invites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Invites a user to join your organization. For additional information on inviting users to the organization, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/invite-member).
         * @summary Invite User to Organization
         * @param {InviteUserPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToOrganization: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('inviteUserToOrganization', 'payload', payload);
            const localVarPath = `/auth/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a list of email invitations from your organization. For additional information on listing invited users, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/list-invites).
         * @summary List Invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvites: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InviteApiAxiosParamCreator = InviteApiAxiosParamCreator;
/**
 * InviteApi - functional programming interface
 * @export
 */
const InviteApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InviteApiAxiosParamCreator)(configuration);
    return {
        /**
         * Accept an invitation for a user to join your organization.
         * @summary Accept Invite
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptInvite(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InviteApi.acceptInvite']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes an invitation for a user to join your organization. For additional information on deleting an invitation, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/delete-invite).
         * @summary Accept Invite
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvite(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InviteApi.deleteInvite']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Invites a user to join your organization. For additional information on inviting users to the organization, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/invite-member).
         * @summary Invite User to Organization
         * @param {InviteUserPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToOrganization(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.inviteUserToOrganization(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InviteApi.inviteUserToOrganization']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a list of email invitations from your organization. For additional information on listing invited users, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/list-invites).
         * @summary List Invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvites(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listInvites(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InviteApi.listInvites']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.InviteApiFp = InviteApiFp;
/**
 * InviteApi - factory interface
 * @export
 */
const InviteApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InviteApiFp)(configuration);
    return {
        /**
         * Accept an invitation for a user to join your organization.
         * @summary Accept Invite
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(id, options) {
            return localVarFp.acceptInvite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an invitation for a user to join your organization. For additional information on deleting an invitation, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/delete-invite).
         * @summary Accept Invite
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite(id, options) {
            return localVarFp.deleteInvite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Invites a user to join your organization. For additional information on inviting users to the organization, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/invite-member).
         * @summary Invite User to Organization
         * @param {InviteUserPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToOrganization(payload, options) {
            return localVarFp.inviteUserToOrganization(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of email invitations from your organization. For additional information on listing invited users, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/list-invites).
         * @summary List Invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvites(options) {
            return localVarFp.listInvites(options).then((request) => request(axios, basePath));
        },
    };
};
exports.InviteApiFactory = InviteApiFactory;
/**
 * InviteApi - object-oriented interface
 * @export
 * @class InviteApi
 * @extends {BaseAPI}
 */
class InviteApi extends base_1.BaseAPI {
    /**
     * Accept an invitation for a user to join your organization.
     * @summary Accept Invite
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    acceptInvite(id, options) {
        return (0, exports.InviteApiFp)(this.configuration).acceptInvite(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an invitation for a user to join your organization. For additional information on deleting an invitation, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/delete-invite).
     * @summary Accept Invite
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    deleteInvite(id, options) {
        return (0, exports.InviteApiFp)(this.configuration).deleteInvite(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Invites a user to join your organization. For additional information on inviting users to the organization, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/invite-member).
     * @summary Invite User to Organization
     * @param {InviteUserPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    inviteUserToOrganization(payload, options) {
        return (0, exports.InviteApiFp)(this.configuration).inviteUserToOrganization(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a list of email invitations from your organization. For additional information on listing invited users, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/list-invites).
     * @summary List Invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    listInvites(options) {
        return (0, exports.InviteApiFp)(this.configuration).listInvites(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InviteApi = InviteApi;
/**
 * KeypairApi - axios parameter creator
 * @export
 */
const KeypairApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Permanently deletes a specified key pair. Provide the key pair ID in the path to remove the designated key pair.
         * @summary Delete key pair
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeyPair: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteKeyPair', 'id', id);
            const localVarPath = `/core/keypair/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Imports a new key pair for secure shell (SSH) access to your resources. Provide the key name, environment name, and public key in the request body. For more details on importing SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/import-keypair).
         * @summary Import key pair
         * @param {ImportKeypairPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importKeyPair: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('importKeyPair', 'payload', payload);
            const localVarPath = `/core/keypairs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a list of your existing SSH key pairs, providing details for each. For more information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
         * @summary List key pairs
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeyPairs: (page_1, pageSize_1, search_1, ...args_1) => __awaiter(this, [page_1, pageSize_1, search_1, ...args_1], void 0, function* (page, pageSize, search, options = {}) {
            const localVarPath = `/core/keypairs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the name of a specified key pair. Provide the key pair ID in the path, and include the new `name` in the request body.
         * @summary Update key pair name
         * @param {number} id
         * @param {UpdateKeypairName} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyPairName: (id_1, payload_1, ...args_1) => __awaiter(this, [id_1, payload_1, ...args_1], void 0, function* (id, payload, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateKeyPairName', 'id', id);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateKeyPairName', 'payload', payload);
            const localVarPath = `/core/keypair/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.KeypairApiAxiosParamCreator = KeypairApiAxiosParamCreator;
/**
 * KeypairApi - functional programming interface
 * @export
 */
const KeypairApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.KeypairApiAxiosParamCreator)(configuration);
    return {
        /**
         * Permanently deletes a specified key pair. Provide the key pair ID in the path to remove the designated key pair.
         * @summary Delete key pair
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeyPair(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteKeyPair(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['KeypairApi.deleteKeyPair']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Imports a new key pair for secure shell (SSH) access to your resources. Provide the key name, environment name, and public key in the request body. For more details on importing SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/import-keypair).
         * @summary Import key pair
         * @param {ImportKeypairPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importKeyPair(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.importKeyPair(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['KeypairApi.importKeyPair']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a list of your existing SSH key pairs, providing details for each. For more information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
         * @summary List key pairs
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeyPairs(page, pageSize, search, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listKeyPairs(page, pageSize, search, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['KeypairApi.listKeyPairs']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the name of a specified key pair. Provide the key pair ID in the path, and include the new `name` in the request body.
         * @summary Update key pair name
         * @param {number} id
         * @param {UpdateKeypairName} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyPairName(id, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateKeyPairName(id, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['KeypairApi.updateKeyPairName']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.KeypairApiFp = KeypairApiFp;
/**
 * KeypairApi - factory interface
 * @export
 */
const KeypairApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.KeypairApiFp)(configuration);
    return {
        /**
         * Permanently deletes a specified key pair. Provide the key pair ID in the path to remove the designated key pair.
         * @summary Delete key pair
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeyPair(id, options) {
            return localVarFp.deleteKeyPair(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports a new key pair for secure shell (SSH) access to your resources. Provide the key name, environment name, and public key in the request body. For more details on importing SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/import-keypair).
         * @summary Import key pair
         * @param {ImportKeypairPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importKeyPair(payload, options) {
            return localVarFp.importKeyPair(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of your existing SSH key pairs, providing details for each. For more information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
         * @summary List key pairs
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeyPairs(page, pageSize, search, options) {
            return localVarFp.listKeyPairs(page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the name of a specified key pair. Provide the key pair ID in the path, and include the new `name` in the request body.
         * @summary Update key pair name
         * @param {number} id
         * @param {UpdateKeypairName} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyPairName(id, payload, options) {
            return localVarFp.updateKeyPairName(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.KeypairApiFactory = KeypairApiFactory;
/**
 * KeypairApi - object-oriented interface
 * @export
 * @class KeypairApi
 * @extends {BaseAPI}
 */
class KeypairApi extends base_1.BaseAPI {
    /**
     * Permanently deletes a specified key pair. Provide the key pair ID in the path to remove the designated key pair.
     * @summary Delete key pair
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    deleteKeyPair(id, options) {
        return (0, exports.KeypairApiFp)(this.configuration).deleteKeyPair(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Imports a new key pair for secure shell (SSH) access to your resources. Provide the key name, environment name, and public key in the request body. For more details on importing SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/import-keypair).
     * @summary Import key pair
     * @param {ImportKeypairPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    importKeyPair(payload, options) {
        return (0, exports.KeypairApiFp)(this.configuration).importKeyPair(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of your existing SSH key pairs, providing details for each. For more information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
     * @summary List key pairs
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    listKeyPairs(page, pageSize, search, options) {
        return (0, exports.KeypairApiFp)(this.configuration).listKeyPairs(page, pageSize, search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the name of a specified key pair. Provide the key pair ID in the path, and include the new `name` in the request body.
     * @summary Update key pair name
     * @param {number} id
     * @param {UpdateKeypairName} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    updateKeyPairName(id, payload, options) {
        return (0, exports.KeypairApiFp)(this.configuration).updateKeyPairName(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.KeypairApi = KeypairApi;
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
const OrganizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Removes a member from your organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/remove-member).
         * @summary Remove Organization Member
         * @param {RemoveMemberPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationMember: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('removeOrganizationMember', 'payload', payload);
            const localVarPath = `/auth/organizations/remove-member`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves detailed information about your organization, including current credit, threshold, number of instances, and number of volumes. For additional information on organizations, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/retrieve-org-details).
         * @summary Retrieve Organization Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrganizationInformation: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the name of the organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/update-org-name).
         * @summary Update Organization Information
         * @param {UpdateOrganizationPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationInformation: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateOrganizationInformation', 'payload', payload);
            const localVarPath = `/auth/organizations/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OrganizationApiAxiosParamCreator = OrganizationApiAxiosParamCreator;
/**
 * OrganizationApi - functional programming interface
 * @export
 */
const OrganizationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.OrganizationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Removes a member from your organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/remove-member).
         * @summary Remove Organization Member
         * @param {RemoveMemberPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationMember(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.removeOrganizationMember(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrganizationApi.removeOrganizationMember']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves detailed information about your organization, including current credit, threshold, number of instances, and number of volumes. For additional information on organizations, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/retrieve-org-details).
         * @summary Retrieve Organization Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrganizationInformation(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveOrganizationInformation(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrganizationApi.retrieveOrganizationInformation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the name of the organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/update-org-name).
         * @summary Update Organization Information
         * @param {UpdateOrganizationPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationInformation(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateOrganizationInformation(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrganizationApi.updateOrganizationInformation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.OrganizationApiFp = OrganizationApiFp;
/**
 * OrganizationApi - factory interface
 * @export
 */
const OrganizationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.OrganizationApiFp)(configuration);
    return {
        /**
         * Removes a member from your organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/remove-member).
         * @summary Remove Organization Member
         * @param {RemoveMemberPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationMember(payload, options) {
            return localVarFp.removeOrganizationMember(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about your organization, including current credit, threshold, number of instances, and number of volumes. For additional information on organizations, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/retrieve-org-details).
         * @summary Retrieve Organization Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrganizationInformation(options) {
            return localVarFp.retrieveOrganizationInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the name of the organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/update-org-name).
         * @summary Update Organization Information
         * @param {UpdateOrganizationPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationInformation(payload, options) {
            return localVarFp.updateOrganizationInformation(payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.OrganizationApiFactory = OrganizationApiFactory;
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
class OrganizationApi extends base_1.BaseAPI {
    /**
     * Removes a member from your organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/remove-member).
     * @summary Remove Organization Member
     * @param {RemoveMemberPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    removeOrganizationMember(payload, options) {
        return (0, exports.OrganizationApiFp)(this.configuration).removeOrganizationMember(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves detailed information about your organization, including current credit, threshold, number of instances, and number of volumes. For additional information on organizations, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/retrieve-org-details).
     * @summary Retrieve Organization Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    retrieveOrganizationInformation(options) {
        return (0, exports.OrganizationApiFp)(this.configuration).retrieveOrganizationInformation(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the name of the organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/update-org-name).
     * @summary Update Organization Information
     * @param {UpdateOrganizationPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateOrganizationInformation(payload, options) {
        return (0, exports.OrganizationApiFp)(this.configuration).updateOrganizationInformation(payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OrganizationApi = OrganizationApi;
/**
 * PartnerConfigApi - axios parameter creator
 * @export
 */
const PartnerConfigApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch the customised customer configuration for Hyperstack.
         * @summary Get partner config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfig: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/partner-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch the partner config for a given domain.
         * @param {string} [domain] The domain to look up the partner config for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfigByDomain: (domain_1, ...args_1) => __awaiter(this, [domain_1, ...args_1], void 0, function* (domain, options = {}) {
            const localVarPath = `/auth/partner-config/docs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PartnerConfigApiAxiosParamCreator = PartnerConfigApiAxiosParamCreator;
/**
 * PartnerConfigApi - functional programming interface
 * @export
 */
const PartnerConfigApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PartnerConfigApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetch the customised customer configuration for Hyperstack.
         * @summary Get partner config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfig(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPartnerConfig(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PartnerConfigApi.getPartnerConfig']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fetch the partner config for a given domain.
         * @param {string} [domain] The domain to look up the partner config for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfigByDomain(domain, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPartnerConfigByDomain(domain, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PartnerConfigApi.getPartnerConfigByDomain']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.PartnerConfigApiFp = PartnerConfigApiFp;
/**
 * PartnerConfigApi - factory interface
 * @export
 */
const PartnerConfigApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PartnerConfigApiFp)(configuration);
    return {
        /**
         * Fetch the customised customer configuration for Hyperstack.
         * @summary Get partner config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfig(options) {
            return localVarFp.getPartnerConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the partner config for a given domain.
         * @param {string} [domain] The domain to look up the partner config for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfigByDomain(domain, options) {
            return localVarFp.getPartnerConfigByDomain(domain, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PartnerConfigApiFactory = PartnerConfigApiFactory;
/**
 * PartnerConfigApi - object-oriented interface
 * @export
 * @class PartnerConfigApi
 * @extends {BaseAPI}
 */
class PartnerConfigApi extends base_1.BaseAPI {
    /**
     * Fetch the customised customer configuration for Hyperstack.
     * @summary Get partner config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerConfigApi
     */
    getPartnerConfig(options) {
        return (0, exports.PartnerConfigApiFp)(this.configuration).getPartnerConfig(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the partner config for a given domain.
     * @param {string} [domain] The domain to look up the partner config for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerConfigApi
     */
    getPartnerConfigByDomain(domain, options) {
        return (0, exports.PartnerConfigApiFp)(this.configuration).getPartnerConfigByDomain(domain, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PartnerConfigApi = PartnerConfigApi;
/**
 * PaymentApi - axios parameter creator
 * @export
 */
const PaymentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all payments made within your [**organization**](/docs/rbac/organization) and their details, including the amount, payment status, and more. For additional information [**click here**](None/docs/api-reference/billing-resources/retrieve-payment-history/).
         * @summary GET: View payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/billing/payment/payment-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve the payment receipt from Stripe for a specific payment
         * @summary Retrieve Payment Receipt
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentReceipt2: (paymentId_1, ...args_1) => __awaiter(this, [paymentId_1, ...args_1], void 0, function* (paymentId, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentReceipt2', 'paymentId', paymentId);
            const localVarPath = `/billing/payment/receipt/{payment_id}`
                .replace(`{${"payment_id"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a payment for a specified amount, adding credit to the balance of your [**organization**](/docs/rbac/organization). Include the `amount` in the body of the request to make a payment for the specified value in dollars. View a history of past payments by calling the [**Retrieve Payment History**](/docs/api-reference/billing-resources/retrieve-payment-history) API. For additional information [**click here**](None/docs/api-reference/billing-resources/create-payment).
         * @summary POST: Initiate payment
         * @param {PaymentInitiatePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPayment: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postPayment', 'payload', payload);
            const localVarPath = `/billing/payment/payment-initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PaymentApiAxiosParamCreator = PaymentApiAxiosParamCreator;
/**
 * PaymentApi - functional programming interface
 * @export
 */
const PaymentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PaymentApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of all payments made within your [**organization**](/docs/rbac/organization) and their details, including the amount, payment status, and more. For additional information [**click here**](None/docs/api-reference/billing-resources/retrieve-payment-history/).
         * @summary GET: View payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDetails(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PaymentApi.getDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve the payment receipt from Stripe for a specific payment
         * @summary Retrieve Payment Receipt
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentReceipt2(paymentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentReceipt2(paymentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PaymentApi.getPaymentReceipt2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a payment for a specified amount, adding credit to the balance of your [**organization**](/docs/rbac/organization). Include the `amount` in the body of the request to make a payment for the specified value in dollars. View a history of past payments by calling the [**Retrieve Payment History**](/docs/api-reference/billing-resources/retrieve-payment-history) API. For additional information [**click here**](None/docs/api-reference/billing-resources/create-payment).
         * @summary POST: Initiate payment
         * @param {PaymentInitiatePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPayment(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postPayment(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PaymentApi.postPayment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.PaymentApiFp = PaymentApiFp;
/**
 * PaymentApi - factory interface
 * @export
 */
const PaymentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PaymentApiFp)(configuration);
    return {
        /**
         * Retrieves a list of all payments made within your [**organization**](/docs/rbac/organization) and their details, including the amount, payment status, and more. For additional information [**click here**](None/docs/api-reference/billing-resources/retrieve-payment-history/).
         * @summary GET: View payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetails(options) {
            return localVarFp.getDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the payment receipt from Stripe for a specific payment
         * @summary Retrieve Payment Receipt
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentReceipt2(paymentId, options) {
            return localVarFp.getPaymentReceipt2(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a payment for a specified amount, adding credit to the balance of your [**organization**](/docs/rbac/organization). Include the `amount` in the body of the request to make a payment for the specified value in dollars. View a history of past payments by calling the [**Retrieve Payment History**](/docs/api-reference/billing-resources/retrieve-payment-history) API. For additional information [**click here**](None/docs/api-reference/billing-resources/create-payment).
         * @summary POST: Initiate payment
         * @param {PaymentInitiatePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPayment(payload, options) {
            return localVarFp.postPayment(payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PaymentApiFactory = PaymentApiFactory;
/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
class PaymentApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of all payments made within your [**organization**](/docs/rbac/organization) and their details, including the amount, payment status, and more. For additional information [**click here**](None/docs/api-reference/billing-resources/retrieve-payment-history/).
     * @summary GET: View payment details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getDetails(options) {
        return (0, exports.PaymentApiFp)(this.configuration).getDetails(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the payment receipt from Stripe for a specific payment
     * @summary Retrieve Payment Receipt
     * @param {string} paymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPaymentReceipt2(paymentId, options) {
        return (0, exports.PaymentApiFp)(this.configuration).getPaymentReceipt2(paymentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a payment for a specified amount, adding credit to the balance of your [**organization**](/docs/rbac/organization). Include the `amount` in the body of the request to make a payment for the specified value in dollars. View a history of past payments by calling the [**Retrieve Payment History**](/docs/api-reference/billing-resources/retrieve-payment-history) API. For additional information [**click here**](None/docs/api-reference/billing-resources/create-payment).
     * @summary POST: Initiate payment
     * @param {PaymentInitiatePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    postPayment(payload, options) {
        return (0, exports.PaymentApiFp)(this.configuration).postPayment(payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PaymentApi = PaymentApi;
/**
 * PermissionApi - axios parameter creator
 * @export
 */
const PermissionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of permissions that users can be granted to access a particular resource action. For additional information on permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/permissions).
         * @summary List Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PermissionApiAxiosParamCreator = PermissionApiAxiosParamCreator;
/**
 * PermissionApi - functional programming interface
 * @export
 */
const PermissionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PermissionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of permissions that users can be granted to access a particular resource action. For additional information on permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/permissions).
         * @summary List Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPermissions(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PermissionApi.listPermissions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.PermissionApiFp = PermissionApiFp;
/**
 * PermissionApi - factory interface
 * @export
 */
const PermissionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PermissionApiFp)(configuration);
    return {
        /**
         * Retrieves a list of permissions that users can be granted to access a particular resource action. For additional information on permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/permissions).
         * @summary List Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(options) {
            return localVarFp.listPermissions(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PermissionApiFactory = PermissionApiFactory;
/**
 * PermissionApi - object-oriented interface
 * @export
 * @class PermissionApi
 * @extends {BaseAPI}
 */
class PermissionApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of permissions that users can be granted to access a particular resource action. For additional information on permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/permissions).
     * @summary List Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    listPermissions(options) {
        return (0, exports.PermissionApiFp)(this.configuration).listPermissions(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PermissionApi = PermissionApi;
/**
 * PolicyApi - axios parameter creator
 * @export
 */
const PolicyApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of policies available for addition to RBAC roles. For additional information on policies, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/policies).
         * @summary List Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PolicyApiAxiosParamCreator = PolicyApiAxiosParamCreator;
/**
 * PolicyApi - functional programming interface
 * @export
 */
const PolicyApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PolicyApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of policies available for addition to RBAC roles. For additional information on policies, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/policies).
         * @summary List Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPolicies(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PolicyApi.listPolicies']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.PolicyApiFp = PolicyApiFp;
/**
 * PolicyApi - factory interface
 * @export
 */
const PolicyApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PolicyApiFp)(configuration);
    return {
        /**
         * Retrieves a list of policies available for addition to RBAC roles. For additional information on policies, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/policies).
         * @summary List Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(options) {
            return localVarFp.listPolicies(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PolicyApiFactory = PolicyApiFactory;
/**
 * PolicyApi - object-oriented interface
 * @export
 * @class PolicyApi
 * @extends {BaseAPI}
 */
class PolicyApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of policies available for addition to RBAC roles. For additional information on policies, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/policies).
     * @summary List Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    listPolicies(options) {
        return (0, exports.PolicyApiFp)(this.configuration).listPolicies(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PolicyApi = PolicyApi;
/**
 * PricebookApi - axios parameter creator
 * @export
 */
const PricebookApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the Infrahub Pricebook, detailing hourly running costs for all resources offered by Infrahub. For more information on Pricebook [**click here**](None/docs/api-reference/pricebook-resources/pricebook/).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricebook: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/pricebook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PricebookApiAxiosParamCreator = PricebookApiAxiosParamCreator;
/**
 * PricebookApi - functional programming interface
 * @export
 */
const PricebookApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PricebookApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves the Infrahub Pricebook, detailing hourly running costs for all resources offered by Infrahub. For more information on Pricebook [**click here**](None/docs/api-reference/pricebook-resources/pricebook/).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricebook(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPricebook(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PricebookApi.getPricebook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.PricebookApiFp = PricebookApiFp;
/**
 * PricebookApi - factory interface
 * @export
 */
const PricebookApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PricebookApiFp)(configuration);
    return {
        /**
         * Retrieves the Infrahub Pricebook, detailing hourly running costs for all resources offered by Infrahub. For more information on Pricebook [**click here**](None/docs/api-reference/pricebook-resources/pricebook/).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricebook(options) {
            return localVarFp.getPricebook(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PricebookApiFactory = PricebookApiFactory;
/**
 * PricebookApi - object-oriented interface
 * @export
 * @class PricebookApi
 * @extends {BaseAPI}
 */
class PricebookApi extends base_1.BaseAPI {
    /**
     * Retrieves the Infrahub Pricebook, detailing hourly running costs for all resources offered by Infrahub. For more information on Pricebook [**click here**](None/docs/api-reference/pricebook-resources/pricebook/).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricebookApi
     */
    getPricebook(options) {
        return (0, exports.PricebookApiFp)(this.configuration).getPricebook(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PricebookApi = PricebookApi;
/**
 * ProfileApi - axios parameter creator
 * @export
 */
const ProfileApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a provisioning profile to save the configuration of a virtual machinefor future use. Include the profile name, description, and virtual machine configuration details in the request body. For more information about virtual machine profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Create profile
         * @param {CreateProfilePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createProfile', 'payload', payload);
            const localVarPath = `/core/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Permanently deletes a provisioning profile. Supply the profile ID in the path to delete the specified profile.
         * @summary Delete profile
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteProfile', 'id', id);
            const localVarPath = `/core/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of your existing provisioning profiles, providing virtual machine configuration details for each. For additional information about profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles#load-a-provisioning-profile).
         * @summary List profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves details for an existing provisioning profile by supplying the profile ID in the request path. For more information about profiles, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Retrieve profile details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProfileDetails: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('retrieveProfileDetails', 'id', id);
            const localVarPath = `/core/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ProfileApiAxiosParamCreator = ProfileApiAxiosParamCreator;
/**
 * ProfileApi - functional programming interface
 * @export
 */
const ProfileApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProfileApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a provisioning profile to save the configuration of a virtual machinefor future use. Include the profile name, description, and virtual machine configuration details in the request body. For more information about virtual machine profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Create profile
         * @param {CreateProfilePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createProfile(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProfileApi.createProfile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Permanently deletes a provisioning profile. Supply the profile ID in the path to delete the specified profile.
         * @summary Delete profile
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteProfile(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProfileApi.deleteProfile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a list of your existing provisioning profiles, providing virtual machine configuration details for each. For additional information about profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles#load-a-provisioning-profile).
         * @summary List profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listProfiles(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProfileApi.listProfiles']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves details for an existing provisioning profile by supplying the profile ID in the request path. For more information about profiles, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Retrieve profile details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProfileDetails(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveProfileDetails(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProfileApi.retrieveProfileDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ProfileApiFp = ProfileApiFp;
/**
 * ProfileApi - factory interface
 * @export
 */
const ProfileApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProfileApiFp)(configuration);
    return {
        /**
         * Creates a provisioning profile to save the configuration of a virtual machinefor future use. Include the profile name, description, and virtual machine configuration details in the request body. For more information about virtual machine profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Create profile
         * @param {CreateProfilePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(payload, options) {
            return localVarFp.createProfile(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a provisioning profile. Supply the profile ID in the path to delete the specified profile.
         * @summary Delete profile
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id, options) {
            return localVarFp.deleteProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your existing provisioning profiles, providing virtual machine configuration details for each. For additional information about profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles#load-a-provisioning-profile).
         * @summary List profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles(options) {
            return localVarFp.listProfiles(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details for an existing provisioning profile by supplying the profile ID in the request path. For more information about profiles, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Retrieve profile details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProfileDetails(id, options) {
            return localVarFp.retrieveProfileDetails(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ProfileApiFactory = ProfileApiFactory;
/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
class ProfileApi extends base_1.BaseAPI {
    /**
     * Creates a provisioning profile to save the configuration of a virtual machinefor future use. Include the profile name, description, and virtual machine configuration details in the request body. For more information about virtual machine profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
     * @summary Create profile
     * @param {CreateProfilePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    createProfile(payload, options) {
        return (0, exports.ProfileApiFp)(this.configuration).createProfile(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Permanently deletes a provisioning profile. Supply the profile ID in the path to delete the specified profile.
     * @summary Delete profile
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    deleteProfile(id, options) {
        return (0, exports.ProfileApiFp)(this.configuration).deleteProfile(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of your existing provisioning profiles, providing virtual machine configuration details for each. For additional information about profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles#load-a-provisioning-profile).
     * @summary List profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    listProfiles(options) {
        return (0, exports.ProfileApiFp)(this.configuration).listProfiles(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves details for an existing provisioning profile by supplying the profile ID in the request path. For more information about profiles, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
     * @summary Retrieve profile details
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    retrieveProfileDetails(id, options) {
        return (0, exports.ProfileApiFp)(this.configuration).retrieveProfileDetails(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProfileApi = ProfileApi;
/**
 * RbacRoleApi - axios parameter creator
 * @export
 */
const RbacRoleApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates an RBAC role that can be assigned to users, granting them access to specific resource actions. Provide the configuration of the RBAC role, including its name, description, and list of permissions and policy IDs in the request body. For additional information on creating RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/create-rbac-role).
         * @summary Create RBAC Role
         * @param {CreateUpdateRbacRolePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRBACRole: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createRBACRole', 'payload', payload);
            const localVarPath = `/auth/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes an RBAC role by providing its ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/delete-rbac-role).
         * @summary Delete RBAC Role
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRBACRole: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteRBACRole', 'id', id);
            const localVarPath = `/auth/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a list of RBAC roles that can be assigned to the users within an organization. For additional information on RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/list-rbac-roles).
         * @summary List RBAC Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRBACRoles: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the details of a specified RBAC role by providing the RBAC role ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/retrieve-rbac-details).
         * @summary Retrieve RBAC Role Details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRBACRoleDetails: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('retrieveRBACRoleDetails', 'id', id);
            const localVarPath = `/auth/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an RBAC role by providing the role ID in the path and the modified role configuration in the request body, including its name, description, and list of permissions and policy IDs. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/update-rbac-role).
         * @summary Update RBAC Role
         * @param {number} id
         * @param {CreateUpdateRbacRolePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRBACRole: (id_1, payload_1, ...args_1) => __awaiter(this, [id_1, payload_1, ...args_1], void 0, function* (id, payload, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateRBACRole', 'id', id);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateRBACRole', 'payload', payload);
            const localVarPath = `/auth/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RbacRoleApiAxiosParamCreator = RbacRoleApiAxiosParamCreator;
/**
 * RbacRoleApi - functional programming interface
 * @export
 */
const RbacRoleApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RbacRoleApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates an RBAC role that can be assigned to users, granting them access to specific resource actions. Provide the configuration of the RBAC role, including its name, description, and list of permissions and policy IDs in the request body. For additional information on creating RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/create-rbac-role).
         * @summary Create RBAC Role
         * @param {CreateUpdateRbacRolePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRBACRole(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRBACRole(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RbacRoleApi.createRBACRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes an RBAC role by providing its ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/delete-rbac-role).
         * @summary Delete RBAC Role
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRBACRole(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRBACRole(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RbacRoleApi.deleteRBACRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a list of RBAC roles that can be assigned to the users within an organization. For additional information on RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/list-rbac-roles).
         * @summary List RBAC Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRBACRoles(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRBACRoles(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RbacRoleApi.listRBACRoles']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the details of a specified RBAC role by providing the RBAC role ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/retrieve-rbac-details).
         * @summary Retrieve RBAC Role Details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRBACRoleDetails(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveRBACRoleDetails(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RbacRoleApi.retrieveRBACRoleDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an RBAC role by providing the role ID in the path and the modified role configuration in the request body, including its name, description, and list of permissions and policy IDs. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/update-rbac-role).
         * @summary Update RBAC Role
         * @param {number} id
         * @param {CreateUpdateRbacRolePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRBACRole(id, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRBACRole(id, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RbacRoleApi.updateRBACRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.RbacRoleApiFp = RbacRoleApiFp;
/**
 * RbacRoleApi - factory interface
 * @export
 */
const RbacRoleApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RbacRoleApiFp)(configuration);
    return {
        /**
         * Creates an RBAC role that can be assigned to users, granting them access to specific resource actions. Provide the configuration of the RBAC role, including its name, description, and list of permissions and policy IDs in the request body. For additional information on creating RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/create-rbac-role).
         * @summary Create RBAC Role
         * @param {CreateUpdateRbacRolePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRBACRole(payload, options) {
            return localVarFp.createRBACRole(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an RBAC role by providing its ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/delete-rbac-role).
         * @summary Delete RBAC Role
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRBACRole(id, options) {
            return localVarFp.deleteRBACRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of RBAC roles that can be assigned to the users within an organization. For additional information on RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/list-rbac-roles).
         * @summary List RBAC Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRBACRoles(options) {
            return localVarFp.listRBACRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a specified RBAC role by providing the RBAC role ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/retrieve-rbac-details).
         * @summary Retrieve RBAC Role Details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRBACRoleDetails(id, options) {
            return localVarFp.retrieveRBACRoleDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an RBAC role by providing the role ID in the path and the modified role configuration in the request body, including its name, description, and list of permissions and policy IDs. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/update-rbac-role).
         * @summary Update RBAC Role
         * @param {number} id
         * @param {CreateUpdateRbacRolePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRBACRole(id, payload, options) {
            return localVarFp.updateRBACRole(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RbacRoleApiFactory = RbacRoleApiFactory;
/**
 * RbacRoleApi - object-oriented interface
 * @export
 * @class RbacRoleApi
 * @extends {BaseAPI}
 */
class RbacRoleApi extends base_1.BaseAPI {
    /**
     * Creates an RBAC role that can be assigned to users, granting them access to specific resource actions. Provide the configuration of the RBAC role, including its name, description, and list of permissions and policy IDs in the request body. For additional information on creating RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/create-rbac-role).
     * @summary Create RBAC Role
     * @param {CreateUpdateRbacRolePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    createRBACRole(payload, options) {
        return (0, exports.RbacRoleApiFp)(this.configuration).createRBACRole(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an RBAC role by providing its ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/delete-rbac-role).
     * @summary Delete RBAC Role
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    deleteRBACRole(id, options) {
        return (0, exports.RbacRoleApiFp)(this.configuration).deleteRBACRole(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of RBAC roles that can be assigned to the users within an organization. For additional information on RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/list-rbac-roles).
     * @summary List RBAC Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    listRBACRoles(options) {
        return (0, exports.RbacRoleApiFp)(this.configuration).listRBACRoles(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the details of a specified RBAC role by providing the RBAC role ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/retrieve-rbac-details).
     * @summary Retrieve RBAC Role Details
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    retrieveRBACRoleDetails(id, options) {
        return (0, exports.RbacRoleApiFp)(this.configuration).retrieveRBACRoleDetails(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an RBAC role by providing the role ID in the path and the modified role configuration in the request body, including its name, description, and list of permissions and policy IDs. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/update-rbac-role).
     * @summary Update RBAC Role
     * @param {number} id
     * @param {CreateUpdateRbacRolePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    updateRBACRole(id, payload, options) {
        return (0, exports.RbacRoleApiFp)(this.configuration).updateRBACRole(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RbacRoleApi = RbacRoleApi;
/**
 * RegionApi - axios parameter creator
 * @export
 */
const RegionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Lists the currently available regions, each representing a distinct geographic  location housing a data center. For additional information on regions, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/regions).
         * @summary List Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegions: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RegionApiAxiosParamCreator = RegionApiAxiosParamCreator;
/**
 * RegionApi - functional programming interface
 * @export
 */
const RegionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RegionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Lists the currently available regions, each representing a distinct geographic  location housing a data center. For additional information on regions, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/regions).
         * @summary List Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegions(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRegions(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RegionApi.listRegions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.RegionApiFp = RegionApiFp;
/**
 * RegionApi - factory interface
 * @export
 */
const RegionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RegionApiFp)(configuration);
    return {
        /**
         * Lists the currently available regions, each representing a distinct geographic  location housing a data center. For additional information on regions, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/regions).
         * @summary List Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegions(options) {
            return localVarFp.listRegions(options).then((request) => request(axios, basePath));
        },
    };
};
exports.RegionApiFactory = RegionApiFactory;
/**
 * RegionApi - object-oriented interface
 * @export
 * @class RegionApi
 * @extends {BaseAPI}
 */
class RegionApi extends base_1.BaseAPI {
    /**
     * Lists the currently available regions, each representing a distinct geographic  location housing a data center. For additional information on regions, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/regions).
     * @summary List Regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    listRegions(options) {
        return (0, exports.RegionApiFp)(this.configuration).listRegions(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RegionApi = RegionApi;
/**
 * SecurityRulesApi - axios parameter creator
 * @export
 */
const SecurityRulesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of all available protocols that can be used in the creation of firewall rules for your virtual machines.
         * @summary List firewall rule protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFirewallRuleProtocols: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/sg-rules-protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SecurityRulesApiAxiosParamCreator = SecurityRulesApiAxiosParamCreator;
/**
 * SecurityRulesApi - functional programming interface
 * @export
 */
const SecurityRulesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SecurityRulesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of all available protocols that can be used in the creation of firewall rules for your virtual machines.
         * @summary List firewall rule protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFirewallRuleProtocols(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFirewallRuleProtocols(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SecurityRulesApi.listFirewallRuleProtocols']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.SecurityRulesApiFp = SecurityRulesApiFp;
/**
 * SecurityRulesApi - factory interface
 * @export
 */
const SecurityRulesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SecurityRulesApiFp)(configuration);
    return {
        /**
         * Returns a list of all available protocols that can be used in the creation of firewall rules for your virtual machines.
         * @summary List firewall rule protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFirewallRuleProtocols(options) {
            return localVarFp.listFirewallRuleProtocols(options).then((request) => request(axios, basePath));
        },
    };
};
exports.SecurityRulesApiFactory = SecurityRulesApiFactory;
/**
 * SecurityRulesApi - object-oriented interface
 * @export
 * @class SecurityRulesApi
 * @extends {BaseAPI}
 */
class SecurityRulesApi extends base_1.BaseAPI {
    /**
     * Returns a list of all available protocols that can be used in the creation of firewall rules for your virtual machines.
     * @summary List firewall rule protocols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityRulesApi
     */
    listFirewallRuleProtocols(options) {
        return (0, exports.SecurityRulesApiFp)(this.configuration).listFirewallRuleProtocols(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SecurityRulesApi = SecurityRulesApi;
/**
 * SnapshotEventsApi - axios parameter creator
 * @export
 */
const SnapshotEventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all events for a Snapshot\'s history, which records actions performed on the specific snapshot. Requires the snapshot ID in the path.
         * @summary Fetch all events for a snapshot
         * @param {number} snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllEventsForASnapshot: (snapshotId_1, ...args_1) => __awaiter(this, [snapshotId_1, ...args_1], void 0, function* (snapshotId, options = {}) {
            // verify required parameter 'snapshotId' is not null or undefined
            (0, common_1.assertParamExists)('fetchAllEventsForASnapshot', 'snapshotId', snapshotId);
            const localVarPath = `/core/snapshots/{snapshot_id}/events`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SnapshotEventsApiAxiosParamCreator = SnapshotEventsApiAxiosParamCreator;
/**
 * SnapshotEventsApi - functional programming interface
 * @export
 */
const SnapshotEventsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SnapshotEventsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of all events for a Snapshot\'s history, which records actions performed on the specific snapshot. Requires the snapshot ID in the path.
         * @summary Fetch all events for a snapshot
         * @param {number} snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllEventsForASnapshot(snapshotId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchAllEventsForASnapshot(snapshotId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SnapshotEventsApi.fetchAllEventsForASnapshot']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.SnapshotEventsApiFp = SnapshotEventsApiFp;
/**
 * SnapshotEventsApi - factory interface
 * @export
 */
const SnapshotEventsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SnapshotEventsApiFp)(configuration);
    return {
        /**
         * Retrieves a list of all events for a Snapshot\'s history, which records actions performed on the specific snapshot. Requires the snapshot ID in the path.
         * @summary Fetch all events for a snapshot
         * @param {number} snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllEventsForASnapshot(snapshotId, options) {
            return localVarFp.fetchAllEventsForASnapshot(snapshotId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SnapshotEventsApiFactory = SnapshotEventsApiFactory;
/**
 * SnapshotEventsApi - object-oriented interface
 * @export
 * @class SnapshotEventsApi
 * @extends {BaseAPI}
 */
class SnapshotEventsApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of all events for a Snapshot\'s history, which records actions performed on the specific snapshot. Requires the snapshot ID in the path.
     * @summary Fetch all events for a snapshot
     * @param {number} snapshotId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotEventsApi
     */
    fetchAllEventsForASnapshot(snapshotId, options) {
        return (0, exports.SnapshotEventsApiFp)(this.configuration).fetchAllEventsForASnapshot(snapshotId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SnapshotEventsApi = SnapshotEventsApi;
/**
 * SnapshotsApi - axios parameter creator
 * @export
 */
const SnapshotsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new custom image from an existing snapshot.Requires a name and any labels for your new custom image.
         * @summary Create an image from a snapshot
         * @param {number} snapshotId
         * @param {CreateImagePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createANewCustomImage: (snapshotId_1, payload_1, ...args_1) => __awaiter(this, [snapshotId_1, payload_1, ...args_1], void 0, function* (snapshotId, payload, options = {}) {
            // verify required parameter 'snapshotId' is not null or undefined
            (0, common_1.assertParamExists)('createANewCustomImage', 'snapshotId', snapshotId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createANewCustomImage', 'payload', payload);
            const localVarPath = `/core/snapshots/{snapshot_id}/image`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a snapshot. Provide the snapshot ID in the path to delete the specified snapshot. If the snapshot is connected with an image, that image will also bedeleted and the deleted image ID will be returned in the success message response.
         * @summary Delete snapshot
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteSnapshot', 'id', id);
            const localVarPath = `/core/snapshots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if a Snapshot name is available
         * @summary Fetch snapshot name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSnapshotNameAvailability: (name_1, ...args_1) => __awaiter(this, [name_1, ...args_1], void 0, function* (name, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('fetchSnapshotNameAvailability', 'name', name);
            const localVarPath = `/core/snapshots/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a snapshot.
         * @summary Retrieve a snapshot
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSnapshot', 'id', id);
            const localVarPath = `/core/snapshots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a list of snapshot, providing details such as snapshot name, timestamp, VM ID, and other relevant information.
         * @summary Retrieve list of snapshots with pagination
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Snapshot ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots: (page_1, pageSize_1, search_1, ...args_1) => __awaiter(this, [page_1, pageSize_1, search_1, ...args_1], void 0, function* (page, pageSize, search, options = {}) {
            const localVarPath = `/core/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Restore a snapshot.
         * @summary Restore a snapshot
         * @param {number} id
         * @param {SnapshotRestoreRequest} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSnapshotRestore: (id_1, payload_1, ...args_1) => __awaiter(this, [id_1, payload_1, ...args_1], void 0, function* (id, payload, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('postSnapshotRestore', 'id', id);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postSnapshotRestore', 'payload', payload);
            const localVarPath = `/core/snapshots/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SnapshotsApiAxiosParamCreator = SnapshotsApiAxiosParamCreator;
/**
 * SnapshotsApi - functional programming interface
 * @export
 */
const SnapshotsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SnapshotsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new custom image from an existing snapshot.Requires a name and any labels for your new custom image.
         * @summary Create an image from a snapshot
         * @param {number} snapshotId
         * @param {CreateImagePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createANewCustomImage(snapshotId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createANewCustomImage(snapshotId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SnapshotsApi.createANewCustomImage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a snapshot. Provide the snapshot ID in the path to delete the specified snapshot. If the snapshot is connected with an image, that image will also bedeleted and the deleted image ID will be returned in the success message response.
         * @summary Delete snapshot
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSnapshot(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SnapshotsApi.deleteSnapshot']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check if a Snapshot name is available
         * @summary Fetch snapshot name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSnapshotNameAvailability(name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchSnapshotNameAvailability(name, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SnapshotsApi.fetchSnapshotNameAvailability']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a snapshot.
         * @summary Retrieve a snapshot
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSnapshot(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SnapshotsApi.getSnapshot']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a list of snapshot, providing details such as snapshot name, timestamp, VM ID, and other relevant information.
         * @summary Retrieve list of snapshots with pagination
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Snapshot ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(page, pageSize, search, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSnapshots(page, pageSize, search, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SnapshotsApi.getSnapshots']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Restore a snapshot.
         * @summary Restore a snapshot
         * @param {number} id
         * @param {SnapshotRestoreRequest} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSnapshotRestore(id, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postSnapshotRestore(id, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SnapshotsApi.postSnapshotRestore']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.SnapshotsApiFp = SnapshotsApiFp;
/**
 * SnapshotsApi - factory interface
 * @export
 */
const SnapshotsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SnapshotsApiFp)(configuration);
    return {
        /**
         * Create a new custom image from an existing snapshot.Requires a name and any labels for your new custom image.
         * @summary Create an image from a snapshot
         * @param {number} snapshotId
         * @param {CreateImagePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createANewCustomImage(snapshotId, payload, options) {
            return localVarFp.createANewCustomImage(snapshotId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a snapshot. Provide the snapshot ID in the path to delete the specified snapshot. If the snapshot is connected with an image, that image will also bedeleted and the deleted image ID will be returned in the success message response.
         * @summary Delete snapshot
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(id, options) {
            return localVarFp.deleteSnapshot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Snapshot name is available
         * @summary Fetch snapshot name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSnapshotNameAvailability(name, options) {
            return localVarFp.fetchSnapshotNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a snapshot.
         * @summary Retrieve a snapshot
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot(id, options) {
            return localVarFp.getSnapshot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of snapshot, providing details such as snapshot name, timestamp, VM ID, and other relevant information.
         * @summary Retrieve list of snapshots with pagination
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Snapshot ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(page, pageSize, search, options) {
            return localVarFp.getSnapshots(page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a snapshot.
         * @summary Restore a snapshot
         * @param {number} id
         * @param {SnapshotRestoreRequest} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSnapshotRestore(id, payload, options) {
            return localVarFp.postSnapshotRestore(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SnapshotsApiFactory = SnapshotsApiFactory;
/**
 * SnapshotsApi - object-oriented interface
 * @export
 * @class SnapshotsApi
 * @extends {BaseAPI}
 */
class SnapshotsApi extends base_1.BaseAPI {
    /**
     * Create a new custom image from an existing snapshot.Requires a name and any labels for your new custom image.
     * @summary Create an image from a snapshot
     * @param {number} snapshotId
     * @param {CreateImagePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    createANewCustomImage(snapshotId, payload, options) {
        return (0, exports.SnapshotsApiFp)(this.configuration).createANewCustomImage(snapshotId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a snapshot. Provide the snapshot ID in the path to delete the specified snapshot. If the snapshot is connected with an image, that image will also bedeleted and the deleted image ID will be returned in the success message response.
     * @summary Delete snapshot
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    deleteSnapshot(id, options) {
        return (0, exports.SnapshotsApiFp)(this.configuration).deleteSnapshot(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if a Snapshot name is available
     * @summary Fetch snapshot name availability
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    fetchSnapshotNameAvailability(name, options) {
        return (0, exports.SnapshotsApiFp)(this.configuration).fetchSnapshotNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a snapshot.
     * @summary Retrieve a snapshot
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    getSnapshot(id, options) {
        return (0, exports.SnapshotsApiFp)(this.configuration).getSnapshot(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of snapshot, providing details such as snapshot name, timestamp, VM ID, and other relevant information.
     * @summary Retrieve list of snapshots with pagination
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search] Search By Snapshot ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    getSnapshots(page, pageSize, search, options) {
        return (0, exports.SnapshotsApiFp)(this.configuration).getSnapshots(page, pageSize, search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restore a snapshot.
     * @summary Restore a snapshot
     * @param {number} id
     * @param {SnapshotRestoreRequest} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    postSnapshotRestore(id, payload, options) {
        return (0, exports.SnapshotsApiFp)(this.configuration).postSnapshotRestore(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SnapshotsApi = SnapshotsApi;
/**
 * StockApi - axios parameter creator
 * @export
 */
const StockApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns information on current and upcoming GPU availability, organized byregion and GPU model. For additional information on GPU stocks,[**click here**](https://docs.hyperstack.cloud/docs/hardware/gpu-stock-information).
         * @summary Retrieve GPU stocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGPUStocks: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.StockApiAxiosParamCreator = StockApiAxiosParamCreator;
/**
 * StockApi - functional programming interface
 * @export
 */
const StockApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.StockApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns information on current and upcoming GPU availability, organized byregion and GPU model. For additional information on GPU stocks,[**click here**](https://docs.hyperstack.cloud/docs/hardware/gpu-stock-information).
         * @summary Retrieve GPU stocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGPUStocks(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveGPUStocks(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['StockApi.retrieveGPUStocks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.StockApiFp = StockApiFp;
/**
 * StockApi - factory interface
 * @export
 */
const StockApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.StockApiFp)(configuration);
    return {
        /**
         * Returns information on current and upcoming GPU availability, organized byregion and GPU model. For additional information on GPU stocks,[**click here**](https://docs.hyperstack.cloud/docs/hardware/gpu-stock-information).
         * @summary Retrieve GPU stocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGPUStocks(options) {
            return localVarFp.retrieveGPUStocks(options).then((request) => request(axios, basePath));
        },
    };
};
exports.StockApiFactory = StockApiFactory;
/**
 * StockApi - object-oriented interface
 * @export
 * @class StockApi
 * @extends {BaseAPI}
 */
class StockApi extends base_1.BaseAPI {
    /**
     * Returns information on current and upcoming GPU availability, organized byregion and GPU model. For additional information on GPU stocks,[**click here**](https://docs.hyperstack.cloud/docs/hardware/gpu-stock-information).
     * @summary Retrieve GPU stocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    retrieveGPUStocks(options) {
        return (0, exports.StockApiFp)(this.configuration).retrieveGPUStocks(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StockApi = StockApi;
/**
 * TemplateApi - axios parameter creator
 * @export
 */
const TemplateApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a resource template for deployment.
         * @summary Create template
         * @param {File} content YAML file is required
         * @param {string} description description is required
         * @param {string} isPublic is_public is required
         * @param {string} name name is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: (content_1, description_1, isPublic_1, name_1, ...args_1) => __awaiter(this, [content_1, description_1, isPublic_1, name_1, ...args_1], void 0, function* (content, description, isPublic, name, options = {}) {
            // verify required parameter 'content' is not null or undefined
            (0, common_1.assertParamExists)('createTemplate', 'content', content);
            // verify required parameter 'description' is not null or undefined
            (0, common_1.assertParamExists)('createTemplate', 'description', description);
            // verify required parameter 'isPublic' is not null or undefined
            (0, common_1.assertParamExists)('createTemplate', 'isPublic', isPublic);
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('createTemplate', 'name', name);
            const localVarPath = `/core/marketplace/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (content !== undefined) {
                localVarFormParams.append('content', content);
            }
            if (description !== undefined) {
                localVarFormParams.append('description', description);
            }
            if (isPublic !== undefined) {
                localVarFormParams.append('is_public', isPublic);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Permanently deletes a template. Supply the template ID in the path to delete the specified template.
         * @summary Delete template
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteTemplate', 'id', id);
            const localVarPath = `/core/marketplace/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a comprehensive list of templates, providing resource configuration details for each. Optionally, specify the `visibility` as `public` or `private` to retrieve templates with the desired visibility status. To learn more about the templates feature, [**click here**](https://docs.hyperstack.cloud/docs/features/templates#view-a-list-of-templates).
         * @summary List templates
         * @param {string} [visibility] Specify the &#x60;visibility&#x60; status as either &#x60;public&#x60; or &#x60;private&#x60; to filter and retrieve templates with the desired visibility.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates: (visibility_1, ...args_1) => __awaiter(this, [visibility_1, ...args_1], void 0, function* (visibility, options = {}) {
            const localVarPath = `/core/marketplace/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (visibility !== undefined) {
                localVarQueryParameter['visibility'] = visibility;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the resource configuration details for a specified template.Provide the template ID in the path to retrieve details for the specified template.For additional information on template configuration details,[**click here**](https://docs.hyperstack.cloud/docs/api-references/).
         * @summary Retrieve template details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTemplateDetails: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('retrieveTemplateDetails', 'id', id);
            const localVarPath = `/core/marketplace/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the details of a template. Modify the template name, description and/or`is_public` status to change the public/private visibility of the template.
         * @summary Update template
         * @param {number} id
         * @param {UpdateTemplate} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: (id_1, payload_1, ...args_1) => __awaiter(this, [id_1, payload_1, ...args_1], void 0, function* (id, payload, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateTemplate', 'id', id);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateTemplate', 'payload', payload);
            const localVarPath = `/core/marketplace/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TemplateApiAxiosParamCreator = TemplateApiAxiosParamCreator;
/**
 * TemplateApi - functional programming interface
 * @export
 */
const TemplateApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TemplateApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a resource template for deployment.
         * @summary Create template
         * @param {File} content YAML file is required
         * @param {string} description description is required
         * @param {string} isPublic is_public is required
         * @param {string} name name is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(content, description, isPublic, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTemplate(content, description, isPublic, name, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TemplateApi.createTemplate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Permanently deletes a template. Supply the template ID in the path to delete the specified template.
         * @summary Delete template
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTemplate(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TemplateApi.deleteTemplate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a comprehensive list of templates, providing resource configuration details for each. Optionally, specify the `visibility` as `public` or `private` to retrieve templates with the desired visibility status. To learn more about the templates feature, [**click here**](https://docs.hyperstack.cloud/docs/features/templates#view-a-list-of-templates).
         * @summary List templates
         * @param {string} [visibility] Specify the &#x60;visibility&#x60; status as either &#x60;public&#x60; or &#x60;private&#x60; to filter and retrieve templates with the desired visibility.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(visibility, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTemplates(visibility, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TemplateApi.listTemplates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the resource configuration details for a specified template.Provide the template ID in the path to retrieve details for the specified template.For additional information on template configuration details,[**click here**](https://docs.hyperstack.cloud/docs/api-references/).
         * @summary Retrieve template details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTemplateDetails(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveTemplateDetails(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TemplateApi.retrieveTemplateDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the details of a template. Modify the template name, description and/or`is_public` status to change the public/private visibility of the template.
         * @summary Update template
         * @param {number} id
         * @param {UpdateTemplate} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(id, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTemplate(id, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TemplateApi.updateTemplate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.TemplateApiFp = TemplateApiFp;
/**
 * TemplateApi - factory interface
 * @export
 */
const TemplateApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TemplateApiFp)(configuration);
    return {
        /**
         * Creates a resource template for deployment.
         * @summary Create template
         * @param {File} content YAML file is required
         * @param {string} description description is required
         * @param {string} isPublic is_public is required
         * @param {string} name name is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(content, description, isPublic, name, options) {
            return localVarFp.createTemplate(content, description, isPublic, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a template. Supply the template ID in the path to delete the specified template.
         * @summary Delete template
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(id, options) {
            return localVarFp.deleteTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a comprehensive list of templates, providing resource configuration details for each. Optionally, specify the `visibility` as `public` or `private` to retrieve templates with the desired visibility status. To learn more about the templates feature, [**click here**](https://docs.hyperstack.cloud/docs/features/templates#view-a-list-of-templates).
         * @summary List templates
         * @param {string} [visibility] Specify the &#x60;visibility&#x60; status as either &#x60;public&#x60; or &#x60;private&#x60; to filter and retrieve templates with the desired visibility.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(visibility, options) {
            return localVarFp.listTemplates(visibility, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the resource configuration details for a specified template.Provide the template ID in the path to retrieve details for the specified template.For additional information on template configuration details,[**click here**](https://docs.hyperstack.cloud/docs/api-references/).
         * @summary Retrieve template details
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTemplateDetails(id, options) {
            return localVarFp.retrieveTemplateDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of a template. Modify the template name, description and/or`is_public` status to change the public/private visibility of the template.
         * @summary Update template
         * @param {number} id
         * @param {UpdateTemplate} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(id, payload, options) {
            return localVarFp.updateTemplate(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TemplateApiFactory = TemplateApiFactory;
/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
class TemplateApi extends base_1.BaseAPI {
    /**
     * Creates a resource template for deployment.
     * @summary Create template
     * @param {File} content YAML file is required
     * @param {string} description description is required
     * @param {string} isPublic is_public is required
     * @param {string} name name is required
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    createTemplate(content, description, isPublic, name, options) {
        return (0, exports.TemplateApiFp)(this.configuration).createTemplate(content, description, isPublic, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Permanently deletes a template. Supply the template ID in the path to delete the specified template.
     * @summary Delete template
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    deleteTemplate(id, options) {
        return (0, exports.TemplateApiFp)(this.configuration).deleteTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a comprehensive list of templates, providing resource configuration details for each. Optionally, specify the `visibility` as `public` or `private` to retrieve templates with the desired visibility status. To learn more about the templates feature, [**click here**](https://docs.hyperstack.cloud/docs/features/templates#view-a-list-of-templates).
     * @summary List templates
     * @param {string} [visibility] Specify the &#x60;visibility&#x60; status as either &#x60;public&#x60; or &#x60;private&#x60; to filter and retrieve templates with the desired visibility.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    listTemplates(visibility, options) {
        return (0, exports.TemplateApiFp)(this.configuration).listTemplates(visibility, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the resource configuration details for a specified template.Provide the template ID in the path to retrieve details for the specified template.For additional information on template configuration details,[**click here**](https://docs.hyperstack.cloud/docs/api-references/).
     * @summary Retrieve template details
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    retrieveTemplateDetails(id, options) {
        return (0, exports.TemplateApiFp)(this.configuration).retrieveTemplateDetails(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the details of a template. Modify the template name, description and/or`is_public` status to change the public/private visibility of the template.
     * @summary Update template
     * @param {number} id
     * @param {UpdateTemplate} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    updateTemplate(id, payload, options) {
        return (0, exports.TemplateApiFp)(this.configuration).updateTemplate(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TemplateApi = TemplateApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the billing details associated with your organization.
         * @summary GET: Retrieve billing info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/billing/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add billing details associated with your organization in the request body.
         * @summary POST: Insert billing info
         * @param {UserInfoPostPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postUser', 'payload', payload);
            const localVarPath = `/billing/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the billing information for your organization in the request body.
         * @summary PUT: Update billing info
         * @param {UserInfoPostPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUser: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('putUser', 'payload', payload);
            const localVarPath = `/billing/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve the billing details associated with your organization.
         * @summary GET: Retrieve billing info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUser(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.getUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Add billing details associated with your organization in the request body.
         * @summary POST: Insert billing info
         * @param {UserInfoPostPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postUser(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.postUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update the billing information for your organization in the request body.
         * @summary PUT: Update billing info
         * @param {UserInfoPostPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUser(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.putUser(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.putUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserApiFp)(configuration);
    return {
        /**
         * Retrieve the billing details associated with your organization.
         * @summary GET: Retrieve billing info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Add billing details associated with your organization in the request body.
         * @summary POST: Insert billing info
         * @param {UserInfoPostPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(payload, options) {
            return localVarFp.postUser(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the billing information for your organization in the request body.
         * @summary PUT: Update billing info
         * @param {UserInfoPostPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUser(payload, options) {
            return localVarFp.putUser(payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * Retrieve the billing details associated with your organization.
     * @summary GET: Retrieve billing info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(options) {
        return (0, exports.UserApiFp)(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add billing details associated with your organization in the request body.
     * @summary POST: Insert billing info
     * @param {UserInfoPostPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    postUser(payload, options) {
        return (0, exports.UserApiFp)(this.configuration).postUser(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the billing information for your organization in the request body.
     * @summary PUT: Update billing info
     * @param {UserInfoPostPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    putUser(payload, options) {
        return (0, exports.UserApiFp)(this.configuration).putUser(payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserApi = UserApi;
/**
 * UserDetailChoiceApi - axios parameter creator
 * @export
 */
const UserDetailChoiceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the default choices for virtual machine deployment, including the default region, flavor, and image.
         * @summary Retrieve Default Flavors and Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDefaultFlavorsAndImages: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/user/resources/defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserDetailChoiceApiAxiosParamCreator = UserDetailChoiceApiAxiosParamCreator;
/**
 * UserDetailChoiceApi - functional programming interface
 * @export
 */
const UserDetailChoiceApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserDetailChoiceApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve the default choices for virtual machine deployment, including the default region, flavor, and image.
         * @summary Retrieve Default Flavors and Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDefaultFlavorsAndImages(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveDefaultFlavorsAndImages(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserDetailChoiceApi.retrieveDefaultFlavorsAndImages']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.UserDetailChoiceApiFp = UserDetailChoiceApiFp;
/**
 * UserDetailChoiceApi - factory interface
 * @export
 */
const UserDetailChoiceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserDetailChoiceApiFp)(configuration);
    return {
        /**
         * Retrieve the default choices for virtual machine deployment, including the default region, flavor, and image.
         * @summary Retrieve Default Flavors and Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDefaultFlavorsAndImages(options) {
            return localVarFp.retrieveDefaultFlavorsAndImages(options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserDetailChoiceApiFactory = UserDetailChoiceApiFactory;
/**
 * UserDetailChoiceApi - object-oriented interface
 * @export
 * @class UserDetailChoiceApi
 * @extends {BaseAPI}
 */
class UserDetailChoiceApi extends base_1.BaseAPI {
    /**
     * Retrieve the default choices for virtual machine deployment, including the default region, flavor, and image.
     * @summary Retrieve Default Flavors and Images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDetailChoiceApi
     */
    retrieveDefaultFlavorsAndImages(options) {
        return (0, exports.UserDetailChoiceApiFp)(this.configuration).retrieveDefaultFlavorsAndImages(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserDetailChoiceApi = UserDetailChoiceApi;
/**
 * UserPermissionApi - axios parameter creator
 * @export
 */
const UserPermissionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of permissions granted to your account. For additional information on your permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-my-permissions).
         * @summary List My User Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserPermissions: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/users/me/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a list of permissions granted to a specific user within your organization. Provide the ID of the user in the path. For additional information on user permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-user-permissions).
         * @summary List User Permissions
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPermissions: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listUserPermissions', 'id', id);
            const localVarPath = `/auth/users/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserPermissionApiAxiosParamCreator = UserPermissionApiAxiosParamCreator;
/**
 * UserPermissionApi - functional programming interface
 * @export
 */
const UserPermissionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserPermissionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of permissions granted to your account. For additional information on your permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-my-permissions).
         * @summary List My User Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserPermissions(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listMyUserPermissions(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserPermissionApi.listMyUserPermissions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a list of permissions granted to a specific user within your organization. Provide the ID of the user in the path. For additional information on user permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-user-permissions).
         * @summary List User Permissions
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPermissions(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUserPermissions(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserPermissionApi.listUserPermissions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.UserPermissionApiFp = UserPermissionApiFp;
/**
 * UserPermissionApi - factory interface
 * @export
 */
const UserPermissionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserPermissionApiFp)(configuration);
    return {
        /**
         * Retrieves a list of permissions granted to your account. For additional information on your permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-my-permissions).
         * @summary List My User Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserPermissions(options) {
            return localVarFp.listMyUserPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of permissions granted to a specific user within your organization. Provide the ID of the user in the path. For additional information on user permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-user-permissions).
         * @summary List User Permissions
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPermissions(id, options) {
            return localVarFp.listUserPermissions(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserPermissionApiFactory = UserPermissionApiFactory;
/**
 * UserPermissionApi - object-oriented interface
 * @export
 * @class UserPermissionApi
 * @extends {BaseAPI}
 */
class UserPermissionApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of permissions granted to your account. For additional information on your permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-my-permissions).
     * @summary List My User Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPermissionApi
     */
    listMyUserPermissions(options) {
        return (0, exports.UserPermissionApiFp)(this.configuration).listMyUserPermissions(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of permissions granted to a specific user within your organization. Provide the ID of the user in the path. For additional information on user permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-user-permissions).
     * @summary List User Permissions
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPermissionApi
     */
    listUserPermissions(id, options) {
        return (0, exports.UserPermissionApiFp)(this.configuration).listUserPermissions(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserPermissionApi = UserPermissionApi;
/**
 * VirtualMachineApi - axios parameter creator
 * @export
 */
const VirtualMachineApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Permanently deletes a virtual machine. Provide the virtual machine ID in the path to delete the specified virtual machine.
         * @summary Delete virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstance: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('deleteInstance', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a firewall rule associated with a virtual machine. Provide the virtual machine ID and the firewall rule ID in the path to remove the specified rule from the specified virtual machine.
         * @summary Delete firewall rule from virtual machine
         * @param {number} vmId
         * @param {number} sgRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecurityRule: (vmId_1, sgRuleId_1, ...args_1) => __awaiter(this, [vmId_1, sgRuleId_1, ...args_1], void 0, function* (vmId, sgRuleId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('deleteSecurityRule', 'vmId', vmId);
            // verify required parameter 'sgRuleId' is not null or undefined
            (0, common_1.assertParamExists)('deleteSecurityRule', 'sgRuleId', sgRuleId);
            const localVarPath = `/core/virtual-machines/{vm_id}/sg-rules/{sg_rule_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"sg_rule_id"}}`, encodeURIComponent(String(sgRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if a Virtual Machine name is available
         * @summary Fetch virtual machine name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVirtualMachineNameAvailability: (name_1, ...args_1) => __awaiter(this, [name_1, ...args_1], void 0, function* (name, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('fetchVirtualMachineNameAvailability', 'name', name);
            const localVarPath = `/core/virtual-machines/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a list of virtual machines associated with a contract, providing details such as virtual machine name, timestamp, flavor name, and other relevant information. Please provide the ID of the relevant contract in the path.
         * @summary Retrieve virtual machines associated with a contract
         * @param {number} contractId
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Instance ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractInstances: (contractId_1, page_1, pageSize_1, search_1, ...args_1) => __awaiter(this, [contractId_1, page_1, pageSize_1, search_1, ...args_1], void 0, function* (contractId, page, pageSize, search, options = {}) {
            // verify required parameter 'contractId' is not null or undefined
            (0, common_1.assertParamExists)('getContractInstances', 'contractId', contractId);
            const localVarPath = `/core/virtual-machines/contract/{contract_id}/virtual-machines`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of your existing virtual machines, providing configuration details for each. The list is sorted by creation date, with the oldest virtual machines displayed first.
         * @summary List virtual machines
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [search]
         * @param {string} [environment]
         * @param {Array<number>} [excludeFirewalls] Comma-separated list of Security Group IDs to ignore instances attached
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance: (page_1, pageSize_1, search_1, environment_1, excludeFirewalls_1, ...args_1) => __awaiter(this, [page_1, pageSize_1, search_1, environment_1, excludeFirewalls_1, ...args_1], void 0, function* (page, pageSize, search, environment, excludeFirewalls, options = {}) {
            const localVarPath = `/core/virtual-machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }
            if (excludeFirewalls) {
                localVarQueryParameter['exclude_firewalls'] = excludeFirewalls;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the details of an existing virtual machine. Provide the virtual machine ID in the path, and Infrahub will return information about the corresponding VM.
         * @summary Retrieve virtual machine details
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance2: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getInstance2', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiates a hard reboot for a virtual machine, simulating the process of unplugging and rebooting a physical machine. Provide the virtual machine ID in the path to execute a hard reboot for the specified virtual machine.
         * @summary Hard reboot virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance3: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getInstance3', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/hard-reboot`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiates the startup of a virtual machine. Provide the virtual machine ID in the path to initiate the starting of the specified virtual machine.
         * @summary Start virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance4: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getInstance4', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/start`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Shuts down a virtual machine. Provide the virtual machine ID in the path to initiate the shutdown process for the specified virtual machine.
         * @summary Stop virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance5: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getInstance5', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/stop`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiates the hibernation of a virtual machine, saving its current state to disk before powering off. Provide the virtual machine ID in the path to specify the virtual machine to be hibernated.
         * @summary Hibernate virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceHibernate: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getInstanceHibernate', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/hibernate`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Resumes a virtual machine from hibernation, bringing it back to an active state. Provide the virtual machine ID in the path to specify the virtual machine to be restored from hibernation.
         * @summary Restore virtual machine from hibernation
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceHibernateRestore: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getInstanceHibernateRestore', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/hibernate-restore`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve console logs for a virtual machine
         * @summary Get virtual machine logs
         * @param {number} vmId
         * @param {number} requestId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceLogs: (vmId_1, requestId_1, ...args_1) => __awaiter(this, [vmId_1, requestId_1, ...args_1], void 0, function* (vmId, requestId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getInstanceLogs', 'vmId', vmId);
            // verify required parameter 'requestId' is not null or undefined
            (0, common_1.assertParamExists)('getInstanceLogs', 'requestId', requestId);
            const localVarPath = `/core/virtual-machines/{vm_id}/logs`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (requestId !== undefined) {
                localVarQueryParameter['request_id'] = requestId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves performance metrics data for a virtual machine. Provide the virtual machine ID in the path to retrieve the following data for the specified virtual machine: CPU usage, memory usage (RAM), `network.in`, `network.out`, `disk.read`, and `disk.write`. The optional `duration` parameter can be used to specify the period for retrieving performance metrics; the default value will retrieve all available data. To learn more about virtual machine performance metrics, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#performance-metrics).
         * @summary Retrieve virtual machine performance metrics
         * @param {number} vmId
         * @param {GetInstanceMetricsDurationEnum} [duration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceMetrics: (vmId_1, duration_1, ...args_1) => __awaiter(this, [vmId_1, duration_1, ...args_1], void 0, function* (vmId, duration, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getInstanceMetrics', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/metrics`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates one or more virtual machines with the specified custom configuration and features provided in the request body. For more information about the virtual machine features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/virtual-machine-features#create-a-virtual-machine-with-custom-features).
         * @summary Create virtual machines
         * @param {CreateInstancesPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstance: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postInstance', 'payload', payload);
            const localVarPath = `/core/virtual-machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Attach firewalls to a virtual machine by providing the virtual machine ID in the path and the IDs of the firewalls in the request body; any firewalls not included will be detached.
         * @summary Attach firewalls to a virtual machine
         * @param {number} vmId
         * @param {AttachFirewallsToVMPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstanceAttachFirewalls: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('postInstanceAttachFirewalls', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postInstanceAttachFirewalls', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/attach-firewalls`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Request console logs for a virtual machine
         * @summary Request virtual machine logs
         * @param {number} vmId
         * @param {RequestInstanceLogsPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstanceLogs: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('postInstanceLogs', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postInstanceLogs', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/logs`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the hardware configuration for an existing virtual machine. Include the virtual machine ID in the path and provide the new configuration, referred to as a `flavor`, in the body of the request. For additional information resizing, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#modify-the-flavor-of-an-existing-virtual-machine).
         * @summary Resize virtual machine
         * @param {number} vmId
         * @param {InstanceResizePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstanceResize: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('postInstanceResize', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postInstanceResize', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/resize`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a firewall rule for a virtual machine. Include the virtual machine ID in the path, and provide the firewall rule configuration in the request body, as detailed below. For additional information on firewall rules, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vm-firewall-rules/add-firewall-rule-to-vm).
         * @summary Add firewall rule to virtual machine
         * @param {number} vmId
         * @param {CreateSecurityRulePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSecurityRule: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('postSecurityRule', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postSecurityRule', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/sg-rules`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create snapshots of a virtual machine by providing the virtual machine ID in the path
         * @summary Create snapshot from a virtual machine
         * @param {number} vmId
         * @param {CreateSnapshotPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSnapshots: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('postSnapshots', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('postSnapshots', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/snapshots`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Adds one or more labels to an existing virtual machine. Provide the virtual machine ID in the path to add labels to the specified VM. For multiple labels, add a space between each label in the request body.
         * @summary Edit virtual machine labels
         * @param {number} vmId
         * @param {EditLabelOfAnExistingVMPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLabels: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('putLabels', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('putLabels', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/label`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.VirtualMachineApiAxiosParamCreator = VirtualMachineApiAxiosParamCreator;
/**
 * VirtualMachineApi - functional programming interface
 * @export
 */
const VirtualMachineApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.VirtualMachineApiAxiosParamCreator)(configuration);
    return {
        /**
         * Permanently deletes a virtual machine. Provide the virtual machine ID in the path to delete the specified virtual machine.
         * @summary Delete virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstance(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInstance(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.deleteInstance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a firewall rule associated with a virtual machine. Provide the virtual machine ID and the firewall rule ID in the path to remove the specified rule from the specified virtual machine.
         * @summary Delete firewall rule from virtual machine
         * @param {number} vmId
         * @param {number} sgRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecurityRule(vmId, sgRuleId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSecurityRule(vmId, sgRuleId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.deleteSecurityRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check if a Virtual Machine name is available
         * @summary Fetch virtual machine name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVirtualMachineNameAvailability(name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchVirtualMachineNameAvailability(name, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.fetchVirtualMachineNameAvailability']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a list of virtual machines associated with a contract, providing details such as virtual machine name, timestamp, flavor name, and other relevant information. Please provide the ID of the relevant contract in the path.
         * @summary Retrieve virtual machines associated with a contract
         * @param {number} contractId
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Instance ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractInstances(contractId, page, pageSize, search, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getContractInstances(contractId, page, pageSize, search, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getContractInstances']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a list of your existing virtual machines, providing configuration details for each. The list is sorted by creation date, with the oldest virtual machines displayed first.
         * @summary List virtual machines
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [search]
         * @param {string} [environment]
         * @param {Array<number>} [excludeFirewalls] Comma-separated list of Security Group IDs to ignore instances attached
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance(page, pageSize, search, environment, excludeFirewalls, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstance(page, pageSize, search, environment, excludeFirewalls, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getInstance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the details of an existing virtual machine. Provide the virtual machine ID in the path, and Infrahub will return information about the corresponding VM.
         * @summary Retrieve virtual machine details
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance2(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstance2(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getInstance2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Initiates a hard reboot for a virtual machine, simulating the process of unplugging and rebooting a physical machine. Provide the virtual machine ID in the path to execute a hard reboot for the specified virtual machine.
         * @summary Hard reboot virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance3(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstance3(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getInstance3']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Initiates the startup of a virtual machine. Provide the virtual machine ID in the path to initiate the starting of the specified virtual machine.
         * @summary Start virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance4(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstance4(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getInstance4']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Shuts down a virtual machine. Provide the virtual machine ID in the path to initiate the shutdown process for the specified virtual machine.
         * @summary Stop virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance5(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstance5(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getInstance5']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Initiates the hibernation of a virtual machine, saving its current state to disk before powering off. Provide the virtual machine ID in the path to specify the virtual machine to be hibernated.
         * @summary Hibernate virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceHibernate(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstanceHibernate(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getInstanceHibernate']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Resumes a virtual machine from hibernation, bringing it back to an active state. Provide the virtual machine ID in the path to specify the virtual machine to be restored from hibernation.
         * @summary Restore virtual machine from hibernation
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceHibernateRestore(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstanceHibernateRestore(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getInstanceHibernateRestore']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve console logs for a virtual machine
         * @summary Get virtual machine logs
         * @param {number} vmId
         * @param {number} requestId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceLogs(vmId, requestId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstanceLogs(vmId, requestId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getInstanceLogs']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves performance metrics data for a virtual machine. Provide the virtual machine ID in the path to retrieve the following data for the specified virtual machine: CPU usage, memory usage (RAM), `network.in`, `network.out`, `disk.read`, and `disk.write`. The optional `duration` parameter can be used to specify the period for retrieving performance metrics; the default value will retrieve all available data. To learn more about virtual machine performance metrics, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#performance-metrics).
         * @summary Retrieve virtual machine performance metrics
         * @param {number} vmId
         * @param {GetInstanceMetricsDurationEnum} [duration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceMetrics(vmId, duration, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInstanceMetrics(vmId, duration, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.getInstanceMetrics']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates one or more virtual machines with the specified custom configuration and features provided in the request body. For more information about the virtual machine features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/virtual-machine-features#create-a-virtual-machine-with-custom-features).
         * @summary Create virtual machines
         * @param {CreateInstancesPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstance(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postInstance(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.postInstance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Attach firewalls to a virtual machine by providing the virtual machine ID in the path and the IDs of the firewalls in the request body; any firewalls not included will be detached.
         * @summary Attach firewalls to a virtual machine
         * @param {number} vmId
         * @param {AttachFirewallsToVMPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstanceAttachFirewalls(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postInstanceAttachFirewalls(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.postInstanceAttachFirewalls']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Request console logs for a virtual machine
         * @summary Request virtual machine logs
         * @param {number} vmId
         * @param {RequestInstanceLogsPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstanceLogs(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postInstanceLogs(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.postInstanceLogs']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates the hardware configuration for an existing virtual machine. Include the virtual machine ID in the path and provide the new configuration, referred to as a `flavor`, in the body of the request. For additional information resizing, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#modify-the-flavor-of-an-existing-virtual-machine).
         * @summary Resize virtual machine
         * @param {number} vmId
         * @param {InstanceResizePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstanceResize(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postInstanceResize(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.postInstanceResize']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a firewall rule for a virtual machine. Include the virtual machine ID in the path, and provide the firewall rule configuration in the request body, as detailed below. For additional information on firewall rules, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vm-firewall-rules/add-firewall-rule-to-vm).
         * @summary Add firewall rule to virtual machine
         * @param {number} vmId
         * @param {CreateSecurityRulePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSecurityRule(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postSecurityRule(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.postSecurityRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create snapshots of a virtual machine by providing the virtual machine ID in the path
         * @summary Create snapshot from a virtual machine
         * @param {number} vmId
         * @param {CreateSnapshotPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSnapshots(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postSnapshots(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.postSnapshots']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Adds one or more labels to an existing virtual machine. Provide the virtual machine ID in the path to add labels to the specified VM. For multiple labels, add a space between each label in the request body.
         * @summary Edit virtual machine labels
         * @param {number} vmId
         * @param {EditLabelOfAnExistingVMPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLabels(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.putLabels(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineApi.putLabels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.VirtualMachineApiFp = VirtualMachineApiFp;
/**
 * VirtualMachineApi - factory interface
 * @export
 */
const VirtualMachineApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.VirtualMachineApiFp)(configuration);
    return {
        /**
         * Permanently deletes a virtual machine. Provide the virtual machine ID in the path to delete the specified virtual machine.
         * @summary Delete virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstance(vmId, options) {
            return localVarFp.deleteInstance(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a firewall rule associated with a virtual machine. Provide the virtual machine ID and the firewall rule ID in the path to remove the specified rule from the specified virtual machine.
         * @summary Delete firewall rule from virtual machine
         * @param {number} vmId
         * @param {number} sgRuleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecurityRule(vmId, sgRuleId, options) {
            return localVarFp.deleteSecurityRule(vmId, sgRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Virtual Machine name is available
         * @summary Fetch virtual machine name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVirtualMachineNameAvailability(name, options) {
            return localVarFp.fetchVirtualMachineNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of virtual machines associated with a contract, providing details such as virtual machine name, timestamp, flavor name, and other relevant information. Please provide the ID of the relevant contract in the path.
         * @summary Retrieve virtual machines associated with a contract
         * @param {number} contractId
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Instance ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractInstances(contractId, page, pageSize, search, options) {
            return localVarFp.getContractInstances(contractId, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your existing virtual machines, providing configuration details for each. The list is sorted by creation date, with the oldest virtual machines displayed first.
         * @summary List virtual machines
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [search]
         * @param {string} [environment]
         * @param {Array<number>} [excludeFirewalls] Comma-separated list of Security Group IDs to ignore instances attached
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance(page, pageSize, search, environment, excludeFirewalls, options) {
            return localVarFp.getInstance(page, pageSize, search, environment, excludeFirewalls, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing virtual machine. Provide the virtual machine ID in the path, and Infrahub will return information about the corresponding VM.
         * @summary Retrieve virtual machine details
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance2(vmId, options) {
            return localVarFp.getInstance2(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a hard reboot for a virtual machine, simulating the process of unplugging and rebooting a physical machine. Provide the virtual machine ID in the path to execute a hard reboot for the specified virtual machine.
         * @summary Hard reboot virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance3(vmId, options) {
            return localVarFp.getInstance3(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates the startup of a virtual machine. Provide the virtual machine ID in the path to initiate the starting of the specified virtual machine.
         * @summary Start virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance4(vmId, options) {
            return localVarFp.getInstance4(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Shuts down a virtual machine. Provide the virtual machine ID in the path to initiate the shutdown process for the specified virtual machine.
         * @summary Stop virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance5(vmId, options) {
            return localVarFp.getInstance5(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates the hibernation of a virtual machine, saving its current state to disk before powering off. Provide the virtual machine ID in the path to specify the virtual machine to be hibernated.
         * @summary Hibernate virtual machine
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceHibernate(vmId, options) {
            return localVarFp.getInstanceHibernate(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a virtual machine from hibernation, bringing it back to an active state. Provide the virtual machine ID in the path to specify the virtual machine to be restored from hibernation.
         * @summary Restore virtual machine from hibernation
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceHibernateRestore(vmId, options) {
            return localVarFp.getInstanceHibernateRestore(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve console logs for a virtual machine
         * @summary Get virtual machine logs
         * @param {number} vmId
         * @param {number} requestId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceLogs(vmId, requestId, options) {
            return localVarFp.getInstanceLogs(vmId, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves performance metrics data for a virtual machine. Provide the virtual machine ID in the path to retrieve the following data for the specified virtual machine: CPU usage, memory usage (RAM), `network.in`, `network.out`, `disk.read`, and `disk.write`. The optional `duration` parameter can be used to specify the period for retrieving performance metrics; the default value will retrieve all available data. To learn more about virtual machine performance metrics, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#performance-metrics).
         * @summary Retrieve virtual machine performance metrics
         * @param {number} vmId
         * @param {GetInstanceMetricsDurationEnum} [duration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceMetrics(vmId, duration, options) {
            return localVarFp.getInstanceMetrics(vmId, duration, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates one or more virtual machines with the specified custom configuration and features provided in the request body. For more information about the virtual machine features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/virtual-machine-features#create-a-virtual-machine-with-custom-features).
         * @summary Create virtual machines
         * @param {CreateInstancesPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstance(payload, options) {
            return localVarFp.postInstance(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach firewalls to a virtual machine by providing the virtual machine ID in the path and the IDs of the firewalls in the request body; any firewalls not included will be detached.
         * @summary Attach firewalls to a virtual machine
         * @param {number} vmId
         * @param {AttachFirewallsToVMPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstanceAttachFirewalls(vmId, payload, options) {
            return localVarFp.postInstanceAttachFirewalls(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Request console logs for a virtual machine
         * @summary Request virtual machine logs
         * @param {number} vmId
         * @param {RequestInstanceLogsPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstanceLogs(vmId, payload, options) {
            return localVarFp.postInstanceLogs(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the hardware configuration for an existing virtual machine. Include the virtual machine ID in the path and provide the new configuration, referred to as a `flavor`, in the body of the request. For additional information resizing, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#modify-the-flavor-of-an-existing-virtual-machine).
         * @summary Resize virtual machine
         * @param {number} vmId
         * @param {InstanceResizePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInstanceResize(vmId, payload, options) {
            return localVarFp.postInstanceResize(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a firewall rule for a virtual machine. Include the virtual machine ID in the path, and provide the firewall rule configuration in the request body, as detailed below. For additional information on firewall rules, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vm-firewall-rules/add-firewall-rule-to-vm).
         * @summary Add firewall rule to virtual machine
         * @param {number} vmId
         * @param {CreateSecurityRulePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSecurityRule(vmId, payload, options) {
            return localVarFp.postSecurityRule(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Create snapshots of a virtual machine by providing the virtual machine ID in the path
         * @summary Create snapshot from a virtual machine
         * @param {number} vmId
         * @param {CreateSnapshotPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSnapshots(vmId, payload, options) {
            return localVarFp.postSnapshots(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds one or more labels to an existing virtual machine. Provide the virtual machine ID in the path to add labels to the specified VM. For multiple labels, add a space between each label in the request body.
         * @summary Edit virtual machine labels
         * @param {number} vmId
         * @param {EditLabelOfAnExistingVMPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLabels(vmId, payload, options) {
            return localVarFp.putLabels(vmId, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.VirtualMachineApiFactory = VirtualMachineApiFactory;
/**
 * VirtualMachineApi - object-oriented interface
 * @export
 * @class VirtualMachineApi
 * @extends {BaseAPI}
 */
class VirtualMachineApi extends base_1.BaseAPI {
    /**
     * Permanently deletes a virtual machine. Provide the virtual machine ID in the path to delete the specified virtual machine.
     * @summary Delete virtual machine
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    deleteInstance(vmId, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).deleteInstance(vmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a firewall rule associated with a virtual machine. Provide the virtual machine ID and the firewall rule ID in the path to remove the specified rule from the specified virtual machine.
     * @summary Delete firewall rule from virtual machine
     * @param {number} vmId
     * @param {number} sgRuleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    deleteSecurityRule(vmId, sgRuleId, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).deleteSecurityRule(vmId, sgRuleId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if a Virtual Machine name is available
     * @summary Fetch virtual machine name availability
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    fetchVirtualMachineNameAvailability(name, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).fetchVirtualMachineNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of virtual machines associated with a contract, providing details such as virtual machine name, timestamp, flavor name, and other relevant information. Please provide the ID of the relevant contract in the path.
     * @summary Retrieve virtual machines associated with a contract
     * @param {number} contractId
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search] Search By Instance ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getContractInstances(contractId, page, pageSize, search, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getContractInstances(contractId, page, pageSize, search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of your existing virtual machines, providing configuration details for each. The list is sorted by creation date, with the oldest virtual machines displayed first.
     * @summary List virtual machines
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [search]
     * @param {string} [environment]
     * @param {Array<number>} [excludeFirewalls] Comma-separated list of Security Group IDs to ignore instances attached
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getInstance(page, pageSize, search, environment, excludeFirewalls, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getInstance(page, pageSize, search, environment, excludeFirewalls, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the details of an existing virtual machine. Provide the virtual machine ID in the path, and Infrahub will return information about the corresponding VM.
     * @summary Retrieve virtual machine details
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getInstance2(vmId, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getInstance2(vmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiates a hard reboot for a virtual machine, simulating the process of unplugging and rebooting a physical machine. Provide the virtual machine ID in the path to execute a hard reboot for the specified virtual machine.
     * @summary Hard reboot virtual machine
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getInstance3(vmId, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getInstance3(vmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiates the startup of a virtual machine. Provide the virtual machine ID in the path to initiate the starting of the specified virtual machine.
     * @summary Start virtual machine
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getInstance4(vmId, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getInstance4(vmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Shuts down a virtual machine. Provide the virtual machine ID in the path to initiate the shutdown process for the specified virtual machine.
     * @summary Stop virtual machine
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getInstance5(vmId, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getInstance5(vmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiates the hibernation of a virtual machine, saving its current state to disk before powering off. Provide the virtual machine ID in the path to specify the virtual machine to be hibernated.
     * @summary Hibernate virtual machine
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getInstanceHibernate(vmId, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getInstanceHibernate(vmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resumes a virtual machine from hibernation, bringing it back to an active state. Provide the virtual machine ID in the path to specify the virtual machine to be restored from hibernation.
     * @summary Restore virtual machine from hibernation
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getInstanceHibernateRestore(vmId, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getInstanceHibernateRestore(vmId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve console logs for a virtual machine
     * @summary Get virtual machine logs
     * @param {number} vmId
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getInstanceLogs(vmId, requestId, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getInstanceLogs(vmId, requestId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves performance metrics data for a virtual machine. Provide the virtual machine ID in the path to retrieve the following data for the specified virtual machine: CPU usage, memory usage (RAM), `network.in`, `network.out`, `disk.read`, and `disk.write`. The optional `duration` parameter can be used to specify the period for retrieving performance metrics; the default value will retrieve all available data. To learn more about virtual machine performance metrics, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#performance-metrics).
     * @summary Retrieve virtual machine performance metrics
     * @param {number} vmId
     * @param {GetInstanceMetricsDurationEnum} [duration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    getInstanceMetrics(vmId, duration, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).getInstanceMetrics(vmId, duration, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates one or more virtual machines with the specified custom configuration and features provided in the request body. For more information about the virtual machine features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/virtual-machine-features#create-a-virtual-machine-with-custom-features).
     * @summary Create virtual machines
     * @param {CreateInstancesPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    postInstance(payload, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).postInstance(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attach firewalls to a virtual machine by providing the virtual machine ID in the path and the IDs of the firewalls in the request body; any firewalls not included will be detached.
     * @summary Attach firewalls to a virtual machine
     * @param {number} vmId
     * @param {AttachFirewallsToVMPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    postInstanceAttachFirewalls(vmId, payload, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).postInstanceAttachFirewalls(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request console logs for a virtual machine
     * @summary Request virtual machine logs
     * @param {number} vmId
     * @param {RequestInstanceLogsPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    postInstanceLogs(vmId, payload, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).postInstanceLogs(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the hardware configuration for an existing virtual machine. Include the virtual machine ID in the path and provide the new configuration, referred to as a `flavor`, in the body of the request. For additional information resizing, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#modify-the-flavor-of-an-existing-virtual-machine).
     * @summary Resize virtual machine
     * @param {number} vmId
     * @param {InstanceResizePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    postInstanceResize(vmId, payload, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).postInstanceResize(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a firewall rule for a virtual machine. Include the virtual machine ID in the path, and provide the firewall rule configuration in the request body, as detailed below. For additional information on firewall rules, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vm-firewall-rules/add-firewall-rule-to-vm).
     * @summary Add firewall rule to virtual machine
     * @param {number} vmId
     * @param {CreateSecurityRulePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    postSecurityRule(vmId, payload, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).postSecurityRule(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create snapshots of a virtual machine by providing the virtual machine ID in the path
     * @summary Create snapshot from a virtual machine
     * @param {number} vmId
     * @param {CreateSnapshotPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    postSnapshots(vmId, payload, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).postSnapshots(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds one or more labels to an existing virtual machine. Provide the virtual machine ID in the path to add labels to the specified VM. For multiple labels, add a space between each label in the request body.
     * @summary Edit virtual machine labels
     * @param {number} vmId
     * @param {EditLabelOfAnExistingVMPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    putLabels(vmId, payload, options) {
        return (0, exports.VirtualMachineApiFp)(this.configuration).putLabels(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VirtualMachineApi = VirtualMachineApi;
/**
 * @export
 */
exports.GetInstanceMetricsDurationEnum = {
    _1h: '1h',
    _2h: '2h',
    _4h: '4h',
    _6h: '6h',
    _12h: '12h',
    _1d: '1d',
    _3d: '3d',
    _7d: '7d',
    _15d: '15d',
    _30d: '30d'
};
/**
 * VirtualMachineEventsApi - axios parameter creator
 * @export
 */
const VirtualMachineEventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all events in a virtual machine\'s history, which records actions performed on the specified virtual machine. Include the virtual machine ID in the path to retrieve the history of events. For more details on virtual machine events history, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#events-history).
         * @summary List virtual machine events
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualMachineEvents: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('listVirtualMachineEvents', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/events`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.VirtualMachineEventsApiAxiosParamCreator = VirtualMachineEventsApiAxiosParamCreator;
/**
 * VirtualMachineEventsApi - functional programming interface
 * @export
 */
const VirtualMachineEventsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.VirtualMachineEventsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of all events in a virtual machine\'s history, which records actions performed on the specified virtual machine. Include the virtual machine ID in the path to retrieve the history of events. For more details on virtual machine events history, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#events-history).
         * @summary List virtual machine events
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualMachineEvents(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listVirtualMachineEvents(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VirtualMachineEventsApi.listVirtualMachineEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.VirtualMachineEventsApiFp = VirtualMachineEventsApiFp;
/**
 * VirtualMachineEventsApi - factory interface
 * @export
 */
const VirtualMachineEventsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.VirtualMachineEventsApiFp)(configuration);
    return {
        /**
         * Retrieves a list of all events in a virtual machine\'s history, which records actions performed on the specified virtual machine. Include the virtual machine ID in the path to retrieve the history of events. For more details on virtual machine events history, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#events-history).
         * @summary List virtual machine events
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualMachineEvents(vmId, options) {
            return localVarFp.listVirtualMachineEvents(vmId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.VirtualMachineEventsApiFactory = VirtualMachineEventsApiFactory;
/**
 * VirtualMachineEventsApi - object-oriented interface
 * @export
 * @class VirtualMachineEventsApi
 * @extends {BaseAPI}
 */
class VirtualMachineEventsApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of all events in a virtual machine\'s history, which records actions performed on the specified virtual machine. Include the virtual machine ID in the path to retrieve the history of events. For more details on virtual machine events history, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#events-history).
     * @summary List virtual machine events
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineEventsApi
     */
    listVirtualMachineEvents(vmId, options) {
        return (0, exports.VirtualMachineEventsApiFp)(this.configuration).listVirtualMachineEvents(vmId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VirtualMachineEventsApi = VirtualMachineEventsApi;
/**
 * VncUrlApi - axios parameter creator
 * @export
 */
const VncUrlApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the URL to access the VNC console for a specified virtual machine by providing the virtual machine ID and the job ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-vnc-url).
         * @summary Get VNC Console Link
         * @param {number} vmId
         * @param {number} jobId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVncUrl: (vmId_1, jobId_1, ...args_1) => __awaiter(this, [vmId_1, jobId_1, ...args_1], void 0, function* (vmId, jobId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getVncUrl', 'vmId', vmId);
            // verify required parameter 'jobId' is not null or undefined
            (0, common_1.assertParamExists)('getVncUrl', 'jobId', jobId);
            const localVarPath = `/core/virtual-machines/{vm_id}/console/{job_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the path of the VNC console for the given virtual machine ID by providing the virtual machine ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-console-path).
         * @summary Request Instance Console
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVncUrl2: (vmId_1, ...args_1) => __awaiter(this, [vmId_1, ...args_1], void 0, function* (vmId, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('getVncUrl2', 'vmId', vmId);
            const localVarPath = `/core/virtual-machines/{vm_id}/request-console`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.VncUrlApiAxiosParamCreator = VncUrlApiAxiosParamCreator;
/**
 * VncUrlApi - functional programming interface
 * @export
 */
const VncUrlApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.VncUrlApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves the URL to access the VNC console for a specified virtual machine by providing the virtual machine ID and the job ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-vnc-url).
         * @summary Get VNC Console Link
         * @param {number} vmId
         * @param {number} jobId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVncUrl(vmId, jobId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVncUrl(vmId, jobId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VncUrlApi.getVncUrl']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the path of the VNC console for the given virtual machine ID by providing the virtual machine ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-console-path).
         * @summary Request Instance Console
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVncUrl2(vmId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVncUrl2(vmId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VncUrlApi.getVncUrl2']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.VncUrlApiFp = VncUrlApiFp;
/**
 * VncUrlApi - factory interface
 * @export
 */
const VncUrlApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.VncUrlApiFp)(configuration);
    return {
        /**
         * Retrieves the URL to access the VNC console for a specified virtual machine by providing the virtual machine ID and the job ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-vnc-url).
         * @summary Get VNC Console Link
         * @param {number} vmId
         * @param {number} jobId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVncUrl(vmId, jobId, options) {
            return localVarFp.getVncUrl(vmId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the path of the VNC console for the given virtual machine ID by providing the virtual machine ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-console-path).
         * @summary Request Instance Console
         * @param {number} vmId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVncUrl2(vmId, options) {
            return localVarFp.getVncUrl2(vmId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.VncUrlApiFactory = VncUrlApiFactory;
/**
 * VncUrlApi - object-oriented interface
 * @export
 * @class VncUrlApi
 * @extends {BaseAPI}
 */
class VncUrlApi extends base_1.BaseAPI {
    /**
     * Retrieves the URL to access the VNC console for a specified virtual machine by providing the virtual machine ID and the job ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-vnc-url).
     * @summary Get VNC Console Link
     * @param {number} vmId
     * @param {number} jobId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VncUrlApi
     */
    getVncUrl(vmId, jobId, options) {
        return (0, exports.VncUrlApiFp)(this.configuration).getVncUrl(vmId, jobId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the path of the VNC console for the given virtual machine ID by providing the virtual machine ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-console-path).
     * @summary Request Instance Console
     * @param {number} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VncUrlApi
     */
    getVncUrl2(vmId, options) {
        return (0, exports.VncUrlApiFp)(this.configuration).getVncUrl2(vmId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VncUrlApi = VncUrlApi;
/**
 * VolumeApi - axios parameter creator
 * @export
 */
const VolumeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a volume that can be attached to a virtual machine, expanding its storage capacity. Specify the volume type and custom configuration in the request body. For additional details on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/create-volume).
         * @summary Create volume
         * @param {CreateVolumePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume: (payload_1, ...args_1) => __awaiter(this, [payload_1, ...args_1], void 0, function* (payload, options = {}) {
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('createVolume', 'payload', payload);
            const localVarPath = `/core/volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a volume permanently. Provide the volume ID in the path to specify the volume to be deleted.
         * @summary Delete volume
         * @param {number} volumeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolume: (volumeId_1, ...args_1) => __awaiter(this, [volumeId_1, ...args_1], void 0, function* (volumeId, options = {}) {
            // verify required parameter 'volumeId' is not null or undefined
            (0, common_1.assertParamExists)('deleteVolume', 'volumeId', volumeId);
            const localVarPath = `/core/volumes/{volume_id}`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch volume details for specific volume. This endpoint returns id, name, volume size, volume type, status, description, image_id, os_image, created_at, updated_at etc.
         * @summary Fetch Volume Details
         * @param {number} volumeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVolumeDetails: (volumeId_1, ...args_1) => __awaiter(this, [volumeId_1, ...args_1], void 0, function* (volumeId, options = {}) {
            // verify required parameter 'volumeId' is not null or undefined
            (0, common_1.assertParamExists)('fetchVolumeDetails', 'volumeId', volumeId);
            const localVarPath = `/core/volumes/{volume_id}`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if a Volume name is available
         * @summary Fetch volume name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVolumeNameAvailability: (name_1, ...args_1) => __awaiter(this, [name_1, ...args_1], void 0, function* (name, options = {}) {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('fetchVolumeNameAvailability', 'name', name);
            const localVarPath = `/core/volume/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a list of available volume types that can be used in the creation of a new volume.
         * @summary List volume types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/core/volume-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of your existing volumes, providing details for each. For more information on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/).
         * @summary List volumes
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search]
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes: (page_1, pageSize_1, search_1, environment_1, ...args_1) => __awaiter(this, [page_1, pageSize_1, search_1, environment_1, ...args_1], void 0, function* (page, pageSize, search, environment, options = {}) {
            const localVarPath = `/core/volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update volume properties. Currently supports updating the environment by providing \'environment_name\'. The volume must not be attached to any instance when changing environments, and the target environment must be in the same region.
         * @summary Update volume fields
         * @param {number} volumeId
         * @param {UpdateVolumePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolume: (volumeId_1, payload_1, ...args_1) => __awaiter(this, [volumeId_1, payload_1, ...args_1], void 0, function* (volumeId, payload, options = {}) {
            // verify required parameter 'volumeId' is not null or undefined
            (0, common_1.assertParamExists)('updateVolume', 'volumeId', volumeId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateVolume', 'payload', payload);
            const localVarPath = `/core/volumes/{volume_id}`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.VolumeApiAxiosParamCreator = VolumeApiAxiosParamCreator;
/**
 * VolumeApi - functional programming interface
 * @export
 */
const VolumeApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.VolumeApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a volume that can be attached to a virtual machine, expanding its storage capacity. Specify the volume type and custom configuration in the request body. For additional details on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/create-volume).
         * @summary Create volume
         * @param {CreateVolumePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume(payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createVolume(payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeApi.createVolume']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a volume permanently. Provide the volume ID in the path to specify the volume to be deleted.
         * @summary Delete volume
         * @param {number} volumeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolume(volumeId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteVolume(volumeId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeApi.deleteVolume']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fetch volume details for specific volume. This endpoint returns id, name, volume size, volume type, status, description, image_id, os_image, created_at, updated_at etc.
         * @summary Fetch Volume Details
         * @param {number} volumeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVolumeDetails(volumeId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchVolumeDetails(volumeId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeApi.fetchVolumeDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Check if a Volume name is available
         * @summary Fetch volume name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVolumeNameAvailability(name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchVolumeNameAvailability(name, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeApi.fetchVolumeNameAvailability']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a list of available volume types that can be used in the creation of a new volume.
         * @summary List volume types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listVolumeTypes(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeApi.listVolumeTypes']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns a list of your existing volumes, providing details for each. For more information on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/).
         * @summary List volumes
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search]
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes(page, pageSize, search, environment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listVolumes(page, pageSize, search, environment, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeApi.listVolumes']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update volume properties. Currently supports updating the environment by providing \'environment_name\'. The volume must not be attached to any instance when changing environments, and the target environment must be in the same region.
         * @summary Update volume fields
         * @param {number} volumeId
         * @param {UpdateVolumePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolume(volumeId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateVolume(volumeId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeApi.updateVolume']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.VolumeApiFp = VolumeApiFp;
/**
 * VolumeApi - factory interface
 * @export
 */
const VolumeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.VolumeApiFp)(configuration);
    return {
        /**
         * Creates a volume that can be attached to a virtual machine, expanding its storage capacity. Specify the volume type and custom configuration in the request body. For additional details on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/create-volume).
         * @summary Create volume
         * @param {CreateVolumePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume(payload, options) {
            return localVarFp.createVolume(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a volume permanently. Provide the volume ID in the path to specify the volume to be deleted.
         * @summary Delete volume
         * @param {number} volumeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolume(volumeId, options) {
            return localVarFp.deleteVolume(volumeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch volume details for specific volume. This endpoint returns id, name, volume size, volume type, status, description, image_id, os_image, created_at, updated_at etc.
         * @summary Fetch Volume Details
         * @param {number} volumeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVolumeDetails(volumeId, options) {
            return localVarFp.fetchVolumeDetails(volumeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Volume name is available
         * @summary Fetch volume name availability
         * @param {string} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVolumeNameAvailability(name, options) {
            return localVarFp.fetchVolumeNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of available volume types that can be used in the creation of a new volume.
         * @summary List volume types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes(options) {
            return localVarFp.listVolumeTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your existing volumes, providing details for each. For more information on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/).
         * @summary List volumes
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search]
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes(page, pageSize, search, environment, options) {
            return localVarFp.listVolumes(page, pageSize, search, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * Update volume properties. Currently supports updating the environment by providing \'environment_name\'. The volume must not be attached to any instance when changing environments, and the target environment must be in the same region.
         * @summary Update volume fields
         * @param {number} volumeId
         * @param {UpdateVolumePayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolume(volumeId, payload, options) {
            return localVarFp.updateVolume(volumeId, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.VolumeApiFactory = VolumeApiFactory;
/**
 * VolumeApi - object-oriented interface
 * @export
 * @class VolumeApi
 * @extends {BaseAPI}
 */
class VolumeApi extends base_1.BaseAPI {
    /**
     * Creates a volume that can be attached to a virtual machine, expanding its storage capacity. Specify the volume type and custom configuration in the request body. For additional details on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/create-volume).
     * @summary Create volume
     * @param {CreateVolumePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    createVolume(payload, options) {
        return (0, exports.VolumeApiFp)(this.configuration).createVolume(payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a volume permanently. Provide the volume ID in the path to specify the volume to be deleted.
     * @summary Delete volume
     * @param {number} volumeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    deleteVolume(volumeId, options) {
        return (0, exports.VolumeApiFp)(this.configuration).deleteVolume(volumeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch volume details for specific volume. This endpoint returns id, name, volume size, volume type, status, description, image_id, os_image, created_at, updated_at etc.
     * @summary Fetch Volume Details
     * @param {number} volumeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    fetchVolumeDetails(volumeId, options) {
        return (0, exports.VolumeApiFp)(this.configuration).fetchVolumeDetails(volumeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if a Volume name is available
     * @summary Fetch volume name availability
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    fetchVolumeNameAvailability(name, options) {
        return (0, exports.VolumeApiFp)(this.configuration).fetchVolumeNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of available volume types that can be used in the creation of a new volume.
     * @summary List volume types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    listVolumeTypes(options) {
        return (0, exports.VolumeApiFp)(this.configuration).listVolumeTypes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of your existing volumes, providing details for each. For more information on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/).
     * @summary List volumes
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search]
     * @param {string} [environment] Filter Environment ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    listVolumes(page, pageSize, search, environment, options) {
        return (0, exports.VolumeApiFp)(this.configuration).listVolumes(page, pageSize, search, environment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update volume properties. Currently supports updating the environment by providing \'environment_name\'. The volume must not be attached to any instance when changing environments, and the target environment must be in the same region.
     * @summary Update volume fields
     * @param {number} volumeId
     * @param {UpdateVolumePayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    updateVolume(volumeId, payload, options) {
        return (0, exports.VolumeApiFp)(this.configuration).updateVolume(volumeId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VolumeApi = VolumeApi;
/**
 * VolumeAttachmentApi - axios parameter creator
 * @export
 */
const VolumeAttachmentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Attaches one or more volumes to an existing virtual machine, expanding its storage capacity by 2PB per attached volume. Include the VM ID in the path and the volume IDs in the request body to attach the specified volumes. For more detailson volume attachment, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-attachment/attach-volumes/).
         * @summary Attach volumes to virtual machine
         * @param {number} vmId
         * @param {AttachVolumesPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachVolumesToVirtualMachine: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('attachVolumesToVirtualMachine', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('attachVolumesToVirtualMachine', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/attach-volumes`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detaches one or more volumes attached to an existing virtual machine. Include the VM ID in the path and volume IDs in the request body to detach the specified volumes from the virtual machine.
         * @summary Detach volumes from virtual machine
         * @param {number} vmId
         * @param {DetachVolumesPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachVolumesFromVirtualMachine: (vmId_1, payload_1, ...args_1) => __awaiter(this, [vmId_1, payload_1, ...args_1], void 0, function* (vmId, payload, options = {}) {
            // verify required parameter 'vmId' is not null or undefined
            (0, common_1.assertParamExists)('detachVolumesFromVirtualMachine', 'vmId', vmId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('detachVolumesFromVirtualMachine', 'payload', payload);
            const localVarPath = `/core/virtual-machines/{vm_id}/detach-volumes`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a volume attachment
         * @param {number} volumeAttachmentId
         * @param {UpdateVolumeAttachmentPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAVolumeAttachment: (volumeAttachmentId_1, payload_1, ...args_1) => __awaiter(this, [volumeAttachmentId_1, payload_1, ...args_1], void 0, function* (volumeAttachmentId, payload, options = {}) {
            // verify required parameter 'volumeAttachmentId' is not null or undefined
            (0, common_1.assertParamExists)('updateAVolumeAttachment', 'volumeAttachmentId', volumeAttachmentId);
            // verify required parameter 'payload' is not null or undefined
            (0, common_1.assertParamExists)('updateAVolumeAttachment', 'payload', payload);
            const localVarPath = `/core/volume-attachments/{volume_attachment_id}`
                .replace(`{${"volume_attachment_id"}}`, encodeURIComponent(String(volumeAttachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "api_key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payload, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.VolumeAttachmentApiAxiosParamCreator = VolumeAttachmentApiAxiosParamCreator;
/**
 * VolumeAttachmentApi - functional programming interface
 * @export
 */
const VolumeAttachmentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.VolumeAttachmentApiAxiosParamCreator)(configuration);
    return {
        /**
         * Attaches one or more volumes to an existing virtual machine, expanding its storage capacity by 2PB per attached volume. Include the VM ID in the path and the volume IDs in the request body to attach the specified volumes. For more detailson volume attachment, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-attachment/attach-volumes/).
         * @summary Attach volumes to virtual machine
         * @param {number} vmId
         * @param {AttachVolumesPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachVolumesToVirtualMachine(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.attachVolumesToVirtualMachine(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeAttachmentApi.attachVolumesToVirtualMachine']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Detaches one or more volumes attached to an existing virtual machine. Include the VM ID in the path and volume IDs in the request body to detach the specified volumes from the virtual machine.
         * @summary Detach volumes from virtual machine
         * @param {number} vmId
         * @param {DetachVolumesPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachVolumesFromVirtualMachine(vmId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.detachVolumesFromVirtualMachine(vmId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeAttachmentApi.detachVolumesFromVirtualMachine']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update a volume attachment
         * @param {number} volumeAttachmentId
         * @param {UpdateVolumeAttachmentPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAVolumeAttachment(volumeAttachmentId, payload, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAVolumeAttachment(volumeAttachmentId, payload, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VolumeAttachmentApi.updateAVolumeAttachment']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.VolumeAttachmentApiFp = VolumeAttachmentApiFp;
/**
 * VolumeAttachmentApi - factory interface
 * @export
 */
const VolumeAttachmentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.VolumeAttachmentApiFp)(configuration);
    return {
        /**
         * Attaches one or more volumes to an existing virtual machine, expanding its storage capacity by 2PB per attached volume. Include the VM ID in the path and the volume IDs in the request body to attach the specified volumes. For more detailson volume attachment, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-attachment/attach-volumes/).
         * @summary Attach volumes to virtual machine
         * @param {number} vmId
         * @param {AttachVolumesPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachVolumesToVirtualMachine(vmId, payload, options) {
            return localVarFp.attachVolumesToVirtualMachine(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches one or more volumes attached to an existing virtual machine. Include the VM ID in the path and volume IDs in the request body to detach the specified volumes from the virtual machine.
         * @summary Detach volumes from virtual machine
         * @param {number} vmId
         * @param {DetachVolumesPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachVolumesFromVirtualMachine(vmId, payload, options) {
            return localVarFp.detachVolumesFromVirtualMachine(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a volume attachment
         * @param {number} volumeAttachmentId
         * @param {UpdateVolumeAttachmentPayload} payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAVolumeAttachment(volumeAttachmentId, payload, options) {
            return localVarFp.updateAVolumeAttachment(volumeAttachmentId, payload, options).then((request) => request(axios, basePath));
        },
    };
};
exports.VolumeAttachmentApiFactory = VolumeAttachmentApiFactory;
/**
 * VolumeAttachmentApi - object-oriented interface
 * @export
 * @class VolumeAttachmentApi
 * @extends {BaseAPI}
 */
class VolumeAttachmentApi extends base_1.BaseAPI {
    /**
     * Attaches one or more volumes to an existing virtual machine, expanding its storage capacity by 2PB per attached volume. Include the VM ID in the path and the volume IDs in the request body to attach the specified volumes. For more detailson volume attachment, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-attachment/attach-volumes/).
     * @summary Attach volumes to virtual machine
     * @param {number} vmId
     * @param {AttachVolumesPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeAttachmentApi
     */
    attachVolumesToVirtualMachine(vmId, payload, options) {
        return (0, exports.VolumeAttachmentApiFp)(this.configuration).attachVolumesToVirtualMachine(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detaches one or more volumes attached to an existing virtual machine. Include the VM ID in the path and volume IDs in the request body to detach the specified volumes from the virtual machine.
     * @summary Detach volumes from virtual machine
     * @param {number} vmId
     * @param {DetachVolumesPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeAttachmentApi
     */
    detachVolumesFromVirtualMachine(vmId, payload, options) {
        return (0, exports.VolumeAttachmentApiFp)(this.configuration).detachVolumesFromVirtualMachine(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a volume attachment
     * @param {number} volumeAttachmentId
     * @param {UpdateVolumeAttachmentPayload} payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeAttachmentApi
     */
    updateAVolumeAttachment(volumeAttachmentId, payload, options) {
        return (0, exports.VolumeAttachmentApiFp)(this.configuration).updateAVolumeAttachment(volumeAttachmentId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VolumeAttachmentApi = VolumeAttachmentApi;
