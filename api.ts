/* tslint:disable */
/* eslint-disable */
/**
 * Infrahub-API
 * Leverage the Infrahub API and Hyperstack platform to easily create, manage, and scale powerful GPU virtual machines and their associated resources.   Access this SDK to automate the deployment of your workloads and streamline your infrastructure management.  To contribute, please raise an issue with a bug report, feature request, feedback, or general inquiry.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessTokenField
 */
export interface AccessTokenField {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenField
     */
    'access_token'?: string;
}
/**
 * 
 * @export
 * @interface AddUserInfoSuccessResponseModel
 */
export interface AddUserInfoSuccessResponseModel {
    /**
     * 
     * @type {UsersInfoFields}
     * @memberof AddUserInfoSuccessResponseModel
     */
    'data'?: UsersInfoFields;
    /**
     * 
     * @type {string}
     * @memberof AddUserInfoSuccessResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddUserInfoSuccessResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface AllocatedGPUCountGraph
 */
export interface AllocatedGPUCountGraph {
    /**
     * 
     * @type {string}
     * @memberof AllocatedGPUCountGraph
     */
    'datetime'?: string;
    /**
     * 
     * @type {number}
     * @memberof AllocatedGPUCountGraph
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface ApiKeyFields
 */
export interface ApiKeyFields {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyFields
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyFields
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyFields
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AssignRbacRolePayload
 */
export interface AssignRbacRolePayload {
    /**
     * 
     * @type {number}
     * @memberof AssignRbacRolePayload
     */
    'role_id': number;
}
/**
 * 
 * @export
 * @interface AttachCallbackPayload
 */
export interface AttachCallbackPayload {
    /**
     * 
     * @type {string}
     * @memberof AttachCallbackPayload
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface AttachCallbackResponse
 */
export interface AttachCallbackResponse {
    /**
     * 
     * @type {string}
     * @memberof AttachCallbackResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AttachCallbackResponse
     */
    'status'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AttachCallbackResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface AttachFirewallWithVM
 */
export interface AttachFirewallWithVM {
    /**
     * 
     * @type {Array<number>}
     * @memberof AttachFirewallWithVM
     */
    'vms': Array<number>;
}
/**
 * 
 * @export
 * @interface AttachFirewallsToVMPayload
 */
export interface AttachFirewallsToVMPayload {
    /**
     * Ids of the firewalls to be attached with a virtual machine.
     * @type {Array<number>}
     * @memberof AttachFirewallsToVMPayload
     */
    'firewalls': Array<number>;
}
/**
 * 
 * @export
 * @interface AttachVolumeFields
 */
export interface AttachVolumeFields {
    /**
     * 
     * @type {string}
     * @memberof AttachVolumeFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachVolumeFields
     */
    'device'?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachVolumeFields
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttachVolumeFields
     */
    'instance_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AttachVolumeFields
     */
    'protected'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AttachVolumeFields
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachVolumeFields
     */
    'volume_id'?: number;
}
/**
 * 
 * @export
 * @interface AttachVolumes
 */
export interface AttachVolumes {
    /**
     * 
     * @type {string}
     * @memberof AttachVolumes
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AttachVolumes
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<AttachVolumeFields>}
     * @memberof AttachVolumes
     */
    'volume_attachments'?: Array<AttachVolumeFields>;
}
/**
 * 
 * @export
 * @interface AttachVolumesPayload
 */
export interface AttachVolumesPayload {
    /**
     * 
     * @type {boolean}
     * @memberof AttachVolumesPayload
     */
    'protected'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof AttachVolumesPayload
     */
    'volume_ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface AttachmentsFieldsForVolume
 */
export interface AttachmentsFieldsForVolume {
    /**
     * 
     * @type {string}
     * @memberof AttachmentsFieldsForVolume
     */
    'device'?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentsFieldsForVolume
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttachmentsFieldsForVolume
     */
    'instance_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AttachmentsFieldsForVolume
     */
    'protected'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AttachmentsFieldsForVolume
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface Attributes
 */
export interface Attributes {
    /**
     * 
     * @type {string}
     * @memberof Attributes
     */
    'base_model'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attributes
     */
    'base_model_display_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Attributes
     */
    'infrahub_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attributes
     */
    'lora_adapter'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attributes
     */
    'resource_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attributes
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface AuthGetTokenResponseModel
 */
export interface AuthGetTokenResponseModel {
    /**
     * 
     * @type {string}
     * @memberof AuthGetTokenResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthGetTokenResponseModel
     */
    'status'?: boolean;
    /**
     * 
     * @type {AccessTokenField}
     * @memberof AuthGetTokenResponseModel
     */
    'token'?: AccessTokenField;
}
/**
 * 
 * @export
 * @interface AuthUserFields
 */
export interface AuthUserFields {
    /**
     * 
     * @type {string}
     * @memberof AuthUserFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthUserFields
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthUserFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthUserFields
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface AuthUserInfoResponseModel
 */
export interface AuthUserInfoResponseModel {
    /**
     * 
     * @type {string}
     * @memberof AuthUserInfoResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthUserInfoResponseModel
     */
    'status'?: boolean;
    /**
     * 
     * @type {AuthUserFields}
     * @memberof AuthUserInfoResponseModel
     */
    'user'?: AuthUserFields;
}
/**
 * 
 * @export
 * @interface BetaAccessRequestFields
 */
export interface BetaAccessRequestFields {
    /**
     * When the request was made
     * @type {string}
     * @memberof BetaAccessRequestFields
     */
    'created_at'?: string;
    /**
     * Unique identifier for the request
     * @type {number}
     * @memberof BetaAccessRequestFields
     */
    'id'?: number;
    /**
     * ID of the beta program
     * @type {number}
     * @memberof BetaAccessRequestFields
     */
    'program_id'?: number;
    /**
     * Name of the beta program
     * @type {string}
     * @memberof BetaAccessRequestFields
     */
    'program_name'?: string;
    /**
     * Status of the request
     * @type {string}
     * @memberof BetaAccessRequestFields
     */
    'status'?: BetaAccessRequestFieldsStatusEnum;
    /**
     * ID of the user who made the request
     * @type {number}
     * @memberof BetaAccessRequestFields
     */
    'user_id'?: number;
}

export const BetaAccessRequestFieldsStatusEnum = {
    Requested: 'requested',
    Approved: 'approved',
    Denied: 'denied',
    Revoked: 'revoked'
} as const;

export type BetaAccessRequestFieldsStatusEnum = typeof BetaAccessRequestFieldsStatusEnum[keyof typeof BetaAccessRequestFieldsStatusEnum];

/**
 * 
 * @export
 * @interface BetaAccessRequestPayload
 */
export interface BetaAccessRequestPayload {
    /**
     * Optional metadata for the request
     * @type {object}
     * @memberof BetaAccessRequestPayload
     */
    'metadata'?: object;
    /**
     * Name of the beta program
     * @type {string}
     * @memberof BetaAccessRequestPayload
     */
    'program': string;
}
/**
 * 
 * @export
 * @interface BetaAccessRequestResponseModel
 */
export interface BetaAccessRequestResponseModel {
    /**
     * 
     * @type {BetaAccessRequestFields}
     * @memberof BetaAccessRequestResponseModel
     */
    'beta_access_request'?: BetaAccessRequestFields;
    /**
     * 
     * @type {string}
     * @memberof BetaAccessRequestResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BetaAccessRequestResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface BetaAccessStatusItem
 */
export interface BetaAccessStatusItem {
    /**
     * Name of the beta program
     * @type {string}
     * @memberof BetaAccessStatusItem
     */
    'program_name'?: string;
    /**
     * When the request was made
     * @type {string}
     * @memberof BetaAccessStatusItem
     */
    'request_date'?: string;
    /**
     * Status of the request (requested, approved, denied, revoked)
     * @type {string}
     * @memberof BetaAccessStatusItem
     */
    'status'?: BetaAccessStatusItemStatusEnum;
}

export const BetaAccessStatusItemStatusEnum = {
    Requested: 'requested',
    Approved: 'approved',
    Denied: 'denied',
    Revoked: 'revoked'
} as const;

export type BetaAccessStatusItemStatusEnum = typeof BetaAccessStatusItemStatusEnum[keyof typeof BetaAccessStatusItemStatusEnum];

/**
 * 
 * @export
 * @interface BetaAccessStatusResponseModel
 */
export interface BetaAccessStatusResponseModel {
    /**
     * List of beta access requests
     * @type {Array<BetaAccessStatusItem>}
     * @memberof BetaAccessStatusResponseModel
     */
    'beta_access_requests'?: Array<BetaAccessStatusItem>;
    /**
     * 
     * @type {string}
     * @memberof BetaAccessStatusResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BetaAccessStatusResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface BillingHistory
 */
export interface BillingHistory {
    /**
     * 
     * @type {Attributes}
     * @memberof BillingHistory
     */
    'attributes'?: Attributes;
    /**
     * 
     * @type {object}
     * @memberof BillingHistory
     */
    'metrics'?: object;
}
/**
 * 
 * @export
 * @interface BillingHistoryDataSynthesisDetails
 */
export interface BillingHistoryDataSynthesisDetails {
    /**
     * 
     * @type {Array<BillingHistory>}
     * @memberof BillingHistoryDataSynthesisDetails
     */
    'billing_history'?: Array<BillingHistory>;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryDataSynthesisDetails
     */
    'org_id'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof BillingHistoryDataSynthesisDetails
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryDataSynthesisDetails
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface BillingHistoryFineTuning
 */
export interface BillingHistoryFineTuning {
    /**
     * 
     * @type {Array<BillingHistory>}
     * @memberof BillingHistoryFineTuning
     */
    'billing_history'?: Array<BillingHistory>;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryFineTuning
     */
    'org_id'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof BillingHistoryFineTuning
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryFineTuning
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface BillingHistoryModelEvalutationDetails
 */
export interface BillingHistoryModelEvalutationDetails {
    /**
     * 
     * @type {Array<BillingHistory>}
     * @memberof BillingHistoryModelEvalutationDetails
     */
    'billing_history'?: Array<BillingHistory>;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryModelEvalutationDetails
     */
    'org_id'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof BillingHistoryModelEvalutationDetails
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryModelEvalutationDetails
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface BillingHistoryServerlessInference
 */
export interface BillingHistoryServerlessInference {
    /**
     * 
     * @type {Array<BillingHistory>}
     * @memberof BillingHistoryServerlessInference
     */
    'billing_history'?: Array<BillingHistory>;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryServerlessInference
     */
    'org_id'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof BillingHistoryServerlessInference
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryServerlessInference
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface BillingHistoryServerlessInferenceDetails
 */
export interface BillingHistoryServerlessInferenceDetails {
    /**
     * 
     * @type {Array<BillingHistory>}
     * @memberof BillingHistoryServerlessInferenceDetails
     */
    'billing_history'?: Array<BillingHistory>;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryServerlessInferenceDetails
     */
    'org_id'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof BillingHistoryServerlessInferenceDetails
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {number}
     * @memberof BillingHistoryServerlessInferenceDetails
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface BillingMetricesFields
 */
export interface BillingMetricesFields {
    /**
     * 
     * @type {boolean}
     * @memberof BillingMetricesFields
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BillingMetricesFields
     */
    'bill_per_minute'?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingMetricesFields
     */
    'create_time'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BillingMetricesFields
     */
    'exclude_billing'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BillingMetricesFields
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof BillingMetricesFields
     */
    'organization_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof BillingMetricesFields
     */
    'resource_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingMetricesFields
     */
    'resource_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingMetricesFields
     */
    'terminate_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof BillingMetricesFields
     */
    'total_bill'?: number;
    /**
     * 
     * @type {number}
     * @memberof BillingMetricesFields
     */
    'total_up_time'?: number;
}
/**
 * 
 * @export
 * @interface BillingMetricesResponse
 */
export interface BillingMetricesResponse {
    /**
     * 
     * @type {Array<BillingMetricesFields>}
     * @memberof BillingMetricesResponse
     */
    'data'?: Array<BillingMetricesFields>;
    /**
     * 
     * @type {string}
     * @memberof BillingMetricesResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BillingMetricesResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterEvents
 */
export interface ClusterEvents {
    /**
     * 
     * @type {Array<ClusterEventsFields>}
     * @memberof ClusterEvents
     */
    'cluster_events'?: Array<ClusterEventsFields>;
    /**
     * 
     * @type {string}
     * @memberof ClusterEvents
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterEvents
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterEventsFields
 */
export interface ClusterEventsFields {
    /**
     * 
     * @type {number}
     * @memberof ClusterEventsFields
     */
    'cluster_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterEventsFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterEventsFields
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterEventsFields
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterEventsFields
     */
    'org_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterEventsFields
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterEventsFields
     */
    'time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterEventsFields
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterEventsFields
     */
    'user_id'?: number;
}
/**
 * 
 * @export
 * @interface ClusterFields
 */
export interface ClusterFields {
    /**
     * 
     * @type {string}
     * @memberof ClusterFields
     */
    'api_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFields
     */
    'environment_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterFields
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFields
     */
    'is_reconciling'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterFields
     */
    'keypair_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFields
     */
    'kube_config'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFields
     */
    'kubernetes_version'?: string;
    /**
     * 
     * @type {ClusterFlavorFields}
     * @memberof ClusterFields
     */
    'master_flavor'?: ClusterFlavorFields;
    /**
     * 
     * @type {string}
     * @memberof ClusterFields
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ClusterNodeGroupFields>}
     * @memberof ClusterFields
     */
    'node_groups'?: Array<ClusterNodeGroupFields>;
    /**
     * 
     * @type {Array<ClusterNodeFields>}
     * @memberof ClusterFields
     */
    'nodes'?: Array<ClusterNodeFields>;
    /**
     * 
     * @type {string}
     * @memberof ClusterFields
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFields
     */
    'status_reason'?: string;
}
/**
 * 
 * @export
 * @interface ClusterFlavorFields
 */
export interface ClusterFlavorFields {
    /**
     * 
     * @type {number}
     * @memberof ClusterFlavorFields
     */
    'cpu'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterFlavorFields
     */
    'disk'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterFlavorFields
     */
    'ephemeral'?: number;
    /**
     * 
     * @type {object}
     * @memberof ClusterFlavorFields
     */
    'features'?: object;
    /**
     * 
     * @type {string}
     * @memberof ClusterFlavorFields
     */
    'gpu'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterFlavorFields
     */
    'gpu_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterFlavorFields
     */
    'id'?: number;
    /**
     * 
     * @type {Array<LableResonse>}
     * @memberof ClusterFlavorFields
     */
    'labels'?: Array<LableResonse>;
    /**
     * 
     * @type {string}
     * @memberof ClusterFlavorFields
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterFlavorFields
     */
    'ram'?: number;
}
/**
 * 
 * @export
 * @interface ClusterListResponse
 */
export interface ClusterListResponse {
    /**
     * 
     * @type {Array<ClusterFields>}
     * @memberof ClusterListResponse
     */
    'clusters'?: Array<ClusterFields>;
    /**
     * 
     * @type {string}
     * @memberof ClusterListResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterListResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterNodeFields
 */
export interface ClusterNodeFields {
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeFields
     */
    'id'?: number;
    /**
     * 
     * @type {ClusterNodeInstanceFields}
     * @memberof ClusterNodeFields
     */
    'instance'?: ClusterNodeInstanceFields;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterNodeFields
     */
    'is_bastion'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeFields
     */
    'node_group_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeFields
     */
    'node_group_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterNodeFields
     */
    'requires_public_ip'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeFields
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeFields
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeFields
     */
    'status_reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeFields
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ClusterNodeGroupFields
 */
export interface ClusterNodeGroupFields {
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeGroupFields
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeGroupFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {ClusterFlavorFields}
     * @memberof ClusterNodeGroupFields
     */
    'flavor'?: ClusterFlavorFields;
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeGroupFields
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeGroupFields
     */
    'max_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeGroupFields
     */
    'min_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeGroupFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeGroupFields
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeGroupFields
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ClusterNodeGroupsCreateResponse
 */
export interface ClusterNodeGroupsCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeGroupsCreateResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ClusterNodeGroupFields}
     * @memberof ClusterNodeGroupsCreateResponse
     */
    'node_group'?: ClusterNodeGroupFields;
    /**
     * 
     * @type {Array<ClusterNodeFields>}
     * @memberof ClusterNodeGroupsCreateResponse
     */
    'nodes'?: Array<ClusterNodeFields>;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterNodeGroupsCreateResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterNodeGroupsGetResponse
 */
export interface ClusterNodeGroupsGetResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeGroupsGetResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ClusterNodeGroupFields}
     * @memberof ClusterNodeGroupsGetResponse
     */
    'node_group'?: ClusterNodeGroupFields;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterNodeGroupsGetResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterNodeGroupsListResponse
 */
export interface ClusterNodeGroupsListResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeGroupsListResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ClusterNodeGroupFields>}
     * @memberof ClusterNodeGroupsListResponse
     */
    'node_groups'?: Array<ClusterNodeGroupFields>;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterNodeGroupsListResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterNodeInstanceFields
 */
export interface ClusterNodeInstanceFields {
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeInstanceFields
     */
    'contract_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeInstanceFields
     */
    'fixed_ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeInstanceFields
     */
    'floating_ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeInstanceFields
     */
    'floating_ip_status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeInstanceFields
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterNodeInstanceFields
     */
    'image_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeInstanceFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterNodeInstanceFields
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ClusterNodesListResponse
 */
export interface ClusterNodesListResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterNodesListResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ClusterNodeFields>}
     * @memberof ClusterNodesListResponse
     */
    'nodes'?: Array<ClusterNodeFields>;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterNodesListResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterResponse
 */
export interface ClusterResponse {
    /**
     * 
     * @type {ClusterFields}
     * @memberof ClusterResponse
     */
    'cluster'?: ClusterFields;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterVersion
 */
export interface ClusterVersion {
    /**
     * 
     * @type {string}
     * @memberof ClusterVersion
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterVersion
     */
    'id'?: number;
    /**
     * 
     * @type {object}
     * @memberof ClusterVersion
     */
    'image'?: object;
    /**
     * 
     * @type {object}
     * @memberof ClusterVersion
     */
    'region'?: object;
    /**
     * 
     * @type {string}
     * @memberof ClusterVersion
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterVersion
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ClusterVersions
 */
export interface ClusterVersions {
    /**
     * 
     * @type {string}
     * @memberof ClusterVersions
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterVersions
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<ClusterVersion>}
     * @memberof ClusterVersions
     */
    'versions'?: Array<ClusterVersion>;
}
/**
 * 
 * @export
 * @interface Colors
 */
export interface Colors {
    /**
     * 
     * @type {PrimaryColor}
     * @memberof Colors
     */
    'primary'?: PrimaryColor;
    /**
     * 
     * @type {SecondaryColor}
     * @memberof Colors
     */
    'secondary'?: SecondaryColor;
}
/**
 * 
 * @export
 * @interface CommonResponseModel
 */
export interface CommonResponseModel {
    /**
     * 
     * @type {string}
     * @memberof CommonResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CommonResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ComplianceFields
 */
export interface ComplianceFields {
    /**
     * 
     * @type {Array<number>}
     * @memberof ComplianceFields
     */
    'cpu'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ComplianceFields
     */
    'gpu_model'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ComplianceFields
     */
    'hdd'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ComplianceFields
     */
    'ram'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ComplianceModelFields
 */
export interface ComplianceModelFields {
    /**
     * 
     * @type {number}
     * @memberof ComplianceModelFields
     */
    'base_value'?: number;
    /**
     * 
     * @type {string}
     * @memberof ComplianceModelFields
     */
    'gpu_model'?: string;
    /**
     * 
     * @type {number}
     * @memberof ComplianceModelFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ComplianceModelFields
     */
    'resource_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof ComplianceModelFields
     */
    'variation_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof ComplianceModelFields
     */
    'variation_min'?: number;
    /**
     * 
     * @type {number}
     * @memberof ComplianceModelFields
     */
    'variation_unit'?: number;
}
/**
 * 
 * @export
 * @interface CompliancePayload
 */
export interface CompliancePayload {
    /**
     * 
     * @type {number}
     * @memberof CompliancePayload
     */
    'base_value': number;
    /**
     * 
     * @type {string}
     * @memberof CompliancePayload
     */
    'gpu_model': string;
    /**
     * 
     * @type {string}
     * @memberof CompliancePayload
     */
    'resource_type': string;
    /**
     * 
     * @type {number}
     * @memberof CompliancePayload
     */
    'variation_max': number;
    /**
     * 
     * @type {number}
     * @memberof CompliancePayload
     */
    'variation_min': number;
    /**
     * 
     * @type {number}
     * @memberof CompliancePayload
     */
    'variation_unit': number;
}
/**
 * 
 * @export
 * @interface ComplianceResponse
 */
export interface ComplianceResponse {
    /**
     * 
     * @type {ComplianceFields}
     * @memberof ComplianceResponse
     */
    'compliance'?: ComplianceFields;
    /**
     * 
     * @type {string}
     * @memberof ComplianceResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ComplianceResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerOverviewFields
 */
export interface ContainerOverviewFields {
    /**
     * 
     * @type {number}
     * @memberof ContainerOverviewFields
     */
    'cost_per_hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerOverviewFields
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerOverviewFields
     */
    'gpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerOverviewFields
     */
    'ram'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerOverviewFields
     */
    'vcpus'?: number;
}
/**
 * 
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * 
     * @type {Array<AllocatedGPUCountGraph>}
     * @memberof Contract
     */
    'allocated_gpu_count_graph'?: Array<AllocatedGPUCountGraph>;
    /**
     * 
     * @type {number}
     * @memberof Contract
     */
    'granularity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Contract
     */
    'org_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof Contract
     */
    'total_gpu_allocation'?: number;
}
/**
 * 
 * @export
 * @interface ContractDiscountPlanFields
 */
export interface ContractDiscountPlanFields {
    /**
     * 
     * @type {number}
     * @memberof ContractDiscountPlanFields
     */
    'discount_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContractDiscountPlanFields
     */
    'discount_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContractDiscountPlanFields
     */
    'discount_percent'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContractDiscountPlanFields
     */
    'discount_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractDiscountPlanFields
     */
    'discount_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContractDiscountPlanFields
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContractDiscountPlanFields
     */
    'remaining_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContractDiscountPlanFields
     */
    'resource_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContractDiscountPlanFields
     */
    'resource_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContractDiscountPlanFields
     */
    'resource_name'?: string;
}
/**
 * 
 * @export
 * @interface ContractGPUAllocationGraphResponse
 */
export interface ContractGPUAllocationGraphResponse {
    /**
     * 
     * @type {Contract}
     * @memberof ContractGPUAllocationGraphResponse
     */
    'contract'?: Contract;
    /**
     * 
     * @type {string}
     * @memberof ContractGPUAllocationGraphResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractGPUAllocationGraphResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ContractInstanceFields
 */
export interface ContractInstanceFields {
    /**
     * 
     * @type {ClusterFields}
     * @memberof ContractInstanceFields
     */
    'cluster'?: ClusterFields;
    /**
     * 
     * @type {string}
     * @memberof ContractInstanceFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractInstanceFields
     */
    'flavor_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContractInstanceFields
     */
    'gpu_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContractInstanceFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContractInstanceFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractInstanceFields
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractInstanceFields
     */
    'termination_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContractInstanceFields
     */
    'total_usage_time'?: number;
}
/**
 * 
 * @export
 * @interface ContractInstancesResponse
 */
export interface ContractInstancesResponse {
    /**
     * 
     * @type {Array<ContractInstanceFields>}
     * @memberof ContractInstancesResponse
     */
    'instances'?: Array<ContractInstanceFields>;
    /**
     * 
     * @type {string}
     * @memberof ContractInstancesResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractInstancesResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateClusterNodeFields
 */
export interface CreateClusterNodeFields {
    /**
     * 
     * @type {number}
     * @memberof CreateClusterNodeFields
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterNodeFields
     */
    'node_group'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterNodeFields
     */
    'role'?: CreateClusterNodeFieldsRoleEnum;
}

export const CreateClusterNodeFieldsRoleEnum = {
    Worker: 'worker',
    Master: 'master'
} as const;

export type CreateClusterNodeFieldsRoleEnum = typeof CreateClusterNodeFieldsRoleEnum[keyof typeof CreateClusterNodeFieldsRoleEnum];

/**
 * 
 * @export
 * @interface CreateClusterNodeGroupPayload
 */
export interface CreateClusterNodeGroupPayload {
    /**
     * 
     * @type {number}
     * @memberof CreateClusterNodeGroupPayload
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterNodeGroupPayload
     */
    'flavor_name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateClusterNodeGroupPayload
     */
    'max_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateClusterNodeGroupPayload
     */
    'min_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterNodeGroupPayload
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterNodeGroupPayload
     */
    'role': CreateClusterNodeGroupPayloadRoleEnum;
}

export const CreateClusterNodeGroupPayloadRoleEnum = {
    Worker: 'worker'
} as const;

export type CreateClusterNodeGroupPayloadRoleEnum = typeof CreateClusterNodeGroupPayloadRoleEnum[keyof typeof CreateClusterNodeGroupPayloadRoleEnum];

/**
 * 
 * @export
 * @interface CreateClusterPayload
 */
export interface CreateClusterPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateClusterPayload
     */
    'deployment_mode'?: CreateClusterPayloadDeploymentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterPayload
     */
    'environment_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterPayload
     */
    'keypair_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterPayload
     */
    'kubernetes_version': string;
    /**
     * 
     * @type {number}
     * @memberof CreateClusterPayload
     */
    'master_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterPayload
     */
    'master_flavor_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterPayload
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateClusterPayload
     */
    'node_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateClusterPayload
     */
    'node_flavor_name'?: string;
    /**
     * 
     * @type {Array<CreateClusterNodeGroupPayload>}
     * @memberof CreateClusterPayload
     */
    'node_groups'?: Array<CreateClusterNodeGroupPayload>;
}

export const CreateClusterPayloadDeploymentModeEnum = {
    Full: 'full',
    Standard: 'standard'
} as const;

export type CreateClusterPayloadDeploymentModeEnum = typeof CreateClusterPayloadDeploymentModeEnum[keyof typeof CreateClusterPayloadDeploymentModeEnum];

/**
 * 
 * @export
 * @interface CreateEnvironment
 */
export interface CreateEnvironment {
    /**
     * The name of the environment being created.
     * @type {string}
     * @memberof CreateEnvironment
     */
    'name': string;
    /**
     * The geographic location of the data center where the environment is being created. To learn more about regions, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/features/regions).
     * @type {string}
     * @memberof CreateEnvironment
     */
    'region': string;
}
/**
 * 
 * @export
 * @interface CreateFirewallPayload
 */
export interface CreateFirewallPayload {
    /**
     * Description of the firewall.
     * @type {string}
     * @memberof CreateFirewallPayload
     */
    'description'?: string;
    /**
     * ID of the environment.
     * @type {number}
     * @memberof CreateFirewallPayload
     */
    'environment_id': number;
    /**
     * Name of the firewall.
     * @type {string}
     * @memberof CreateFirewallPayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateFirewallRulePayload
 */
export interface CreateFirewallRulePayload {
    /**
     * The direction of traffic that the firewall rule applies to.
     * @type {string}
     * @memberof CreateFirewallRulePayload
     */
    'direction': string;
    /**
     * The Ethernet type associated with the rule.
     * @type {string}
     * @memberof CreateFirewallRulePayload
     */
    'ethertype': string;
    /**
     * The maximum port number in the range of ports to be allowed by the firewall rule.
     * @type {number}
     * @memberof CreateFirewallRulePayload
     */
    'port_range_max'?: number;
    /**
     * The minimum port number in the range of ports to be allowed by the firewall rule.
     * @type {number}
     * @memberof CreateFirewallRulePayload
     */
    'port_range_min'?: number;
    /**
     * The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
     * @type {string}
     * @memberof CreateFirewallRulePayload
     */
    'protocol': CreateFirewallRulePayloadProtocolEnum;
    /**
     * The IP address range that is allowed to access the specified port. Use \"0.0.0.0/0\" to allow any IP address.
     * @type {string}
     * @memberof CreateFirewallRulePayload
     */
    'remote_ip_prefix': string;
}

export const CreateFirewallRulePayloadProtocolEnum = {
    Any: 'any',
    Ah: 'ah',
    Dccp: 'dccp',
    Egp: 'egp',
    Esp: 'esp',
    Gre: 'gre',
    Hopopt: 'hopopt',
    Icmp: 'icmp',
    Igmp: 'igmp',
    Ip: 'ip',
    Ipip: 'ipip',
    Ipv6Encap: 'ipv6-encap',
    Ipv6Frag: 'ipv6-frag',
    Ipv6Icmp: 'ipv6-icmp',
    Icmpv6: 'icmpv6',
    Ipv6Nonxt: 'ipv6-nonxt',
    Ipv6Opts: 'ipv6-opts',
    Ipv6Route: 'ipv6-route',
    Ospf: 'ospf',
    Pgm: 'pgm',
    Rsvp: 'rsvp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp',
    Udplite: 'udplite',
    Vrrp: 'vrrp'
} as const;

export type CreateFirewallRulePayloadProtocolEnum = typeof CreateFirewallRulePayloadProtocolEnum[keyof typeof CreateFirewallRulePayloadProtocolEnum];

/**
 * 
 * @export
 * @interface CreateImage
 */
export interface CreateImage {
    /**
     * 
     * @type {number}
     * @memberof CreateImage
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateImage
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImage
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateImagePayload
 */
export interface CreateImagePayload {
    /**
     * List of labels to attach to the image
     * @type {Array<string>}
     * @memberof CreateImagePayload
     */
    'labels'?: Array<string>;
    /**
     * Name for the new custom image
     * @type {string}
     * @memberof CreateImagePayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateInstancesPayload
 */
export interface CreateInstancesPayload {
    /**
     * When this field is set to `true`, it attaches a [public IP address](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/) to the virtual machine, enabling internet accessibility.
     * @type {boolean}
     * @memberof CreateInstancesPayload
     */
    'assign_floating_ip'?: boolean;
    /**
     * An optional URL where actions performed on the virtual machine will be sent. For additional information on event callbacks, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/).
     * @type {string}
     * @memberof CreateInstancesPayload
     */
    'callback_url'?: string;
    /**
     * The number of virtual machines to be created.
     * @type {number}
     * @memberof CreateInstancesPayload
     */
    'count': number;
    /**
     * Indicates whether to create a bootable volume for the virtual machine. When set to `true`, a bootable volume will be created; the default value is `false`.
     * @type {boolean}
     * @memberof CreateInstancesPayload
     */
    'create_bootable_volume'?: boolean;
    /**
     * Indicates whether to enable port randomization.This setting is only effective if \'assign_floating_ip\' is true. Defaults to true.
     * @type {boolean}
     * @memberof CreateInstancesPayload
     */
    'enable_port_randomization'?: boolean;
    /**
     * The name of the [environment](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/) in which the virtual machine is to be created.
     * @type {string}
     * @memberof CreateInstancesPayload
     */
    'environment_name': string;
    /**
     * 
     * @type {FlavorObjectFields}
     * @memberof CreateInstancesPayload
     */
    'flavor'?: FlavorObjectFields;
    /**
     * The name of the GPU hardware configuration ([flavor](https://docs.hyperstack.cloud/docs/hardware/flavors)) for the virtual machines being created.
     * @type {string}
     * @memberof CreateInstancesPayload
     */
    'flavor_name': string;
    /**
     * The [operating system (OS) image](https://docs.hyperstack.cloud/docs/virtual-machines/images) name designated for installation on the virtual machine.It also accepts custom, private images, created from [existing snapshots](https://docs.hyperstack.cloud/docs/virtual-machines/custom-images).
     * @type {string}
     * @memberof CreateInstancesPayload
     */
    'image_name'?: string;
    /**
     * The name of the existing SSH key pair to be used for secure access to the virtual machine. For additional information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
     * @type {string}
     * @memberof CreateInstancesPayload
     */
    'key_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateInstancesPayload
     */
    'labels'?: Array<string>;
    /**
     * The name of the virtual machine being created.
     * @type {string}
     * @memberof CreateInstancesPayload
     */
    'name': string;
    /**
     * 
     * @type {ProfileObjectFields}
     * @memberof CreateInstancesPayload
     */
    'profile'?: ProfileObjectFields;
    /**
     * 
     * @type {Array<CreateSecurityRulePayload>}
     * @memberof CreateInstancesPayload
     */
    'security_rules'?: Array<CreateSecurityRulePayload>;
    /**
     * Optional initialization configuration commands to manage the configuration of a virtual machine at launch using cloud-init scripts. For more information about custom VM configuration using cloud-init, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/initialization-configuration).
     * @type {string}
     * @memberof CreateInstancesPayload
     */
    'user_data'?: string;
    /**
     * The names of the volume(s) to be attached to the virtual machine being created.
     * @type {string}
     * @memberof CreateInstancesPayload
     */
    'volume_name'?: string;
}
/**
 * 
 * @export
 * @interface CreateInstancesResponse
 */
export interface CreateInstancesResponse {
    /**
     * 
     * @type {Array<InstanceFields>}
     * @memberof CreateInstancesResponse
     */
    'instances'?: Array<InstanceFields>;
    /**
     * 
     * @type {string}
     * @memberof CreateInstancesResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateInstancesResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateProfilePayload
 */
export interface CreateProfilePayload {
    /**
     * The data object containing the configuration details of the virtual machine profile being created.
     * @type {{ [key: string]: string; }}
     * @memberof CreateProfilePayload
     */
    'data': { [key: string]: string; };
    /**
     * The optional description for the profile being created.
     * @type {string}
     * @memberof CreateProfilePayload
     */
    'description'?: string;
    /**
     * The name of the profile being created.
     * @type {string}
     * @memberof CreateProfilePayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateProfileResponse
 */
export interface CreateProfileResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateProfileResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ProfileFields}
     * @memberof CreateProfileResponse
     */
    'profile'?: ProfileFields;
    /**
     * 
     * @type {boolean}
     * @memberof CreateProfileResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateSecurityRulePayload
 */
export interface CreateSecurityRulePayload {
    /**
     * The direction of traffic that the firewall rule applies to.
     * @type {string}
     * @memberof CreateSecurityRulePayload
     */
    'direction': string;
    /**
     * The Ethernet type associated with the rule.
     * @type {string}
     * @memberof CreateSecurityRulePayload
     */
    'ethertype': string;
    /**
     * The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.
     * @type {string}
     * @memberof CreateSecurityRulePayload
     */
    'protocol': CreateSecurityRulePayloadProtocolEnum;
    /**
     * The IP address range that is allowed to access the specified port. Use \"0.0.0.0/0\" to allow any IP address.
     * @type {string}
     * @memberof CreateSecurityRulePayload
     */
    'remote_ip_prefix': string;
    /**
     * 
     * @type {number}
     * @memberof CreateSecurityRulePayload
     */
    'port_range_min'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateSecurityRulePayload
     */
    'port_range_max'?: number;
}

export const CreateSecurityRulePayloadProtocolEnum = {
    Any: 'any',
    Ah: 'ah',
    Dccp: 'dccp',
    Egp: 'egp',
    Esp: 'esp',
    Gre: 'gre',
    Hopopt: 'hopopt',
    Icmp: 'icmp',
    Igmp: 'igmp',
    Ip: 'ip',
    Ipip: 'ipip',
    Ipv6Encap: 'ipv6-encap',
    Ipv6Frag: 'ipv6-frag',
    Ipv6Icmp: 'ipv6-icmp',
    Icmpv6: 'icmpv6',
    Ipv6Nonxt: 'ipv6-nonxt',
    Ipv6Opts: 'ipv6-opts',
    Ipv6Route: 'ipv6-route',
    Ospf: 'ospf',
    Pgm: 'pgm',
    Rsvp: 'rsvp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp',
    Udplite: 'udplite',
    Vrrp: 'vrrp'
} as const;

export type CreateSecurityRulePayloadProtocolEnum = typeof CreateSecurityRulePayloadProtocolEnum[keyof typeof CreateSecurityRulePayloadProtocolEnum];

/**
 * 
 * @export
 * @interface CreateSnapshotPayload
 */
export interface CreateSnapshotPayload {
    /**
     * description
     * @type {string}
     * @memberof CreateSnapshotPayload
     */
    'description': string;
    /**
     * Labels associated with snapshot
     * @type {Array<string>}
     * @memberof CreateSnapshotPayload
     */
    'labels'?: Array<string>;
    /**
     * Snapshot name
     * @type {string}
     * @memberof CreateSnapshotPayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateSnapshotResponse
 */
export interface CreateSnapshotResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateSnapshotResponse
     */
    'message'?: string;
    /**
     * 
     * @type {SnapshotFields}
     * @memberof CreateSnapshotResponse
     */
    'snapshot'?: SnapshotFields;
    /**
     * 
     * @type {boolean}
     * @memberof CreateSnapshotResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateUpdateComplianceResponse
 */
export interface CreateUpdateComplianceResponse {
    /**
     * 
     * @type {ComplianceModelFields}
     * @memberof CreateUpdateComplianceResponse
     */
    'compliance'?: ComplianceModelFields;
    /**
     * 
     * @type {string}
     * @memberof CreateUpdateComplianceResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUpdateComplianceResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateUpdateRbacRolePayload
 */
export interface CreateUpdateRbacRolePayload {
    /**
     * Description of the role.
     * @type {string}
     * @memberof CreateUpdateRbacRolePayload
     */
    'description': string;
    /**
     * Name of the RBAC role.
     * @type {string}
     * @memberof CreateUpdateRbacRolePayload
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateUpdateRbacRolePayload
     */
    'permissions'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateUpdateRbacRolePayload
     */
    'policies'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CreateVolumePayload
 */
export interface CreateVolumePayload {
    /**
     * A URL that can be attached to the volume you are creating. This `callback_url` will post any action events that occur to your volume to the provided URL.
     * @type {string}
     * @memberof CreateVolumePayload
     */
    'callback_url'?: string;
    /**
     * A brief description or comment about the volume.
     * @type {string}
     * @memberof CreateVolumePayload
     */
    'description'?: string;
    /**
     * The name of the [environment](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/) within which the volume is being created.
     * @type {string}
     * @memberof CreateVolumePayload
     */
    'environment_name': string;
    /**
     * The ID of the operating system image that will be associated with the volume. By providing an `image_id` in the create volume request, you will create a bootable volume.
     * @type {number}
     * @memberof CreateVolumePayload
     */
    'image_id'?: number;
    /**
     * The name of the volume being created.
     * @type {string}
     * @memberof CreateVolumePayload
     */
    'name': string;
    /**
     * The size of the volume in GB. 1048576GB storage capacity per volume.
     * @type {number}
     * @memberof CreateVolumePayload
     */
    'size': number;
    /**
     * Specifies the type of volume being created, which determines the storage technology it will use. Call the [List volume types](https://infrahub-api-doc.nexgencloud.com/#get-/core/volumes) endpoint to retrieve a list of available volume model types.
     * @type {string}
     * @memberof CreateVolumePayload
     */
    'volume_type': string;
}
/**
 * 
 * @export
 * @interface CustomerContractDetailResponseModel
 */
export interface CustomerContractDetailResponseModel {
    /**
     * 
     * @type {CustomerContractFields}
     * @memberof CustomerContractDetailResponseModel
     */
    'contracts'?: CustomerContractFields;
    /**
     * 
     * @type {string}
     * @memberof CustomerContractDetailResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerContractDetailResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomerContractFields
 */
export interface CustomerContractFields {
    /**
     * 
     * @type {string}
     * @memberof CustomerContractFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerContractFields
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ContractDiscountPlanFields>}
     * @memberof CustomerContractFields
     */
    'discounts'?: Array<ContractDiscountPlanFields>;
    /**
     * 
     * @type {string}
     * @memberof CustomerContractFields
     */
    'end_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerContractFields
     */
    'expiration_policy'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerContractFields
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerContractFields
     */
    'org_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerContractFields
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerContractFields
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DashboardInfoResponse
 */
export interface DashboardInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof DashboardInfoResponse
     */
    'message'?: string;
    /**
     * 
     * @type {OverviewInfo}
     * @memberof DashboardInfoResponse
     */
    'overview'?: OverviewInfo;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardInfoResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface DataSynthesisBillingHistoryDetailsResponseSchema
 */
export interface DataSynthesisBillingHistoryDetailsResponseSchema {
    /**
     * 
     * @type {BillingHistoryDataSynthesisDetails}
     * @memberof DataSynthesisBillingHistoryDetailsResponseSchema
     */
    'billing_history_data_synthesis_details'?: BillingHistoryDataSynthesisDetails;
    /**
     * 
     * @type {string}
     * @memberof DataSynthesisBillingHistoryDetailsResponseSchema
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DataSynthesisBillingHistoryDetailsResponseSchema
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteClusterNodesFields
 */
export interface DeleteClusterNodesFields {
    /**
     * 
     * @type {Array<number>}
     * @memberof DeleteClusterNodesFields
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeploymentFields
 */
export interface DeploymentFields {
    /**
     * 
     * @type {string}
     * @memberof DeploymentFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentFields
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentFields
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentFields
     */
    'template'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentFieldsForStartDeployments
 */
export interface DeploymentFieldsForStartDeployments {
    /**
     * 
     * @type {string}
     * @memberof DeploymentFieldsForStartDeployments
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentFieldsForStartDeployments
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentFieldsForStartDeployments
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentFieldsForStartDeployments
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentFieldsForStartDeployments
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentFieldsForStartDeployments
     */
    'template'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentFieldsForStartDeployments
     */
    'variables'?: string;
}
/**
 * 
 * @export
 * @interface Deployments
 */
export interface Deployments {
    /**
     * 
     * @type {Array<DeploymentFields>}
     * @memberof Deployments
     */
    'deployments'?: Array<DeploymentFields>;
    /**
     * 
     * @type {string}
     * @memberof Deployments
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Deployments
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface DetachVolumes
 */
export interface DetachVolumes {
    /**
     * 
     * @type {string}
     * @memberof DetachVolumes
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DetachVolumes
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<AttachVolumeFields>}
     * @memberof DetachVolumes
     */
    'volume_attachments'?: Array<AttachVolumeFields>;
}
/**
 * 
 * @export
 * @interface DetachVolumesPayload
 */
export interface DetachVolumesPayload {
    /**
     * 
     * @type {Array<number>}
     * @memberof DetachVolumesPayload
     */
    'volume_ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EditLabelOfAnExistingVMPayload
 */
export interface EditLabelOfAnExistingVMPayload {
    /**
     * Multiple labels can be added by separating with spaces
     * @type {Array<string>}
     * @memberof EditLabelOfAnExistingVMPayload
     */
    'labels'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * 
     * @type {EnvironmentFields}
     * @memberof Environment
     */
    'environment'?: EnvironmentFields;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Environment
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface EnvironmentFeatures
 */
export interface EnvironmentFeatures {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentFeatures
     */
    'green_status'?: EnvironmentFeaturesGreenStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentFeatures
     */
    'network_optimised'?: boolean;
}

export const EnvironmentFeaturesGreenStatusEnum = {
    Green: 'GREEN',
    PartiallyGreen: 'PARTIALLY_GREEN',
    NotGreen: 'NOT_GREEN'
} as const;

export type EnvironmentFeaturesGreenStatusEnum = typeof EnvironmentFeaturesGreenStatusEnum[keyof typeof EnvironmentFeaturesGreenStatusEnum];

/**
 * 
 * @export
 * @interface EnvironmentFields
 */
export interface EnvironmentFields {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {EnvironmentFeatures}
     * @memberof EnvironmentFields
     */
    'features'?: EnvironmentFeatures;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentFields
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentFieldsForVolume
 */
export interface EnvironmentFieldsForVolume {
    /**
     * 
     * @type {object}
     * @memberof EnvironmentFieldsForVolume
     */
    'features'?: object;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentFieldsForVolume
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentFieldsForVolume
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface Environments
 */
export interface Environments {
    /**
     * 
     * @type {number}
     * @memberof Environments
     */
    'count'?: number;
    /**
     * 
     * @type {Array<EnvironmentFields>}
     * @memberof Environments
     */
    'environments'?: Array<EnvironmentFields>;
    /**
     * 
     * @type {string}
     * @memberof Environments
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof Environments
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Environments
     */
    'page_size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Environments
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ErrorResponseModel
 */
export interface ErrorResponseModel {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseModel
     */
    'error_reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface FirewallAttachmentModel
 */
export interface FirewallAttachmentModel {
    /**
     * 
     * @type {string}
     * @memberof FirewallAttachmentModel
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof FirewallAttachmentModel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FirewallAttachmentModel
     */
    'status'?: string;
    /**
     * 
     * @type {FirewallAttachmentVMModel}
     * @memberof FirewallAttachmentModel
     */
    'vm'?: FirewallAttachmentVMModel;
}
/**
 * 
 * @export
 * @interface FirewallAttachmentVMModel
 */
export interface FirewallAttachmentVMModel {
    /**
     * 
     * @type {string}
     * @memberof FirewallAttachmentVMModel
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof FirewallAttachmentVMModel
     */
    'environment'?: string;
    /**
     * 
     * @type {string}
     * @memberof FirewallAttachmentVMModel
     */
    'flavor'?: string;
    /**
     * 
     * @type {number}
     * @memberof FirewallAttachmentVMModel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FirewallAttachmentVMModel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FirewallAttachmentVMModel
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface FirewallDetailFields
 */
export interface FirewallDetailFields {
    /**
     * 
     * @type {Array<FirewallAttachmentModel>}
     * @memberof FirewallDetailFields
     */
    'attachments'?: Array<FirewallAttachmentModel>;
    /**
     * 
     * @type {string}
     * @memberof FirewallDetailFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof FirewallDetailFields
     */
    'description'?: string;
    /**
     * 
     * @type {FirewallEnvironmentFields}
     * @memberof FirewallDetailFields
     */
    'environment'?: FirewallEnvironmentFields;
    /**
     * 
     * @type {number}
     * @memberof FirewallDetailFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FirewallDetailFields
     */
    'name'?: string;
    /**
     * 
     * @type {Array<SecurityGroupRuleFields>}
     * @memberof FirewallDetailFields
     */
    'rules'?: Array<SecurityGroupRuleFields>;
    /**
     * 
     * @type {string}
     * @memberof FirewallDetailFields
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface FirewallDetailResponse
 */
export interface FirewallDetailResponse {
    /**
     * 
     * @type {FirewallDetailFields}
     * @memberof FirewallDetailResponse
     */
    'firewall'?: FirewallDetailFields;
    /**
     * 
     * @type {string}
     * @memberof FirewallDetailResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FirewallDetailResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface FirewallEnvironmentFields
 */
export interface FirewallEnvironmentFields {
    /**
     * 
     * @type {number}
     * @memberof FirewallEnvironmentFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FirewallEnvironmentFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FirewallEnvironmentFields
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface FirewallFields
 */
export interface FirewallFields {
    /**
     * 
     * @type {string}
     * @memberof FirewallFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof FirewallFields
     */
    'description'?: string;
    /**
     * 
     * @type {FirewallEnvironmentFields}
     * @memberof FirewallFields
     */
    'environment'?: FirewallEnvironmentFields;
    /**
     * 
     * @type {number}
     * @memberof FirewallFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FirewallFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FirewallFields
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface FirewallResponse
 */
export interface FirewallResponse {
    /**
     * 
     * @type {FirewallFields}
     * @memberof FirewallResponse
     */
    'firewall'?: FirewallFields;
    /**
     * 
     * @type {string}
     * @memberof FirewallResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FirewallResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface FirewallRule
 */
export interface FirewallRule {
    /**
     * 
     * @type {SecurityGroupRuleFields}
     * @memberof FirewallRule
     */
    'firewall_rule'?: SecurityGroupRuleFields;
    /**
     * 
     * @type {string}
     * @memberof FirewallRule
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FirewallRule
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface FirewallsListResponse
 */
export interface FirewallsListResponse {
    /**
     * 
     * @type {number}
     * @memberof FirewallsListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {Array<FirewallDetailFields>}
     * @memberof FirewallsListResponse
     */
    'firewalls'?: Array<FirewallDetailFields>;
    /**
     * 
     * @type {string}
     * @memberof FirewallsListResponse
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof FirewallsListResponse
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof FirewallsListResponse
     */
    'page_size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FirewallsListResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface FlavorFields
 */
export interface FlavorFields {
    /**
     * 
     * @type {number}
     * @memberof FlavorFields
     */
    'cpu'?: number;
    /**
     * 
     * @type {string}
     * @memberof FlavorFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlavorFields
     */
    'disk'?: number;
    /**
     * 
     * @type {string}
     * @memberof FlavorFields
     */
    'display_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlavorFields
     */
    'ephemeral'?: number;
    /**
     * 
     * @type {object}
     * @memberof FlavorFields
     */
    'features'?: object;
    /**
     * 
     * @type {string}
     * @memberof FlavorFields
     */
    'gpu'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlavorFields
     */
    'gpu_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof FlavorFields
     */
    'id'?: number;
    /**
     * 
     * @type {Array<LableResonse>}
     * @memberof FlavorFields
     */
    'labels'?: Array<LableResonse>;
    /**
     * 
     * @type {string}
     * @memberof FlavorFields
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlavorFields
     */
    'ram'?: number;
    /**
     * 
     * @type {string}
     * @memberof FlavorFields
     */
    'region_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FlavorFields
     */
    'stock_available'?: boolean;
}
/**
 * 
 * @export
 * @interface FlavorItemGetResponse
 */
export interface FlavorItemGetResponse {
    /**
     * 
     * @type {Array<FlavorFields>}
     * @memberof FlavorItemGetResponse
     */
    'flavors'?: Array<FlavorFields>;
    /**
     * 
     * @type {string}
     * @memberof FlavorItemGetResponse
     */
    'gpu'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlavorItemGetResponse
     */
    'region_name'?: string;
}
/**
 * 
 * @export
 * @interface FlavorLabelFields
 */
export interface FlavorLabelFields {
    /**
     * 
     * @type {number}
     * @memberof FlavorLabelFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FlavorLabelFields
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface FlavorListResponse
 */
export interface FlavorListResponse {
    /**
     * 
     * @type {Array<FlavorItemGetResponse>}
     * @memberof FlavorListResponse
     */
    'data'?: Array<FlavorItemGetResponse>;
    /**
     * 
     * @type {string}
     * @memberof FlavorListResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FlavorListResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface FlavorObjectFields
 */
export interface FlavorObjectFields {
    /**
     * 
     * @type {number}
     * @memberof FlavorObjectFields
     */
    'cpu'?: number;
    /**
     * 
     * @type {number}
     * @memberof FlavorObjectFields
     */
    'disk'?: number;
    /**
     * 
     * @type {string}
     * @memberof FlavorObjectFields
     */
    'gpu'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlavorObjectFields
     */
    'gpu_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof FlavorObjectFields
     */
    'ram'?: number;
}
/**
 * 
 * @export
 * @interface GPUFields
 */
export interface GPUFields {
    /**
     * 
     * @type {string}
     * @memberof GPUFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GPUFields
     */
    'example_metadata'?: string;
    /**
     * 
     * @type {number}
     * @memberof GPUFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GPUFields
     */
    'name'?: string;
    /**
     * 
     * @type {Array<GPURegionFields>}
     * @memberof GPUFields
     */
    'regions'?: Array<GPURegionFields>;
    /**
     * 
     * @type {string}
     * @memberof GPUFields
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface GPUList
 */
export interface GPUList {
    /**
     * 
     * @type {Array<GPUFields>}
     * @memberof GPUList
     */
    'gpu_list'?: Array<GPUFields>;
    /**
     * 
     * @type {string}
     * @memberof GPUList
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GPUList
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GPURegionFields
 */
export interface GPURegionFields {
    /**
     * 
     * @type {number}
     * @memberof GPURegionFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GPURegionFields
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GenerateUpdateApiKeyPayload
 */
export interface GenerateUpdateApiKeyPayload {
    /**
     * 
     * @type {string}
     * @memberof GenerateUpdateApiKeyPayload
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerateUpdateApiKeyPayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GenerateUpdateApiKeyResponseModel
 */
export interface GenerateUpdateApiKeyResponseModel {
    /**
     * 
     * @type {ApiKeyFields}
     * @memberof GenerateUpdateApiKeyResponseModel
     */
    'api_key'?: ApiKeyFields;
    /**
     * 
     * @type {string}
     * @memberof GenerateUpdateApiKeyResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GenerateUpdateApiKeyResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetApiKeysResponseModel
 */
export interface GetApiKeysResponseModel {
    /**
     * 
     * @type {Array<ApiKeyFields>}
     * @memberof GetApiKeysResponseModel
     */
    'api_keys'?: Array<ApiKeyFields>;
    /**
     * 
     * @type {string}
     * @memberof GetApiKeysResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetApiKeysResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetCreditAndThresholdInfo
 */
export interface GetCreditAndThresholdInfo {
    /**
     * 
     * @type {boolean}
     * @memberof GetCreditAndThresholdInfo
     */
    'can_create_instance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetCreditAndThresholdInfo
     */
    'credit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetCreditAndThresholdInfo
     */
    'threshold'?: number;
}
/**
 * 
 * @export
 * @interface GetCreditAndThresholdInfoInResponse
 */
export interface GetCreditAndThresholdInfoInResponse {
    /**
     * 
     * @type {GetCreditAndThresholdInfo}
     * @memberof GetCreditAndThresholdInfoInResponse
     */
    'data'?: GetCreditAndThresholdInfo;
    /**
     * 
     * @type {string}
     * @memberof GetCreditAndThresholdInfoInResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetCreditAndThresholdInfoInResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetCustomerContractsListResponseModel
 */
export interface GetCustomerContractsListResponseModel {
    /**
     * 
     * @type {Array<CustomerContractFields>}
     * @memberof GetCustomerContractsListResponseModel
     */
    'contracts'?: Array<CustomerContractFields>;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerContractsListResponseModel
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerContractsListResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerContractsListResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetInstanceLogsResponse
 */
export interface GetInstanceLogsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetInstanceLogsResponse
     */
    'logs'?: string;
}
/**
 * 
 * @export
 * @interface GetInvitesResponseModel
 */
export interface GetInvitesResponseModel {
    /**
     * 
     * @type {Array<InviteFields>}
     * @memberof GetInvitesResponseModel
     */
    'invites'?: Array<InviteFields>;
    /**
     * 
     * @type {string}
     * @memberof GetInvitesResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetInvitesResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetOrganizationResponseModel
 */
export interface GetOrganizationResponseModel {
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {OrganizationFields}
     * @memberof GetOrganizationResponseModel
     */
    'organization'?: OrganizationFields;
    /**
     * 
     * @type {boolean}
     * @memberof GetOrganizationResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetPermissionsResponseModel
 */
export interface GetPermissionsResponseModel {
    /**
     * 
     * @type {string}
     * @memberof GetPermissionsResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PermissionFields>}
     * @memberof GetPermissionsResponseModel
     */
    'permissions'?: Array<PermissionFields>;
    /**
     * 
     * @type {boolean}
     * @memberof GetPermissionsResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetPoliciesResponseModel
 */
export interface GetPoliciesResponseModel {
    /**
     * 
     * @type {string}
     * @memberof GetPoliciesResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PolicyFields>}
     * @memberof GetPoliciesResponseModel
     */
    'policies'?: Array<PolicyFields>;
    /**
     * 
     * @type {boolean}
     * @memberof GetPoliciesResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetRbacRolesResponseModel
 */
export interface GetRbacRolesResponseModel {
    /**
     * 
     * @type {string}
     * @memberof GetRbacRolesResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {Array<RbacRoleFields>}
     * @memberof GetRbacRolesResponseModel
     */
    'roles'?: Array<RbacRoleFields>;
    /**
     * 
     * @type {boolean}
     * @memberof GetRbacRolesResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetUserPermissionsResponseModel
 */
export interface GetUserPermissionsResponseModel {
    /**
     * 
     * @type {string}
     * @memberof GetUserPermissionsResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {Array<UserPermissionFields>}
     * @memberof GetUserPermissionsResponseModel
     */
    'permissions'?: Array<UserPermissionFields>;
    /**
     * 
     * @type {boolean}
     * @memberof GetUserPermissionsResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GraphDatetimeValueModel
 */
export interface GraphDatetimeValueModel {
    /**
     * 
     * @type {string}
     * @memberof GraphDatetimeValueModel
     */
    'datetime'?: string;
    /**
     * 
     * @type {number}
     * @memberof GraphDatetimeValueModel
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {ImageFields}
     * @memberof Image
     */
    'image'?: ImageFields;
}
/**
 * 
 * @export
 * @interface ImageFields
 */
export interface ImageFields {
    /**
     * 
     * @type {string}
     * @memberof ImageFields
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageFields
     */
    'display_size'?: string;
    /**
     * 
     * @type {number}
     * @memberof ImageFields
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ImageFields
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {Array<LableResonse>}
     * @memberof ImageFields
     */
    'labels'?: Array<LableResonse>;
    /**
     * 
     * @type {string}
     * @memberof ImageFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageFields
     */
    'region_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ImageFields
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImageFields
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageFields
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ImageGetResponse
 */
export interface ImageGetResponse {
    /**
     * 
     * @type {Array<ImageFields>}
     * @memberof ImageGetResponse
     */
    'images'?: Array<ImageFields>;
    /**
     * 
     * @type {string}
     * @memberof ImageGetResponse
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGetResponse
     */
    'region_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageGetResponse
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Images
 */
export interface Images {
    /**
     * 
     * @type {Array<ImageGetResponse>}
     * @memberof Images
     */
    'images'?: Array<ImageGetResponse>;
    /**
     * 
     * @type {string}
     * @memberof Images
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Images
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ImportKeypairPayload
 */
export interface ImportKeypairPayload {
    /**
     * The name of the environment where the key pair is being created.
     * @type {string}
     * @memberof ImportKeypairPayload
     */
    'environment_name': string;
    /**
     * The name of the key pair that is being created.
     * @type {string}
     * @memberof ImportKeypairPayload
     */
    'name': string;
    /**
     * The public key that is being used to import an SSH key pair.
     * @type {string}
     * @memberof ImportKeypairPayload
     */
    'public_key': string;
}
/**
 * 
 * @export
 * @interface ImportKeypairResponse
 */
export interface ImportKeypairResponse {
    /**
     * 
     * @type {KeypairFields}
     * @memberof ImportKeypairResponse
     */
    'keypair'?: KeypairFields;
    /**
     * 
     * @type {string}
     * @memberof ImportKeypairResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportKeypairResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface InfrahubResourceObjectResponseForCustomer
 */
export interface InfrahubResourceObjectResponseForCustomer {
    /**
     * 
     * @type {number}
     * @memberof InfrahubResourceObjectResponseForCustomer
     */
    'actual_price'?: number;
    /**
     * 
     * @type {string}
     * @memberof InfrahubResourceObjectResponseForCustomer
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof InfrahubResourceObjectResponseForCustomer
     */
    'infrahub_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof InfrahubResourceObjectResponseForCustomer
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof InfrahubResourceObjectResponseForCustomer
     */
    'price'?: number;
    /**
     * 
     * @type {Array<PricebookResourceObjectResponseForCustomer>}
     * @memberof InfrahubResourceObjectResponseForCustomer
     */
    'resources'?: Array<PricebookResourceObjectResponseForCustomer>;
    /**
     * 
     * @type {string}
     * @memberof InfrahubResourceObjectResponseForCustomer
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfrahubResourceObjectResponseForCustomer
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Instance
 */
export interface Instance {
    /**
     * 
     * @type {InstanceFields}
     * @memberof Instance
     */
    'instance'?: InstanceFields;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Instance
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface InstanceEnvironmentFields
 */
export interface InstanceEnvironmentFields {
    /**
     * 
     * @type {EnvironmentFeatures}
     * @memberof InstanceEnvironmentFields
     */
    'features'?: EnvironmentFeatures;
    /**
     * 
     * @type {number}
     * @memberof InstanceEnvironmentFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof InstanceEnvironmentFields
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceEnvironmentFields
     */
    'org_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof InstanceEnvironmentFields
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface InstanceEvents
 */
export interface InstanceEvents {
    /**
     * 
     * @type {Array<InstanceEventsFields>}
     * @memberof InstanceEvents
     */
    'instance_events'?: Array<InstanceEventsFields>;
    /**
     * 
     * @type {string}
     * @memberof InstanceEvents
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceEvents
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface InstanceEventsFields
 */
export interface InstanceEventsFields {
    /**
     * 
     * @type {number}
     * @memberof InstanceEventsFields
     */
    'instance_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof InstanceEventsFields
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceEventsFields
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceEventsFields
     */
    'org_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof InstanceEventsFields
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceEventsFields
     */
    'time'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceEventsFields
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceEventsFields
     */
    'user_id'?: number;
}
/**
 * 
 * @export
 * @interface InstanceFields
 */
export interface InstanceFields {
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'callback_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceFields
     */
    'contract_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {InstanceEnvironmentFields}
     * @memberof InstanceFields
     */
    'environment'?: InstanceEnvironmentFields;
    /**
     * 
     * @type {object}
     * @memberof InstanceFields
     */
    'features'?: object;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'fixed_ip'?: string;
    /**
     * 
     * @type {InstanceFlavorFields}
     * @memberof InstanceFields
     */
    'flavor'?: InstanceFlavorFields;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'floating_ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'floating_ip_status'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceFields
     */
    'id'?: number;
    /**
     * 
     * @type {InstanceImageFields}
     * @memberof InstanceFields
     */
    'image'?: InstanceImageFields;
    /**
     * 
     * @type {InstanceKeypairFields}
     * @memberof InstanceFields
     */
    'keypair'?: InstanceKeypairFields;
    /**
     * 
     * @type {Array<string>}
     * @memberof InstanceFields
     */
    'labels'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceFields
     */
    'locked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'os'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceFields
     */
    'port_randomization'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'port_randomization_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'power_state'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceFields
     */
    'requires_public_ip'?: boolean;
    /**
     * 
     * @type {Array<SecurityRulesFieldsForInstance>}
     * @memberof InstanceFields
     */
    'security_rules'?: Array<SecurityRulesFieldsForInstance>;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceFields
     */
    'vm_state'?: string;
    /**
     * 
     * @type {Array<VolumeAttachmentFields>}
     * @memberof InstanceFields
     */
    'volume_attachments'?: Array<VolumeAttachmentFields>;
}
/**
 * 
 * @export
 * @interface InstanceFlavorFields
 */
export interface InstanceFlavorFields {
    /**
     * 
     * @type {number}
     * @memberof InstanceFlavorFields
     */
    'cpu'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFlavorFields
     */
    'disk'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFlavorFields
     */
    'ephemeral'?: number;
    /**
     * 
     * @type {object}
     * @memberof InstanceFlavorFields
     */
    'features'?: object;
    /**
     * 
     * @type {string}
     * @memberof InstanceFlavorFields
     */
    'gpu'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceFlavorFields
     */
    'gpu_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFlavorFields
     */
    'id'?: number;
    /**
     * 
     * @type {Array<FlavorLabelFields>}
     * @memberof InstanceFlavorFields
     */
    'labels'?: Array<FlavorLabelFields>;
    /**
     * 
     * @type {string}
     * @memberof InstanceFlavorFields
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceFlavorFields
     */
    'ram'?: number;
}
/**
 * 
 * @export
 * @interface InstanceImageFields
 */
export interface InstanceImageFields {
    /**
     * 
     * @type {string}
     * @memberof InstanceImageFields
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface InstanceKeypairFields
 */
export interface InstanceKeypairFields {
    /**
     * 
     * @type {string}
     * @memberof InstanceKeypairFields
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface InstanceOverviewFields
 */
export interface InstanceOverviewFields {
    /**
     * 
     * @type {number}
     * @memberof InstanceOverviewFields
     */
    'cost_per_hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceOverviewFields
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceOverviewFields
     */
    'gpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceOverviewFields
     */
    'ram'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceOverviewFields
     */
    'vcpus'?: number;
}
/**
 * 
 * @export
 * @interface InstanceResizePayload
 */
export interface InstanceResizePayload {
    /**
     * 
     * @type {FlavorObjectFields}
     * @memberof InstanceResizePayload
     */
    'flavor'?: FlavorObjectFields;
    /**
     * 
     * @type {string}
     * @memberof InstanceResizePayload
     */
    'flavor_name'?: string;
}
/**
 * 
 * @export
 * @interface Instances
 */
export interface Instances {
    /**
     * 
     * @type {number}
     * @memberof Instances
     */
    'count'?: number;
    /**
     * 
     * @type {Array<InstanceFields>}
     * @memberof Instances
     */
    'instances'?: Array<InstanceFields>;
    /**
     * 
     * @type {string}
     * @memberof Instances
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof Instances
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Instances
     */
    'page_size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Instances
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface InviteFields
 */
export interface InviteFields {
    /**
     * 
     * @type {string}
     * @memberof InviteFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteFields
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteFields
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface InviteUserPayload
 */
export interface InviteUserPayload {
    /**
     * The email for sending invitation.
     * @type {string}
     * @memberof InviteUserPayload
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface InviteUserResponseModel
 */
export interface InviteUserResponseModel {
    /**
     * 
     * @type {InviteFields}
     * @memberof InviteUserResponseModel
     */
    'invite'?: InviteFields;
    /**
     * 
     * @type {string}
     * @memberof InviteUserResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InviteUserResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface KeypairEnvironmentFeatures
 */
export interface KeypairEnvironmentFeatures {
    /**
     * 
     * @type {string}
     * @memberof KeypairEnvironmentFeatures
     */
    'green_status'?: KeypairEnvironmentFeaturesGreenStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof KeypairEnvironmentFeatures
     */
    'network_optimised'?: boolean;
}

export const KeypairEnvironmentFeaturesGreenStatusEnum = {
    Green: 'GREEN',
    PartiallyGreen: 'PARTIALLY_GREEN',
    NotGreen: 'NOT_GREEN'
} as const;

export type KeypairEnvironmentFeaturesGreenStatusEnum = typeof KeypairEnvironmentFeaturesGreenStatusEnum[keyof typeof KeypairEnvironmentFeaturesGreenStatusEnum];

/**
 * 
 * @export
 * @interface KeypairEnvironmentFields
 */
export interface KeypairEnvironmentFields {
    /**
     * 
     * @type {string}
     * @memberof KeypairEnvironmentFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {KeypairEnvironmentFeatures}
     * @memberof KeypairEnvironmentFields
     */
    'features'?: KeypairEnvironmentFeatures;
    /**
     * 
     * @type {number}
     * @memberof KeypairEnvironmentFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof KeypairEnvironmentFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeypairEnvironmentFields
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface KeypairFields
 */
export interface KeypairFields {
    /**
     * 
     * @type {string}
     * @memberof KeypairFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {KeypairEnvironmentFields}
     * @memberof KeypairFields
     */
    'environment'?: KeypairEnvironmentFields;
    /**
     * 
     * @type {string}
     * @memberof KeypairFields
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {number}
     * @memberof KeypairFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof KeypairFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeypairFields
     */
    'public_key'?: string;
}
/**
 * 
 * @export
 * @interface Keypairs
 */
export interface Keypairs {
    /**
     * 
     * @type {number}
     * @memberof Keypairs
     */
    'count'?: number;
    /**
     * 
     * @type {Array<KeypairFields>}
     * @memberof Keypairs
     */
    'keypairs'?: Array<KeypairFields>;
    /**
     * 
     * @type {string}
     * @memberof Keypairs
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof Keypairs
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Keypairs
     */
    'page_size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Keypairs
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface LableResonse
 */
export interface LableResonse {
    /**
     * 
     * @type {number}
     * @memberof LableResonse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LableResonse
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface LastDayCostFields
 */
export interface LastDayCostFields {
    /**
     * 
     * @type {number}
     * @memberof LastDayCostFields
     */
    'clusters_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof LastDayCostFields
     */
    'instances_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof LastDayCostFields
     */
    'total_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof LastDayCostFields
     */
    'volumes_cost'?: number;
}
/**
 * 
 * @export
 * @interface LastDayCostResponse
 */
export interface LastDayCostResponse {
    /**
     * 
     * @type {LastDayCostFields}
     * @memberof LastDayCostResponse
     */
    'data'?: LastDayCostFields;
    /**
     * 
     * @type {string}
     * @memberof LastDayCostResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LastDayCostResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface Logos
 */
export interface Logos {
    /**
     * 
     * @type {string}
     * @memberof Logos
     */
    'dark'?: string;
    /**
     * 
     * @type {string}
     * @memberof Logos
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Logos
     */
    'favicon'?: string;
    /**
     * 
     * @type {string}
     * @memberof Logos
     */
    'light'?: string;
}
/**
 * 
 * @export
 * @interface MFAStatusFields
 */
export interface MFAStatusFields {
    /**
     * Whether MFA is enabled for the user
     * @type {boolean}
     * @memberof MFAStatusFields
     */
    'mfa_enabled': boolean;
}
/**
 * 
 * @export
 * @interface MFAStatusResponse
 */
export interface MFAStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof MFAStatusResponse
     */
    'message'?: string;
    /**
     * 
     * @type {MFAStatusFields}
     * @memberof MFAStatusResponse
     */
    'mfa'?: MFAStatusFields;
    /**
     * 
     * @type {boolean}
     * @memberof MFAStatusResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ManualReconciliationModel
 */
export interface ManualReconciliationModel {
    /**
     * 
     * @type {ClusterFields}
     * @memberof ManualReconciliationModel
     */
    'cluster'?: ClusterFields;
    /**
     * 
     * @type {string}
     * @memberof ManualReconciliationModel
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManualReconciliationModel
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface MasterFlavorsResponse
 */
export interface MasterFlavorsResponse {
    /**
     * 
     * @type {Array<ClusterFlavorFields>}
     * @memberof MasterFlavorsResponse
     */
    'flavors'?: Array<ClusterFlavorFields>;
    /**
     * 
     * @type {string}
     * @memberof MasterFlavorsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MasterFlavorsResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface MetricItemFields
 */
export interface MetricItemFields {
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricItemFields
     */
    'columns'?: Array<string>;
    /**
     * 
     * @type {Array<Array<object>>}
     * @memberof MetricItemFields
     */
    'data'?: Array<Array<object>>;
    /**
     * 
     * @type {string}
     * @memberof MetricItemFields
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface MetricsFields
 */
export interface MetricsFields {
    /**
     * 
     * @type {MetricItemFields}
     * @memberof MetricsFields
     */
    'cpu'?: MetricItemFields;
    /**
     * 
     * @type {MetricItemFields}
     * @memberof MetricsFields
     */
    'disk.read'?: MetricItemFields;
    /**
     * 
     * @type {MetricItemFields}
     * @memberof MetricsFields
     */
    'disk.write'?: MetricItemFields;
    /**
     * 
     * @type {MetricItemFields}
     * @memberof MetricsFields
     */
    'memory.usages'?: MetricItemFields;
    /**
     * 
     * @type {MetricItemFields}
     * @memberof MetricsFields
     */
    'network.in'?: MetricItemFields;
    /**
     * 
     * @type {MetricItemFields}
     * @memberof MetricsFields
     */
    'network.out'?: MetricItemFields;
}
/**
 * 
 * @export
 * @interface ModelEvaluationBillingHistoryDetailsResponseSchema
 */
export interface ModelEvaluationBillingHistoryDetailsResponseSchema {
    /**
     * 
     * @type {BillingHistoryModelEvalutationDetails}
     * @memberof ModelEvaluationBillingHistoryDetailsResponseSchema
     */
    'billing_history_model_evalutation_details'?: BillingHistoryModelEvalutationDetails;
    /**
     * 
     * @type {string}
     * @memberof ModelEvaluationBillingHistoryDetailsResponseSchema
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelEvaluationBillingHistoryDetailsResponseSchema
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface NameAvailableModel
 */
export interface NameAvailableModel {
    /**
     * 
     * @type {boolean}
     * @memberof NameAvailableModel
     */
    'available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NameAvailableModel
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof NameAvailableModel
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface NewConfigurationsResponse
 */
export interface NewConfigurationsResponse {
    /**
     * 
     * @type {number}
     * @memberof NewConfigurationsResponse
     */
    '10x'?: number;
    /**
     * 
     * @type {number}
     * @memberof NewConfigurationsResponse
     */
    '1x'?: number;
    /**
     * 
     * @type {number}
     * @memberof NewConfigurationsResponse
     */
    '2x'?: number;
    /**
     * 
     * @type {number}
     * @memberof NewConfigurationsResponse
     */
    '4x'?: number;
    /**
     * 
     * @type {number}
     * @memberof NewConfigurationsResponse
     */
    '8x'?: number;
}
/**
 * 
 * @export
 * @interface NewModelResponse
 */
export interface NewModelResponse {
    /**
     * 
     * @type {string}
     * @memberof NewModelResponse
     */
    'available'?: string;
    /**
     * 
     * @type {NewConfigurationsResponse}
     * @memberof NewModelResponse
     */
    'configurations'?: NewConfigurationsResponse;
    /**
     * 
     * @type {string}
     * @memberof NewModelResponse
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewModelResponse
     */
    'planned_100_days'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewModelResponse
     */
    'planned_30_days'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewModelResponse
     */
    'planned_7_days'?: string;
}
/**
 * 
 * @export
 * @interface NewStockResponse
 */
export interface NewStockResponse {
    /**
     * 
     * @type {Array<NewModelResponse>}
     * @memberof NewStockResponse
     */
    'models'?: Array<NewModelResponse>;
    /**
     * 
     * @type {string}
     * @memberof NewStockResponse
     */
    'region'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewStockResponse
     */
    'stock-type'?: string;
}
/**
 * 
 * @export
 * @interface NewStockRetriveResponse
 */
export interface NewStockRetriveResponse {
    /**
     * 
     * @type {Array<NewStockResponse>}
     * @memberof NewStockRetriveResponse
     */
    'stocks'?: Array<NewStockResponse>;
}
/**
 * 
 * @export
 * @interface OrganizationFields
 */
export interface OrganizationFields {
    /**
     * 
     * @type {string}
     * @memberof OrganizationFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationFields
     */
    'credit'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationFields
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationFields
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationFields
     */
    'threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationFields
     */
    'total_clusters'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationFields
     */
    'total_containers'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationFields
     */
    'total_instances'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationFields
     */
    'total_volumes'?: number;
    /**
     * 
     * @type {Array<OrganizationUserResponseModel>}
     * @memberof OrganizationFields
     */
    'users'?: Array<OrganizationUserResponseModel>;
}
/**
 * 
 * @export
 * @interface OrganizationLevelBillingHistory
 */
export interface OrganizationLevelBillingHistory {
    /**
     * 
     * @type {Array<OrganizationLevelBillingHistoryResources>}
     * @memberof OrganizationLevelBillingHistory
     */
    'billing_history'?: Array<OrganizationLevelBillingHistoryResources>;
    /**
     * 
     * @type {number}
     * @memberof OrganizationLevelBillingHistory
     */
    'org_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationLevelBillingHistory
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface OrganizationLevelBillingHistoryResources
 */
export interface OrganizationLevelBillingHistoryResources {
    /**
     * 
     * @type {OrganizationLevelBillingHistoryResponseAttributes}
     * @memberof OrganizationLevelBillingHistoryResources
     */
    'attributes'?: OrganizationLevelBillingHistoryResponseAttributes;
    /**
     * 
     * @type {OrganizationLevelBillingHistoryResponseMetrics}
     * @memberof OrganizationLevelBillingHistoryResources
     */
    'metrics'?: OrganizationLevelBillingHistoryResponseMetrics;
}
/**
 * 
 * @export
 * @interface OrganizationLevelBillingHistoryResponseAttributes
 */
export interface OrganizationLevelBillingHistoryResponseAttributes {
    /**
     * 
     * @type {string}
     * @memberof OrganizationLevelBillingHistoryResponseAttributes
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationLevelBillingHistoryResponseMetrics
 */
export interface OrganizationLevelBillingHistoryResponseMetrics {
    /**
     * 
     * @type {number}
     * @memberof OrganizationLevelBillingHistoryResponseMetrics
     */
    'contract_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationLevelBillingHistoryResponseMetrics
     */
    'incurred_bill'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationLevelBillingHistoryResponseMetrics
     */
    'non_discounted_bill'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationLevelBillingHistoryResponseMetrics
     */
    'snapshot_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationLevelBillingHistoryResponseMetrics
     */
    'vm_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationLevelBillingHistoryResponseMetrics
     */
    'volume_cost'?: number;
}
/**
 * 
 * @export
 * @interface OrganizationLevelBillingHistoryResponseModel
 */
export interface OrganizationLevelBillingHistoryResponseModel {
    /**
     * 
     * @type {OrganizationLevelBillingHistory}
     * @memberof OrganizationLevelBillingHistoryResponseModel
     */
    'billing_history'?: OrganizationLevelBillingHistory;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLevelBillingHistoryResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationLevelBillingHistoryResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface OrganizationThresholdFields
 */
export interface OrganizationThresholdFields {
    /**
     * 
     * @type {number}
     * @memberof OrganizationThresholdFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationThresholdFields
     */
    'interface_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationThresholdFields
     */
    'interface_tooltip'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationThresholdFields
     */
    'subscribed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrganizationThresholdFields
     */
    'threshold'?: number;
}
/**
 * 
 * @export
 * @interface OrganizationThresholdUpdateResponse
 */
export interface OrganizationThresholdUpdateResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationThresholdUpdateResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationThresholdUpdateResponse
     */
    'status'?: boolean;
    /**
     * 
     * @type {OrganizationThresholdFields}
     * @memberof OrganizationThresholdUpdateResponse
     */
    'threshold'?: OrganizationThresholdFields;
}
/**
 * 
 * @export
 * @interface OrganizationThresholdsResponse
 */
export interface OrganizationThresholdsResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationThresholdsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationThresholdsResponse
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<OrganizationThresholdFields>}
     * @memberof OrganizationThresholdsResponse
     */
    'thresholds'?: Array<OrganizationThresholdFields>;
}
/**
 * 
 * @export
 * @interface OrganizationUserResponseModel
 */
export interface OrganizationUserResponseModel {
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserResponseModel
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUserResponseModel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserResponseModel
     */
    'joined_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserResponseModel
     */
    'last_login'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserResponseModel
     */
    'name'?: string;
    /**
     * 
     * @type {Array<RbacRoleField>}
     * @memberof OrganizationUserResponseModel
     */
    'rbac_roles'?: Array<RbacRoleField>;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserResponseModel
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserResponseModel
     */
    'sub'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserResponseModel
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface OverviewInfo
 */
export interface OverviewInfo {
    /**
     * 
     * @type {ContainerOverviewFields}
     * @memberof OverviewInfo
     */
    'container'?: ContainerOverviewFields;
    /**
     * 
     * @type {InstanceOverviewFields}
     * @memberof OverviewInfo
     */
    'instance'?: InstanceOverviewFields;
    /**
     * 
     * @type {VolumeOverviewFields}
     * @memberof OverviewInfo
     */
    'volume'?: VolumeOverviewFields;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'per_page'?: number;
}
/**
 * 
 * @export
 * @interface PaginationData
 */
export interface PaginationData {
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'per_page'?: number;
}
/**
 * 
 * @export
 * @interface PartnerConfig
 */
export interface PartnerConfig {
    /**
     * 
     * @type {string}
     * @memberof PartnerConfig
     */
    'background_image_url'?: string;
    /**
     * 
     * @type {Colors}
     * @memberof PartnerConfig
     */
    'colors'?: Colors;
    /**
     * 
     * @type {Logos}
     * @memberof PartnerConfig
     */
    'logos'?: Logos;
    /**
     * 
     * @type {string}
     * @memberof PartnerConfig
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerConfig
     */
    'support_email'?: string;
    /**
     * 
     * @type {URIs}
     * @memberof PartnerConfig
     */
    'uris'?: URIs;
    /**
     * 
     * @type {string}
     * @memberof PartnerConfig
     */
    'user_type': string;
}
/**
 * 
 * @export
 * @interface PaymentDetailsFields
 */
export interface PaymentDetailsFields {
    /**
     * 
     * @type {number}
     * @memberof PaymentDetailsFields
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'gateway_response'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'invoice'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'paid_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'payment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentDetailsFields
     */
    'tax_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'transaction_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsFields
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PaymentDetailsResponse
 */
export interface PaymentDetailsResponse {
    /**
     * 
     * @type {PaymentDetailsFields}
     * @memberof PaymentDetailsResponse
     */
    'data'?: PaymentDetailsFields;
    /**
     * 
     * @type {string}
     * @memberof PaymentDetailsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentDetailsResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentInitiateFields
 */
export interface PaymentInitiateFields {
    /**
     * 
     * @type {string}
     * @memberof PaymentInitiateFields
     */
    'payment_id'?: string;
}
/**
 * 
 * @export
 * @interface PaymentInitiatePayload
 */
export interface PaymentInitiatePayload {
    /**
     * 
     * @type {number}
     * @memberof PaymentInitiatePayload
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface PaymentInitiateResponse
 */
export interface PaymentInitiateResponse {
    /**
     * 
     * @type {PaymentInitiateFields}
     * @memberof PaymentInitiateResponse
     */
    'data'?: PaymentInitiateFields;
    /**
     * 
     * @type {string}
     * @memberof PaymentInitiateResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentInitiateResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface PermissionFields
 */
export interface PermissionFields {
    /**
     * 
     * @type {string}
     * @memberof PermissionFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionFields
     */
    'endpoint'?: string;
    /**
     * 
     * @type {number}
     * @memberof PermissionFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PermissionFields
     */
    'method'?: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionFields
     */
    'permission'?: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionFields
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface PolicyFields
 */
export interface PolicyFields {
    /**
     * 
     * @type {string}
     * @memberof PolicyFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PolicyFields
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PolicyFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PolicyFields
     */
    'name'?: string;
    /**
     * 
     * @type {Array<PolicyPermissionFields>}
     * @memberof PolicyFields
     */
    'permissions'?: Array<PolicyPermissionFields>;
}
/**
 * 
 * @export
 * @interface PolicyPermissionFields
 */
export interface PolicyPermissionFields {
    /**
     * 
     * @type {number}
     * @memberof PolicyPermissionFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PolicyPermissionFields
     */
    'permission'?: string;
    /**
     * 
     * @type {string}
     * @memberof PolicyPermissionFields
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface PricebookModel
 */
export interface PricebookModel {
    /**
     * 
     * @type {boolean}
     * @memberof PricebookModel
     */
    'discount_applied'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PricebookModel
     */
    'end_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof PricebookModel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PricebookModel
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PricebookModel
     */
    'original_value'?: number;
    /**
     * 
     * @type {string}
     * @memberof PricebookModel
     */
    'start_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof PricebookModel
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface PricebookResourceObjectResponseForCustomer
 */
export interface PricebookResourceObjectResponseForCustomer {
    /**
     * 
     * @type {number}
     * @memberof PricebookResourceObjectResponseForCustomer
     */
    'actual_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof PricebookResourceObjectResponseForCustomer
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PricebookResourceObjectResponseForCustomer
     */
    'discounted_rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof PricebookResourceObjectResponseForCustomer
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PricebookResourceObjectResponseForCustomer
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof PricebookResourceObjectResponseForCustomer
     */
    'rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof PricebookResourceObjectResponseForCustomer
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PrimaryColor
 */
export interface PrimaryColor {
    /**
     * 
     * @type {string}
     * @memberof PrimaryColor
     */
    'dark'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryColor
     */
    'light'?: string;
}
/**
 * 
 * @export
 * @interface ProfileFields
 */
export interface ProfileFields {
    /**
     * 
     * @type {string}
     * @memberof ProfileFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileFields
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileFields
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProfileFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileFields
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ProfileListResponse
 */
export interface ProfileListResponse {
    /**
     * 
     * @type {string}
     * @memberof ProfileListResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProfileFields>}
     * @memberof ProfileListResponse
     */
    'profiles'?: Array<ProfileFields>;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileListResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ProfileObjectFields
 */
export interface ProfileObjectFields {
    /**
     * 
     * @type {string}
     * @memberof ProfileObjectFields
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileObjectFields
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface RbacRoleDetailResponseModel
 */
export interface RbacRoleDetailResponseModel {
    /**
     * 
     * @type {string}
     * @memberof RbacRoleDetailResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {RbacRoleFields}
     * @memberof RbacRoleDetailResponseModel
     */
    'role'?: RbacRoleFields;
    /**
     * 
     * @type {boolean}
     * @memberof RbacRoleDetailResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface RbacRoleDetailResponseModelFixed
 */
export interface RbacRoleDetailResponseModelFixed {
    /**
     * 
     * @type {string}
     * @memberof RbacRoleDetailResponseModelFixed
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RbacRoleDetailResponseModelFixed
     */
    'status'?: boolean;
    /**
     * 
     * @type {RbacRoleFields}
     * @memberof RbacRoleDetailResponseModelFixed
     */
    'roles'?: RbacRoleFields;
}
/**
 * 
 * @export
 * @interface RbacRoleField
 */
export interface RbacRoleField {
    /**
     * 
     * @type {string}
     * @memberof RbacRoleField
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RbacRoleFields
 */
export interface RbacRoleFields {
    /**
     * 
     * @type {string}
     * @memberof RbacRoleFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RbacRoleFields
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof RbacRoleFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RbacRoleFields
     */
    'name'?: string;
    /**
     * 
     * @type {Array<RolePermissionFields>}
     * @memberof RbacRoleFields
     */
    'permissions'?: Array<RolePermissionFields>;
    /**
     * 
     * @type {Array<RolePolicyFields>}
     * @memberof RbacRoleFields
     */
    'policies'?: Array<RolePolicyFields>;
}
/**
 * 
 * @export
 * @interface RedeemVoucherPayload
 */
export interface RedeemVoucherPayload {
    /**
     * The code of the voucher you want to redeem.
     * @type {string}
     * @memberof RedeemVoucherPayload
     */
    'voucher_code': string;
}
/**
 * 
 * @export
 * @interface RegionFields
 */
export interface RegionFields {
    /**
     * 
     * @type {string}
     * @memberof RegionFields
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegionFields
     */
    'description'?: string;
    /**
     * Green status
     * @type {string}
     * @memberof RegionFields
     */
    'green_status'?: RegionFieldsGreenStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof RegionFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RegionFields
     */
    'name'?: string;
}

export const RegionFieldsGreenStatusEnum = {
    Green: 'GREEN',
    PartiallyGreen: 'PARTIALLY_GREEN',
    NotGreen: 'NOT_GREEN'
} as const;

export type RegionFieldsGreenStatusEnum = typeof RegionFieldsGreenStatusEnum[keyof typeof RegionFieldsGreenStatusEnum];

/**
 * 
 * @export
 * @interface Regions
 */
export interface Regions {
    /**
     * 
     * @type {string}
     * @memberof Regions
     */
    'message'?: string;
    /**
     * 
     * @type {Array<RegionFields>}
     * @memberof Regions
     */
    'regions'?: Array<RegionFields>;
    /**
     * 
     * @type {boolean}
     * @memberof Regions
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface RemoveMemberFromOrganizationResponseModel
 */
export interface RemoveMemberFromOrganizationResponseModel {
    /**
     * 
     * @type {string}
     * @memberof RemoveMemberFromOrganizationResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RemoveMemberFromOrganizationResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface RemoveMemberPayload
 */
export interface RemoveMemberPayload {
    /**
     * The email of the user to be removed.
     * @type {string}
     * @memberof RemoveMemberPayload
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface RequestConsole
 */
export interface RequestConsole {
    /**
     * 
     * @type {string}
     * @memberof RequestConsole
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RequestConsole
     */
    'status'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RequestConsole
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface RequestInstanceLogsPayload
 */
export interface RequestInstanceLogsPayload {
    /**
     * The amount of lines to fetch
     * @type {number}
     * @memberof RequestInstanceLogsPayload
     */
    'length'?: number;
}
/**
 * 
 * @export
 * @interface RequestInstanceLogsResponse
 */
export interface RequestInstanceLogsResponse {
    /**
     * 
     * @type {number}
     * @memberof RequestInstanceLogsResponse
     */
    'request_id'?: number;
}
/**
 * 
 * @export
 * @interface ResourceBillingEventsHistoryMetrics
 */
export interface ResourceBillingEventsHistoryMetrics {
    /**
     * 
     * @type {string}
     * @memberof ResourceBillingEventsHistoryMetrics
     */
    'event'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceBillingEventsHistoryMetrics
     */
    'event_duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceBillingEventsHistoryMetrics
     */
    'price_per_hour'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceBillingEventsHistoryMetrics
     */
    'start'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceBillingEventsHistoryMetrics
     */
    'total_cost'?: number;
}
/**
 * 
 * @export
 * @interface ResourceBillingEventsHistoryResponse
 */
export interface ResourceBillingEventsHistoryResponse {
    /**
     * 
     * @type {Array<ResourceBillingEventsHistoryMetrics>}
     * @memberof ResourceBillingEventsHistoryResponse
     */
    'billing_events_history'?: Array<ResourceBillingEventsHistoryMetrics>;
    /**
     * 
     * @type {string}
     * @memberof ResourceBillingEventsHistoryResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceBillingEventsHistoryResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceBillingResponseForCustomer
 */
export interface ResourceBillingResponseForCustomer {
    /**
     * 
     * @type {ResourceObjectResponseForCustomer}
     * @memberof ResourceBillingResponseForCustomer
     */
    'calculated_resource_bills'?: ResourceObjectResponseForCustomer;
    /**
     * 
     * @type {string}
     * @memberof ResourceBillingResponseForCustomer
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceBillingResponseForCustomer
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingBucketDetailsResources
 */
export interface ResourceLevelBillingBucketDetailsResources {
    /**
     * 
     * @type {ResourceLevelBillingDetailsAttributes}
     * @memberof ResourceLevelBillingBucketDetailsResources
     */
    'attributes'?: ResourceLevelBillingDetailsAttributes;
    /**
     * 
     * @type {ResourceLevelBillingDetailsMetrics}
     * @memberof ResourceLevelBillingBucketDetailsResources
     */
    'metrics'?: ResourceLevelBillingDetailsMetrics;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingDetailsAttributes
 */
export interface ResourceLevelBillingDetailsAttributes {
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBillingDetailsAttributes
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsAttributes
     */
    'infrahub_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBillingDetailsAttributes
     */
    'resource_name'?: string;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingDetailsMetrics
 */
export interface ResourceLevelBillingDetailsMetrics {
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsMetrics
     */
    'incurred_bill'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsMetrics
     */
    'non_discounted_bill'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsMetrics
     */
    'non_discounted_price_per_hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsMetrics
     */
    'price_per_hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsMetrics
     */
    'usage_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsMetrics
     */
    'usage_time_ACTIVE'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsMetrics
     */
    'usage_time_HIBERNATED'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsMetrics
     */
    'usage_time_SHUTOFF'?: number;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingDetailsVM
 */
export interface ResourceLevelBillingDetailsVM {
    /**
     * 
     * @type {Array<ResourceLevelBillingVMDetailsResources>}
     * @memberof ResourceLevelBillingDetailsVM
     */
    'billing_history'?: Array<ResourceLevelBillingVMDetailsResources>;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVM
     */
    'org_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVM
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingDetailsVolume
 */
export interface ResourceLevelBillingDetailsVolume {
    /**
     * 
     * @type {Array<ResourceLevelBillingVolumeDetailsResources>}
     * @memberof ResourceLevelBillingDetailsVolume
     */
    'billing_history'?: Array<ResourceLevelBillingVolumeDetailsResources>;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVolume
     */
    'org_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVolume
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingDetailsVolumeAttributes
 */
export interface ResourceLevelBillingDetailsVolumeAttributes {
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBillingDetailsVolumeAttributes
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVolumeAttributes
     */
    'infrahub_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBillingDetailsVolumeAttributes
     */
    'resource_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVolumeAttributes
     */
    'subresource_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBillingDetailsVolumeAttributes
     */
    'subresource_type'?: string;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingDetailsVolumeMetrics
 */
export interface ResourceLevelBillingDetailsVolumeMetrics {
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVolumeMetrics
     */
    'incurred_bill'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVolumeMetrics
     */
    'non_discounted_bill'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVolumeMetrics
     */
    'non_discounted_price_per_hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVolumeMetrics
     */
    'price_per_hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingDetailsVolumeMetrics
     */
    'usage_time'?: number;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingHistory
 */
export interface ResourceLevelBillingHistory {
    /**
     * 
     * @type {Array<ResourceLevelBillingHistoryResources>}
     * @memberof ResourceLevelBillingHistory
     */
    'billing_history'?: Array<ResourceLevelBillingHistoryResources>;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingHistory
     */
    'org_id'?: number;
    /**
     * 
     * @type {PaginationData}
     * @memberof ResourceLevelBillingHistory
     */
    'pagination'?: PaginationData;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingHistory
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingHistoryResources
 */
export interface ResourceLevelBillingHistoryResources {
    /**
     * 
     * @type {ResourceLevelBillingHistoryResponseAttributes}
     * @memberof ResourceLevelBillingHistoryResources
     */
    'attributes'?: ResourceLevelBillingHistoryResponseAttributes;
    /**
     * 
     * @type {ResourceLevelBillingHistoryResponseMetrics}
     * @memberof ResourceLevelBillingHistoryResources
     */
    'metrics'?: ResourceLevelBillingHistoryResponseMetrics;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingHistoryResourcesCluster
 */
export interface ResourceLevelBillingHistoryResourcesCluster {
    /**
     * 
     * @type {ResourceLevelBillingHistoryResponseAttributes}
     * @memberof ResourceLevelBillingHistoryResourcesCluster
     */
    'attributes'?: ResourceLevelBillingHistoryResponseAttributes;
    /**
     * 
     * @type {ResourceLevelBillingHistoryResponseMetrics}
     * @memberof ResourceLevelBillingHistoryResourcesCluster
     */
    'metrics'?: ResourceLevelBillingHistoryResponseMetrics;
    /**
     * 
     * @type {Array<ResourceLevelBillingHistoryResources>}
     * @memberof ResourceLevelBillingHistoryResourcesCluster
     */
    'nodes'?: Array<ResourceLevelBillingHistoryResources>;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingHistoryResponseAttributes
 */
export interface ResourceLevelBillingHistoryResponseAttributes {
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingHistoryResponseAttributes
     */
    'contract_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBillingHistoryResponseAttributes
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingHistoryResponseAttributes
     */
    'infrahub_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBillingHistoryResponseAttributes
     */
    'resource_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBillingHistoryResponseAttributes
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingHistoryResponseMetrics
 */
export interface ResourceLevelBillingHistoryResponseMetrics {
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingHistoryResponseMetrics
     */
    'incurred_bill'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingHistoryResponseMetrics
     */
    'price_per_hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelBillingHistoryResponseMetrics
     */
    'usage_time'?: number;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingVMDetailsResources
 */
export interface ResourceLevelBillingVMDetailsResources {
    /**
     * 
     * @type {ResourceLevelBillingDetailsAttributes}
     * @memberof ResourceLevelBillingVMDetailsResources
     */
    'attributes'?: ResourceLevelBillingDetailsAttributes;
    /**
     * 
     * @type {ResourceLevelBillingDetailsMetrics}
     * @memberof ResourceLevelBillingVMDetailsResources
     */
    'metrics'?: ResourceLevelBillingDetailsMetrics;
}
/**
 * 
 * @export
 * @interface ResourceLevelBillingVolumeDetailsResources
 */
export interface ResourceLevelBillingVolumeDetailsResources {
    /**
     * 
     * @type {ResourceLevelBillingDetailsVolumeAttributes}
     * @memberof ResourceLevelBillingVolumeDetailsResources
     */
    'attributes'?: ResourceLevelBillingDetailsVolumeAttributes;
    /**
     * 
     * @type {ResourceLevelBillingDetailsVolumeMetrics}
     * @memberof ResourceLevelBillingVolumeDetailsResources
     */
    'metrics'?: ResourceLevelBillingDetailsVolumeMetrics;
}
/**
 * 
 * @export
 * @interface ResourceLevelBucketBillingDetailsResponseModel
 */
export interface ResourceLevelBucketBillingDetailsResponseModel {
    /**
     * 
     * @type {ResourceLevelBillingBucketDetailsResources}
     * @memberof ResourceLevelBucketBillingDetailsResponseModel
     */
    'billing_history_bucket_details'?: ResourceLevelBillingBucketDetailsResources;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBucketBillingDetailsResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelBucketBillingDetailsResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelBucketBillingHistoryResponseModel
 */
export interface ResourceLevelBucketBillingHistoryResponseModel {
    /**
     * 
     * @type {ResourceLevelBillingHistory}
     * @memberof ResourceLevelBucketBillingHistoryResponseModel
     */
    'billing_history_bucket'?: ResourceLevelBillingHistory;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelBucketBillingHistoryResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelBucketBillingHistoryResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelClusterBillingDetailsResponseModel
 */
export interface ResourceLevelClusterBillingDetailsResponseModel {
    /**
     * 
     * @type {ResourceLevelBillingHistoryResourcesCluster}
     * @memberof ResourceLevelClusterBillingDetailsResponseModel
     */
    'billing_history_cluster_details'?: ResourceLevelBillingHistoryResourcesCluster;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelClusterBillingDetailsResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelClusterBillingDetailsResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelClusterBillingHistoryResponseModel
 */
export interface ResourceLevelClusterBillingHistoryResponseModel {
    /**
     * 
     * @type {ResourceLevelBillingHistory}
     * @memberof ResourceLevelClusterBillingHistoryResponseModel
     */
    'billing_history_cluster'?: ResourceLevelBillingHistory;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelClusterBillingHistoryResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelClusterBillingHistoryResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelClusterGraphBillingDetailsResponseModel
 */
export interface ResourceLevelClusterGraphBillingDetailsResponseModel {
    /**
     * 
     * @type {ResourceLevelGraphBillingDetailVolume}
     * @memberof ResourceLevelClusterGraphBillingDetailsResponseModel
     */
    'billing_history_cluster_details'?: ResourceLevelGraphBillingDetailVolume;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelClusterGraphBillingDetailsResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelClusterGraphBillingDetailsResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelGraphBillingDetailVolume
 */
export interface ResourceLevelGraphBillingDetailVolume {
    /**
     * 
     * @type {Array<ResourceLevelGraphBillingVolumeDetailsResources>}
     * @memberof ResourceLevelGraphBillingDetailVolume
     */
    'billing_history'?: Array<ResourceLevelGraphBillingVolumeDetailsResources>;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailVolume
     */
    'granularity'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailVolume
     */
    'org_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailVolume
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface ResourceLevelGraphBillingDetailsAttributes
 */
export interface ResourceLevelGraphBillingDetailsAttributes {
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelGraphBillingDetailsAttributes
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailsAttributes
     */
    'infrahub_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelGraphBillingDetailsAttributes
     */
    'resource_name'?: string;
}
/**
 * 
 * @export
 * @interface ResourceLevelGraphBillingDetailsBucket
 */
export interface ResourceLevelGraphBillingDetailsBucket {
    /**
     * 
     * @type {Array<ResourceLevelBillingBucketDetailsResources>}
     * @memberof ResourceLevelGraphBillingDetailsBucket
     */
    'billing_history'?: Array<ResourceLevelBillingBucketDetailsResources>;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailsBucket
     */
    'granularity'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailsBucket
     */
    'org_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailsBucket
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface ResourceLevelGraphBillingDetailsMetrics
 */
export interface ResourceLevelGraphBillingDetailsMetrics {
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailsMetrics
     */
    'incurred_bill'?: number;
    /**
     * 
     * @type {Array<GraphDatetimeValueModel>}
     * @memberof ResourceLevelGraphBillingDetailsMetrics
     */
    'incurred_bill_graph'?: Array<GraphDatetimeValueModel>;
}
/**
 * 
 * @export
 * @interface ResourceLevelGraphBillingDetailsVM
 */
export interface ResourceLevelGraphBillingDetailsVM {
    /**
     * 
     * @type {Array<ResourceLevelGraphBillingVMDetailsResources>}
     * @memberof ResourceLevelGraphBillingDetailsVM
     */
    'billing_history'?: Array<ResourceLevelGraphBillingVMDetailsResources>;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailsVM
     */
    'granularity'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailsVM
     */
    'org_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceLevelGraphBillingDetailsVM
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface ResourceLevelGraphBillingVMDetailsResources
 */
export interface ResourceLevelGraphBillingVMDetailsResources {
    /**
     * 
     * @type {ResourceLevelGraphBillingDetailsAttributes}
     * @memberof ResourceLevelGraphBillingVMDetailsResources
     */
    'attributes'?: ResourceLevelGraphBillingDetailsAttributes;
    /**
     * 
     * @type {ResourceLevelGraphBillingDetailsMetrics}
     * @memberof ResourceLevelGraphBillingVMDetailsResources
     */
    'metrics'?: ResourceLevelGraphBillingDetailsMetrics;
}
/**
 * 
 * @export
 * @interface ResourceLevelGraphBillingVolumeDetailsResources
 */
export interface ResourceLevelGraphBillingVolumeDetailsResources {
    /**
     * 
     * @type {ResourceLevelGraphBillingDetailsAttributes}
     * @memberof ResourceLevelGraphBillingVolumeDetailsResources
     */
    'attributes'?: ResourceLevelGraphBillingDetailsAttributes;
    /**
     * 
     * @type {ResourceLevelGraphBillingDetailsMetrics}
     * @memberof ResourceLevelGraphBillingVolumeDetailsResources
     */
    'metrics'?: ResourceLevelGraphBillingDetailsMetrics;
}
/**
 * 
 * @export
 * @interface ResourceLevelVMBillingDetailsResponseModel
 */
export interface ResourceLevelVMBillingDetailsResponseModel {
    /**
     * 
     * @type {ResourceLevelBillingDetailsVM}
     * @memberof ResourceLevelVMBillingDetailsResponseModel
     */
    'billing_history_vm_details'?: ResourceLevelBillingDetailsVM;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelVMBillingDetailsResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelVMBillingDetailsResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelVmBillingHistoryResponseModel
 */
export interface ResourceLevelVmBillingHistoryResponseModel {
    /**
     * 
     * @type {ResourceLevelBillingHistory}
     * @memberof ResourceLevelVmBillingHistoryResponseModel
     */
    'billing_history_vm'?: ResourceLevelBillingHistory;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelVmBillingHistoryResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelVmBillingHistoryResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelVmGraphBillingDetailsResponseModel
 */
export interface ResourceLevelVmGraphBillingDetailsResponseModel {
    /**
     * 
     * @type {ResourceLevelGraphBillingDetailsVM}
     * @memberof ResourceLevelVmGraphBillingDetailsResponseModel
     */
    'billing_history_vm_details'?: ResourceLevelGraphBillingDetailsVM;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelVmGraphBillingDetailsResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelVmGraphBillingDetailsResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelVolumeBillingDetailsResponseModel
 */
export interface ResourceLevelVolumeBillingDetailsResponseModel {
    /**
     * 
     * @type {ResourceLevelBillingDetailsVolume}
     * @memberof ResourceLevelVolumeBillingDetailsResponseModel
     */
    'billing_history_volume_details'?: ResourceLevelBillingDetailsVolume;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelVolumeBillingDetailsResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelVolumeBillingDetailsResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelVolumeBillingHistoryResponseModel
 */
export interface ResourceLevelVolumeBillingHistoryResponseModel {
    /**
     * 
     * @type {ResourceLevelBillingHistory}
     * @memberof ResourceLevelVolumeBillingHistoryResponseModel
     */
    'billing_history_volume'?: ResourceLevelBillingHistory;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelVolumeBillingHistoryResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelVolumeBillingHistoryResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceLevelVolumeGraphBillingDetailsResponseModel
 */
export interface ResourceLevelVolumeGraphBillingDetailsResponseModel {
    /**
     * 
     * @type {ResourceLevelGraphBillingDetailVolume}
     * @memberof ResourceLevelVolumeGraphBillingDetailsResponseModel
     */
    'billing_history_snapshot_details'?: ResourceLevelGraphBillingDetailVolume;
    /**
     * 
     * @type {string}
     * @memberof ResourceLevelVolumeGraphBillingDetailsResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceLevelVolumeGraphBillingDetailsResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResourceObjectResponseForCustomer
 */
export interface ResourceObjectResponseForCustomer {
    /**
     * 
     * @type {number}
     * @memberof ResourceObjectResponseForCustomer
     */
    'org_id'?: number;
    /**
     * 
     * @type {InfrahubResourceObjectResponseForCustomer}
     * @memberof ResourceObjectResponseForCustomer
     */
    'resource'?: InfrahubResourceObjectResponseForCustomer;
}
/**
 * 
 * @export
 * @interface ResponseModel
 */
export interface ResponseModel {
    /**
     * 
     * @type {string}
     * @memberof ResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface RolePermissionFields
 */
export interface RolePermissionFields {
    /**
     * 
     * @type {number}
     * @memberof RolePermissionFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RolePermissionFields
     */
    'permission'?: string;
    /**
     * 
     * @type {string}
     * @memberof RolePermissionFields
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface RolePolicyFields
 */
export interface RolePolicyFields {
    /**
     * 
     * @type {string}
     * @memberof RolePolicyFields
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof RolePolicyFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RolePolicyFields
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SecondaryColor
 */
export interface SecondaryColor {
    /**
     * 
     * @type {string}
     * @memberof SecondaryColor
     */
    'dark'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecondaryColor
     */
    'light'?: string;
}
/**
 * 
 * @export
 * @interface SecurityGroupRule
 */
export interface SecurityGroupRule {
    /**
     * 
     * @type {string}
     * @memberof SecurityGroupRule
     */
    'message'?: string;
    /**
     * 
     * @type {SecurityGroupRuleFields}
     * @memberof SecurityGroupRule
     */
    'security_rule'?: SecurityGroupRuleFields;
    /**
     * 
     * @type {boolean}
     * @memberof SecurityGroupRule
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface SecurityGroupRuleFields
 */
export interface SecurityGroupRuleFields {
    /**
     * 
     * @type {string}
     * @memberof SecurityGroupRuleFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroupRuleFields
     */
    'direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroupRuleFields
     */
    'ethertype'?: string;
    /**
     * 
     * @type {number}
     * @memberof SecurityGroupRuleFields
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecurityGroupRuleFields
     */
    'port_range_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecurityGroupRuleFields
     */
    'port_range_min'?: number;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroupRuleFields
     */
    'protocol'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroupRuleFields
     */
    'remote_ip_prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroupRuleFields
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface SecurityRulesFieldsForInstance
 */
export interface SecurityRulesFieldsForInstance {
    /**
     * 
     * @type {string}
     * @memberof SecurityRulesFieldsForInstance
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityRulesFieldsForInstance
     */
    'direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityRulesFieldsForInstance
     */
    'ethertype'?: string;
    /**
     * 
     * @type {number}
     * @memberof SecurityRulesFieldsForInstance
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecurityRulesFieldsForInstance
     */
    'port_range_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecurityRulesFieldsForInstance
     */
    'port_range_min'?: number;
    /**
     * 
     * @type {string}
     * @memberof SecurityRulesFieldsForInstance
     */
    'protocol'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityRulesFieldsForInstance
     */
    'remote_ip_prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityRulesFieldsForInstance
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface SecurityRulesProtocolFields
 */
export interface SecurityRulesProtocolFields {
    /**
     * 
     * @type {string}
     * @memberof SecurityRulesProtocolFields
     */
    'message'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SecurityRulesProtocolFields
     */
    'protocols'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SecurityRulesProtocolFields
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ServerlessInferencedBillingHistoryDetailsResponseSchema
 */
export interface ServerlessInferencedBillingHistoryDetailsResponseSchema {
    /**
     * 
     * @type {BillingHistoryServerlessInferenceDetails}
     * @memberof ServerlessInferencedBillingHistoryDetailsResponseSchema
     */
    'billing_history_serverless_inference_details'?: BillingHistoryServerlessInferenceDetails;
    /**
     * 
     * @type {string}
     * @memberof ServerlessInferencedBillingHistoryDetailsResponseSchema
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServerlessInferencedBillingHistoryDetailsResponseSchema
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface SnapshotFields
 */
export interface SnapshotFields {
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SnapshotFields
     */
    'created_at': string;
    /**
     * Description of the snapshot
     * @type {string}
     * @memberof SnapshotFields
     */
    'description': string;
    /**
     * Indicates if the VM had a floating IP assigned
     * @type {boolean}
     * @memberof SnapshotFields
     */
    'has_floating_ip'?: boolean;
    /**
     * Snapshot ID
     * @type {number}
     * @memberof SnapshotFields
     */
    'id': number;
    /**
     * Indicates if the snapshot is an image
     * @type {boolean}
     * @memberof SnapshotFields
     */
    'is_image': boolean;
    /**
     * Labels associated with snapshot
     * @type {Array<string>}
     * @memberof SnapshotFields
     */
    'labels'?: Array<string>;
    /**
     * Snapshot name
     * @type {string}
     * @memberof SnapshotFields
     */
    'name': string;
    /**
     * Region where the snapshot will be available
     * @type {number}
     * @memberof SnapshotFields
     */
    'region_id': number;
    /**
     * Size in GB of the snapshot
     * @type {number}
     * @memberof SnapshotFields
     */
    'size': number;
    /**
     * Status of the snapshot
     * @type {string}
     * @memberof SnapshotFields
     */
    'status': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof SnapshotFields
     */
    'updated_at': string;
    /**
     * ID of the VM from which the snapshot is created
     * @type {number}
     * @memberof SnapshotFields
     */
    'vm_id': number;
}
/**
 * 
 * @export
 * @interface SnapshotRestoreRequest
 */
export interface SnapshotRestoreRequest {
    /**
     * Contract ID to assign to the newly restored VM
     * @type {number}
     * @memberof SnapshotRestoreRequest
     */
    'contract_id'?: number;
    /**
     * The name of the newly restored VM
     * @type {string}
     * @memberof SnapshotRestoreRequest
     */
    'new_vm_name': string;
}
/**
 * 
 * @export
 * @interface SnapshotRetrieve
 */
export interface SnapshotRetrieve {
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieve
     */
    'message'?: string;
    /**
     * 
     * @type {SnapshotRetrieveFields}
     * @memberof SnapshotRetrieve
     */
    'snapshot'?: SnapshotRetrieveFields;
    /**
     * 
     * @type {boolean}
     * @memberof SnapshotRetrieve
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface SnapshotRetrieveFields
 */
export interface SnapshotRetrieveFields {
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'custom_image'?: string;
    /**
     * Description of the snapshot
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'description': string;
    /**
     * Indicates if the VM had a floating IP assigned
     * @type {boolean}
     * @memberof SnapshotRetrieveFields
     */
    'has_floating_ip'?: boolean;
    /**
     * Snapshot ID
     * @type {number}
     * @memberof SnapshotRetrieveFields
     */
    'id': number;
    /**
     * Indicates if the snapshot is an image
     * @type {boolean}
     * @memberof SnapshotRetrieveFields
     */
    'is_image': boolean;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'labels'?: string;
    /**
     * Snapshot name
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'region'?: string;
    /**
     * Region where the snapshot will be available
     * @type {number}
     * @memberof SnapshotRetrieveFields
     */
    'region_id': number;
    /**
     * Size in GB of the snapshot
     * @type {number}
     * @memberof SnapshotRetrieveFields
     */
    'size': number;
    /**
     * Status of the snapshot
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'status': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'vm_environment'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'vm_flavor'?: string;
    /**
     * ID of the VM from which the snapshot is created
     * @type {number}
     * @memberof SnapshotRetrieveFields
     */
    'vm_id': number;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'vm_image'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'vm_keypair'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'vm_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'vm_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'volume_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotRetrieveFields
     */
    'volume_name'?: string;
}
/**
 * 
 * @export
 * @interface Snapshots
 */
export interface Snapshots {
    /**
     * 
     * @type {number}
     * @memberof Snapshots
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof Snapshots
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof Snapshots
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Snapshots
     */
    'page_size'?: number;
    /**
     * 
     * @type {Array<SnapshotFields>}
     * @memberof Snapshots
     */
    'snapshots'?: Array<SnapshotFields>;
    /**
     * 
     * @type {boolean}
     * @memberof Snapshots
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface StartDeployment
 */
export interface StartDeployment {
    /**
     * 
     * @type {DeploymentFieldsForStartDeployments}
     * @memberof StartDeployment
     */
    'deployment'?: DeploymentFieldsForStartDeployments;
    /**
     * 
     * @type {string}
     * @memberof StartDeployment
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StartDeployment
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface StartDeploymentPayload
 */
export interface StartDeploymentPayload {
    /**
     * 
     * @type {string}
     * @memberof StartDeploymentPayload
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof StartDeploymentPayload
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof StartDeploymentPayload
     */
    'template_id': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof StartDeploymentPayload
     */
    'variables'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SubResourceGraphBillingDetailsMetrics
 */
export interface SubResourceGraphBillingDetailsMetrics {
    /**
     * 
     * @type {number}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'cpu_incurred_bill'?: number;
    /**
     * 
     * @type {Array<GraphDatetimeValueModel>}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'cpu_incurred_bill_graph'?: Array<GraphDatetimeValueModel>;
    /**
     * 
     * @type {number}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'disk_incurred_bill'?: number;
    /**
     * 
     * @type {Array<GraphDatetimeValueModel>}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'disk_incurred_bill_graph'?: Array<GraphDatetimeValueModel>;
    /**
     * 
     * @type {number}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'ephemeral_incurred_bill'?: number;
    /**
     * 
     * @type {Array<GraphDatetimeValueModel>}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'ephemeral_incurred_bill_graph'?: Array<GraphDatetimeValueModel>;
    /**
     * 
     * @type {number}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'gpu_incurred_bill'?: number;
    /**
     * 
     * @type {Array<GraphDatetimeValueModel>}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'gpu_incurred_bill_graph'?: Array<GraphDatetimeValueModel>;
    /**
     * 
     * @type {number}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'publicip_incurred_bill'?: number;
    /**
     * 
     * @type {Array<GraphDatetimeValueModel>}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'publicip_incurred_bill_graph'?: Array<GraphDatetimeValueModel>;
    /**
     * 
     * @type {number}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'ram_incurred_bill'?: number;
    /**
     * 
     * @type {Array<GraphDatetimeValueModel>}
     * @memberof SubResourceGraphBillingDetailsMetrics
     */
    'ram_incurred_bill_graph'?: Array<GraphDatetimeValueModel>;
}
/**
 * 
 * @export
 * @interface SubResourcesCostsResponseModel
 */
export interface SubResourcesCostsResponseModel {
    /**
     * 
     * @type {Array<SubResourcesGraphBillingHistoryFields>}
     * @memberof SubResourcesCostsResponseModel
     */
    'billing_history'?: Array<SubResourcesGraphBillingHistoryFields>;
    /**
     * 
     * @type {number}
     * @memberof SubResourcesCostsResponseModel
     */
    'granularity'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubResourcesCostsResponseModel
     */
    'org_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubResourcesCostsResponseModel
     */
    'total_count'?: number;
}
/**
 * 
 * @export
 * @interface SubResourcesGraphBillingHistoryFields
 */
export interface SubResourcesGraphBillingHistoryFields {
    /**
     * 
     * @type {ResourceLevelBillingDetailsAttributes}
     * @memberof SubResourcesGraphBillingHistoryFields
     */
    'attributes'?: ResourceLevelBillingDetailsAttributes;
    /**
     * 
     * @type {SubResourceGraphBillingDetailsMetrics}
     * @memberof SubResourcesGraphBillingHistoryFields
     */
    'metrics'?: SubResourceGraphBillingDetailsMetrics;
}
/**
 * 
 * @export
 * @interface SubResourcesGraphResponseModel
 */
export interface SubResourcesGraphResponseModel {
    /**
     * 
     * @type {string}
     * @memberof SubResourcesGraphResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubResourcesGraphResponseModel
     */
    'status'?: boolean;
    /**
     * 
     * @type {SubResourcesCostsResponseModel}
     * @memberof SubResourcesGraphResponseModel
     */
    'sub_resources_costs'?: SubResourcesCostsResponseModel;
}
/**
 * 
 * @export
 * @interface SubscribeOrUnsubscribeUpdatePayload
 */
export interface SubscribeOrUnsubscribeUpdatePayload {
    /**
     * `false` indicates that the user will no longer receive notifications for this specific threshold, whereas `true` signifies that the user will receive notification emails.
     * @type {boolean}
     * @memberof SubscribeOrUnsubscribeUpdatePayload
     */
    'subscribe': boolean;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Template
     */
    'status'?: boolean;
    /**
     * 
     * @type {TemplateFields}
     * @memberof Template
     */
    'template'?: TemplateFields;
}
/**
 * 
 * @export
 * @interface TemplateFields
 */
export interface TemplateFields {
    /**
     * 
     * @type {string}
     * @memberof TemplateFields
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFields
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof TemplateFields
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateFields
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TemplateFields
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Templates
 */
export interface Templates {
    /**
     * 
     * @type {string}
     * @memberof Templates
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Templates
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<TemplateFields>}
     * @memberof Templates
     */
    'templates'?: Array<TemplateFields>;
}
/**
 * 
 * @export
 * @interface TokenBasedBillingHistoryResponse
 */
export interface TokenBasedBillingHistoryResponse {
    /**
     * 
     * @type {BillingHistoryServerlessInference}
     * @memberof TokenBasedBillingHistoryResponse
     */
    'billing_history_serverless_inference'?: BillingHistoryServerlessInference;
    /**
     * 
     * @type {string}
     * @memberof TokenBasedBillingHistoryResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenBasedBillingHistoryResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface URIs
 */
export interface URIs {
    /**
     * 
     * @type {string}
     * @memberof URIs
     */
    'api_doc'?: string;
    /**
     * 
     * @type {string}
     * @memberof URIs
     */
    'api_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof URIs
     */
    'auth'?: string;
    /**
     * 
     * @type {string}
     * @memberof URIs
     */
    'console'?: string;
    /**
     * 
     * @type {string}
     * @memberof URIs
     */
    'contact_us'?: string;
    /**
     * 
     * @type {string}
     * @memberof URIs
     */
    'doc'?: string;
    /**
     * 
     * @type {string}
     * @memberof URIs
     */
    'landing_page'?: string;
}
/**
 * 
 * @export
 * @interface UpdateClusterNodeGroupPayload
 */
export interface UpdateClusterNodeGroupPayload {
    /**
     * 
     * @type {number}
     * @memberof UpdateClusterNodeGroupPayload
     */
    'max_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateClusterNodeGroupPayload
     */
    'min_count'?: number;
}
/**
 * 
 * @export
 * @interface UpdateEnvironment
 */
export interface UpdateEnvironment {
    /**
     * The new name of the environment.
     * @type {string}
     * @memberof UpdateEnvironment
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateKeypairName
 */
export interface UpdateKeypairName {
    /**
     * The new key pair name.
     * @type {string}
     * @memberof UpdateKeypairName
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateKeypairNameResponse
 */
export interface UpdateKeypairNameResponse {
    /**
     * 
     * @type {KeypairFields}
     * @memberof UpdateKeypairNameResponse
     */
    'keypair'?: KeypairFields;
    /**
     * 
     * @type {string}
     * @memberof UpdateKeypairNameResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateKeypairNameResponse
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationPayload
 */
export interface UpdateOrganizationPayload {
    /**
     * The new name for the organition
     * @type {string}
     * @memberof UpdateOrganizationPayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationResponseModel
 */
export interface UpdateOrganizationResponseModel {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationResponseModel
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateOrganizationResponseModel
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateTemplate
 */
export interface UpdateTemplate {
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplate
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTemplate
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplate
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateVolumeAttachmentPayload
 */
export interface UpdateVolumeAttachmentPayload {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateVolumeAttachmentPayload
     */
    'protected'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateVolumePayload
 */
export interface UpdateVolumePayload {
    /**
     * The name of the target environment to move the volume to. The target environment must be in the same region as the current environment.
     * @type {string}
     * @memberof UpdateVolumePayload
     */
    'environment_name': string;
}
/**
 * 
 * @export
 * @interface UpdateVolumeResponse
 */
export interface UpdateVolumeResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateVolumeResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateVolumeResponse
     */
    'status'?: boolean;
    /**
     * Summary of fields that were updated
     * @type {object}
     * @memberof UpdateVolumeResponse
     */
    'updates'?: object;
    /**
     * 
     * @type {VolumeFields}
     * @memberof UpdateVolumeResponse
     */
    'volume'?: VolumeFields;
}
/**
 * 
 * @export
 * @interface UserDefaultChoiceForUserFields
 */
export interface UserDefaultChoiceForUserFields {
    /**
     * 
     * @type {number}
     * @memberof UserDefaultChoiceForUserFields
     */
    'flavor_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserDefaultChoiceForUserFields
     */
    'image_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserDefaultChoiceForUserFields
     */
    'keypair_id'?: number;
}
/**
 * 
 * @export
 * @interface UserDefaultChoicesForUserResponse
 */
export interface UserDefaultChoicesForUserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserDefaultChoicesForUserResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDefaultChoicesForUserResponse
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<UserDefaultChoiceForUserFields>}
     * @memberof UserDefaultChoicesForUserResponse
     */
    'user_default_choices'?: Array<UserDefaultChoiceForUserFields>;
}
/**
 * 
 * @export
 * @interface UserInfoPostPayload
 */
export interface UserInfoPostPayload {
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'billing_address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'billing_address2'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfoPostPayload
     */
    'business': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'vat_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoPostPayload
     */
    'zip_code': string;
}
/**
 * 
 * @export
 * @interface UserOrganizationsResponse
 */
export interface UserOrganizationsResponse {
    /**
     * 
     * @type {Array<OrganizationFields>}
     * @memberof UserOrganizationsResponse
     */
    'organizations'?: Array<OrganizationFields>;
}
/**
 * 
 * @export
 * @interface UserPermissionFields
 */
export interface UserPermissionFields {
    /**
     * 
     * @type {number}
     * @memberof UserPermissionFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPermissionFields
     */
    'permission'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPermissionFields
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface UsersInfoFields
 */
export interface UsersInfoFields {
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'billing_address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'billing_address2'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UsersInfoFields
     */
    'business'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof UsersInfoFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UsersInfoFields
     */
    'organization_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'stripe_user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'vat_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersInfoFields
     */
    'zip_code'?: string;
}
/**
 * 
 * @export
 * @interface UsersInfoListResponse
 */
export interface UsersInfoListResponse {
    /**
     * 
     * @type {string}
     * @memberof UsersInfoListResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UsersInfoListResponse
     */
    'status'?: boolean;
    /**
     * 
     * @type {UsersInfoFields}
     * @memberof UsersInfoListResponse
     */
    'users_info'?: UsersInfoFields;
}
/**
 * 
 * @export
 * @interface VNCURL
 */
export interface VNCURL {
    /**
     * 
     * @type {string}
     * @memberof VNCURL
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VNCURL
     */
    'status'?: boolean;
    /**
     * 
     * @type {VNCURLFields}
     * @memberof VNCURL
     */
    'vnc_url'?: VNCURLFields;
}
/**
 * 
 * @export
 * @interface VNCURLFields
 */
export interface VNCURLFields {
    /**
     * 
     * @type {number}
     * @memberof VNCURLFields
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof VNCURLFields
     */
    'vnc_url'?: string;
}
/**
 * 
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Volume
     */
    'status'?: boolean;
    /**
     * 
     * @type {VolumeFields}
     * @memberof Volume
     */
    'volume'?: VolumeFields;
}
/**
 * 
 * @export
 * @interface VolumeAttachmentFields
 */
export interface VolumeAttachmentFields {
    /**
     * 
     * @type {string}
     * @memberof VolumeAttachmentFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeAttachmentFields
     */
    'device'?: string;
    /**
     * 
     * @type {number}
     * @memberof VolumeAttachmentFields
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VolumeAttachmentFields
     */
    'protected'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VolumeAttachmentFields
     */
    'status'?: string;
    /**
     * 
     * @type {VolumeFieldsForInstance}
     * @memberof VolumeAttachmentFields
     */
    'volume'?: VolumeFieldsForInstance;
}
/**
 * 
 * @export
 * @interface VolumeFields
 */
export interface VolumeFields {
    /**
     * 
     * @type {Array<AttachmentsFieldsForVolume>}
     * @memberof VolumeFields
     */
    'attachments'?: Array<AttachmentsFieldsForVolume>;
    /**
     * 
     * @type {boolean}
     * @memberof VolumeFields
     */
    'bootable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VolumeFields
     */
    'callback_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeFields
     */
    'description'?: string;
    /**
     * 
     * @type {EnvironmentFieldsForVolume}
     * @memberof VolumeFields
     */
    'environment'?: EnvironmentFieldsForVolume;
    /**
     * 
     * @type {number}
     * @memberof VolumeFields
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof VolumeFields
     */
    'image_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof VolumeFields
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeFields
     */
    'os_image'?: string;
    /**
     * 
     * @type {number}
     * @memberof VolumeFields
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof VolumeFields
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeFields
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeFields
     */
    'volume_type'?: string;
}
/**
 * 
 * @export
 * @interface VolumeFieldsForInstance
 */
export interface VolumeFieldsForInstance {
    /**
     * 
     * @type {boolean}
     * @memberof VolumeFieldsForInstance
     */
    'bootable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VolumeFieldsForInstance
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof VolumeFieldsForInstance
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof VolumeFieldsForInstance
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VolumeFieldsForInstance
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof VolumeFieldsForInstance
     */
    'volume_type'?: string;
}
/**
 * 
 * @export
 * @interface VolumeOverviewFields
 */
export interface VolumeOverviewFields {
    /**
     * 
     * @type {number}
     * @memberof VolumeOverviewFields
     */
    'cost_per_hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof VolumeOverviewFields
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof VolumeOverviewFields
     */
    'using'?: number;
}
/**
 * 
 * @export
 * @interface VolumeTypes
 */
export interface VolumeTypes {
    /**
     * 
     * @type {string}
     * @memberof VolumeTypes
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VolumeTypes
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof VolumeTypes
     */
    'volume_types'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Volumes
 */
export interface Volumes {
    /**
     * 
     * @type {number}
     * @memberof Volumes
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof Volumes
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof Volumes
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Volumes
     */
    'page_size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Volumes
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<VolumesFields>}
     * @memberof Volumes
     */
    'volumes'?: Array<VolumesFields>;
}
/**
 * 
 * @export
 * @interface VolumesFields
 */
export interface VolumesFields {
    /**
     * 
     * @type {Array<AttachmentsFieldsForVolume>}
     * @memberof VolumesFields
     */
    'attachments'?: Array<AttachmentsFieldsForVolume>;
    /**
     * 
     * @type {boolean}
     * @memberof VolumesFields
     */
    'bootable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VolumesFields
     */
    'callback_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumesFields
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumesFields
     */
    'description'?: string;
    /**
     * 
     * @type {EnvironmentFieldsForVolume}
     * @memberof VolumesFields
     */
    'environment'?: EnvironmentFieldsForVolume;
    /**
     * 
     * @type {number}
     * @memberof VolumesFields
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof VolumesFields
     */
    'image_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof VolumesFields
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VolumesFields
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof VolumesFields
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumesFields
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumesFields
     */
    'volume_type'?: string;
}
/**
 * 
 * @export
 * @interface Voucher
 */
export interface Voucher {
    /**
     * Voucher code
     * @type {string}
     * @memberof Voucher
     */
    'code': string;
    /**
     * Voucher ID
     * @type {number}
     * @memberof Voucher
     */
    'id': number;
    /**
     * Voucher status
     * @type {string}
     * @memberof Voucher
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface VoucherRedeemResponseSchema
 */
export interface VoucherRedeemResponseSchema {
    /**
     * Response message
     * @type {string}
     * @memberof VoucherRedeemResponseSchema
     */
    'message': string;
    /**
     * Success status of the operation
     * @type {boolean}
     * @memberof VoucherRedeemResponseSchema
     */
    'status': boolean;
    /**
     * Redeemed voucher details
     * @type {Voucher}
     * @memberof VoucherRedeemResponseSchema
     */
    'voucher'?: Voucher;
}
/**
 * 
 * @export
 * @interface WorkloadBillingHistoryResponse
 */
export interface WorkloadBillingHistoryResponse {
    /**
     * 
     * @type {BillingHistoryFineTuning}
     * @memberof WorkloadBillingHistoryResponse
     */
    'billing_history_fine_tuning'?: BillingHistoryFineTuning;
    /**
     * 
     * @type {string}
     * @memberof WorkloadBillingHistoryResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkloadBillingHistoryResponse
     */
    'success'?: boolean;
}

/**
 * AliveApi - axios parameter creator
 * @export
 */
export const AliveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the billing status of your account to ensure that it is active. An active billing status ensures uninterrupted service. For additional information [**click here**](None/docs/api-reference/billing-resources/alive/).
         * @summary GET: Alive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/alive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliveDoc: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/alive/doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AliveApi - functional programming interface
 * @export
 */
export const AliveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AliveApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the billing status of your account to ensure that it is active. An active billing status ensures uninterrupted service. For additional information [**click here**](None/docs/api-reference/billing-resources/alive/).
         * @summary GET: Alive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlive(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AliveApi.getAlive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAliveDoc(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAliveDoc(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AliveApi.getAliveDoc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AliveApi - factory interface
 * @export
 */
export const AliveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AliveApiFp(configuration)
    return {
        /**
         * Retrieve the billing status of your account to ensure that it is active. An active billing status ensures uninterrupted service. For additional information [**click here**](None/docs/api-reference/billing-resources/alive/).
         * @summary GET: Alive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlive(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getAlive(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliveDoc(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getAliveDoc(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AliveApi - object-oriented interface
 * @export
 * @class AliveApi
 * @extends {BaseAPI}
 */
export class AliveApi extends BaseAPI {
    /**
     * Retrieve the billing status of your account to ensure that it is active. An active billing status ensures uninterrupted service. For additional information [**click here**](None/docs/api-reference/billing-resources/alive/).
     * @summary GET: Alive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliveApi
     */
    public getAlive(options?: RawAxiosRequestConfig) {
        return AliveApiFp(this.configuration).getAlive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliveApi
     */
    public getAliveDoc(options?: RawAxiosRequestConfig) {
        return AliveApiFp(this.configuration).getAliveDoc(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a specified API key by including the ID of the API key in the path.
         * @summary Delete API Key
         * @param {number} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPIKey: async (apiKeyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('deleteAPIKey', 'apiKeyId', apiKeyId)
            const localVarPath = `/api-key/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates your API key, providing access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/generate-api-key).
         * @summary Generate API Key
         * @param {GenerateUpdateApiKeyPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAPIKey: async (payload: GenerateUpdateApiKeyPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('generateAPIKey', 'payload', payload)
            const localVarPath = `/api-key/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves your API keys, granting access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/retrieve-api-key).
         * @summary Retrieve API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAPIKey: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the name and optionally the description of a specified API key. Include the ID of the API key in the path and the new name and optional description in the body of the request.
         * @summary Update API Key
         * @param {number} apiKeyId 
         * @param {GenerateUpdateApiKeyPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPIKey: async (apiKeyId: number, payload: GenerateUpdateApiKeyPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('updateAPIKey', 'apiKeyId', apiKeyId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateAPIKey', 'payload', payload)
            const localVarPath = `/api-key/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a specified API key by including the ID of the API key in the path.
         * @summary Delete API Key
         * @param {number} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAPIKey(apiKeyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAPIKey(apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.deleteAPIKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates your API key, providing access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/generate-api-key).
         * @summary Generate API Key
         * @param {GenerateUpdateApiKeyPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateAPIKey(payload: GenerateUpdateApiKeyPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateUpdateApiKeyResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateAPIKey(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.generateAPIKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves your API keys, granting access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/retrieve-api-key).
         * @summary Retrieve API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAPIKey(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiKeysResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAPIKey(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.getAPIKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the name and optionally the description of a specified API key. Include the ID of the API key in the path and the new name and optional description in the body of the request.
         * @summary Update API Key
         * @param {number} apiKeyId 
         * @param {GenerateUpdateApiKeyPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAPIKey(apiKeyId: number, payload: GenerateUpdateApiKeyPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateUpdateApiKeyResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAPIKey(apiKeyId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.updateAPIKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeyApiFp(configuration)
    return {
        /**
         * Delete a specified API key by including the ID of the API key in the path.
         * @summary Delete API Key
         * @param {number} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPIKey(apiKeyId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponseModel> {
            return localVarFp.deleteAPIKey(apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates your API key, providing access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/generate-api-key).
         * @summary Generate API Key
         * @param {GenerateUpdateApiKeyPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAPIKey(payload: GenerateUpdateApiKeyPayload, options?: RawAxiosRequestConfig): AxiosPromise<GenerateUpdateApiKeyResponseModel> {
            return localVarFp.generateAPIKey(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves your API keys, granting access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/retrieve-api-key).
         * @summary Retrieve API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAPIKey(options?: RawAxiosRequestConfig): AxiosPromise<GetApiKeysResponseModel> {
            return localVarFp.getAPIKey(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the name and optionally the description of a specified API key. Include the ID of the API key in the path and the new name and optional description in the body of the request.
         * @summary Update API Key
         * @param {number} apiKeyId 
         * @param {GenerateUpdateApiKeyPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPIKey(apiKeyId: number, payload: GenerateUpdateApiKeyPayload, options?: RawAxiosRequestConfig): AxiosPromise<GenerateUpdateApiKeyResponseModel> {
            return localVarFp.updateAPIKey(apiKeyId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * Delete a specified API key by including the ID of the API key in the path.
     * @summary Delete API Key
     * @param {number} apiKeyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public deleteAPIKey(apiKeyId: number, options?: RawAxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).deleteAPIKey(apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates your API key, providing access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/generate-api-key).
     * @summary Generate API Key
     * @param {GenerateUpdateApiKeyPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public generateAPIKey(payload: GenerateUpdateApiKeyPayload, options?: RawAxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).generateAPIKey(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves your API keys, granting access to the Infrahub APIs. For further details on API keys, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/api-key/retrieve-api-key).
     * @summary Retrieve API Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public getAPIKey(options?: RawAxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).getAPIKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the name and optionally the description of a specified API key. Include the ID of the API key in the path and the new name and optional description in the body of the request.
     * @summary Update API Key
     * @param {number} apiKeyId 
     * @param {GenerateUpdateApiKeyPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public updateAPIKey(apiKeyId: number, payload: GenerateUpdateApiKeyPayload, options?: RawAxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).updateAPIKey(apiKeyId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssigningMemberRoleApi - axios parameter creator
 * @export
 */
export const AssigningMemberRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a specific RBAC role to a user within your organization, granting them access to the resource actions permitted by the role. Provide the user ID in the path and the role ID in the request body. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/assign-rbac-role).
         * @summary Assign RBAC Role
         * @param {number} userId 
         * @param {AssignRbacRolePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRBACRoleToUser: async (userId: number, payload: AssignRbacRolePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignRBACRoleToUser', 'userId', userId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('assignRBACRoleToUser', 'payload', payload)
            const localVarPath = `/auth/users/{user_id}/assign-roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an RBAC role from a user within your organization, revoking the resource permissions they had access to. Provide the user ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/revoke-rbac-role).
         * @summary Remove RBAC Role From User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRBACRoleFromUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeRBACRoleFromUser', 'userId', userId)
            const localVarPath = `/auth/users/{user_id}/roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssigningMemberRoleApi - functional programming interface
 * @export
 */
export const AssigningMemberRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssigningMemberRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a specific RBAC role to a user within your organization, granting them access to the resource actions permitted by the role. Provide the user ID in the path and the role ID in the request body. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/assign-rbac-role).
         * @summary Assign RBAC Role
         * @param {number} userId 
         * @param {AssignRbacRolePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignRBACRoleToUser(userId: number, payload: AssignRbacRolePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacRoleDetailResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRBACRoleToUser(userId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssigningMemberRoleApi.assignRBACRoleToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes an RBAC role from a user within your organization, revoking the resource permissions they had access to. Provide the user ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/revoke-rbac-role).
         * @summary Remove RBAC Role From User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRBACRoleFromUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRBACRoleFromUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssigningMemberRoleApi.removeRBACRoleFromUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssigningMemberRoleApi - factory interface
 * @export
 */
export const AssigningMemberRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssigningMemberRoleApiFp(configuration)
    return {
        /**
         * Assigns a specific RBAC role to a user within your organization, granting them access to the resource actions permitted by the role. Provide the user ID in the path and the role ID in the request body. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/assign-rbac-role).
         * @summary Assign RBAC Role
         * @param {number} userId 
         * @param {AssignRbacRolePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRBACRoleToUser(userId: number, payload: AssignRbacRolePayload, options?: RawAxiosRequestConfig): AxiosPromise<RbacRoleDetailResponseModel> {
            return localVarFp.assignRBACRoleToUser(userId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an RBAC role from a user within your organization, revoking the resource permissions they had access to. Provide the user ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/revoke-rbac-role).
         * @summary Remove RBAC Role From User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRBACRoleFromUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponseModel> {
            return localVarFp.removeRBACRoleFromUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssigningMemberRoleApi - object-oriented interface
 * @export
 * @class AssigningMemberRoleApi
 * @extends {BaseAPI}
 */
export class AssigningMemberRoleApi extends BaseAPI {
    /**
     * Assigns a specific RBAC role to a user within your organization, granting them access to the resource actions permitted by the role. Provide the user ID in the path and the role ID in the request body. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/assign-rbac-role).
     * @summary Assign RBAC Role
     * @param {number} userId 
     * @param {AssignRbacRolePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssigningMemberRoleApi
     */
    public assignRBACRoleToUser(userId: number, payload: AssignRbacRolePayload, options?: RawAxiosRequestConfig) {
        return AssigningMemberRoleApiFp(this.configuration).assignRBACRoleToUser(userId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes an RBAC role from a user within your organization, revoking the resource permissions they had access to. Provide the user ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/manage-member-roles/revoke-rbac-role).
     * @summary Remove RBAC Role From User
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssigningMemberRoleApi
     */
    public removeRBACRoleFromUser(userId: number, options?: RawAxiosRequestConfig) {
        return AssigningMemberRoleApiFp(this.configuration).removeRBACRoleFromUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change the organization associated with the current token. This is useful for users who have access to multiple organizations.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOrganizationForToken: async (orgId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('changeOrganizationForToken', 'orgId', orgId)
            const localVarPath = `/auth/token/change-org/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable Multi-Factor Authentication (MFA) for the currently authenticated user. This endpoint is used to turn off MFA.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me/mfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Multi-Factor Authentication (MFA) status for the currentlyauthenticated user. Includes whether MFA is enabled.
         * @summary Get MFA status for authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMFAStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me/mfa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the organizations associated with a user by their user ID. This endpoint is useful for understanding the user\'s organizational affiliations.
         * @summary Get User Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrganizations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about the currently authenticated user. For additional information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/auth).
         * @summary Retrieve Authenticated User Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAuthenticatedUserDetails: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Change the organization associated with the current token. This is useful for users who have access to multiple organizations.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeOrganizationForToken(orgId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthGetTokenResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeOrganizationForToken(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.changeOrganizationForToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable Multi-Factor Authentication (MFA) for the currently authenticated user. This endpoint is used to turn off MFA.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMFA(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMFA(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.disableMFA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the Multi-Factor Authentication (MFA) status for the currentlyauthenticated user. Includes whether MFA is enabled.
         * @summary Get MFA status for authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserMFAStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MFAStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserMFAStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getUserMFAStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the organizations associated with a user by their user ID. This endpoint is useful for understanding the user\'s organizational affiliations.
         * @summary Get User Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserOrganizations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOrganizationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserOrganizations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getUserOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about the currently authenticated user. For additional information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/auth).
         * @summary Retrieve Authenticated User Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAuthenticatedUserDetails(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUserInfoResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAuthenticatedUserDetails(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.retrieveAuthenticatedUserDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Change the organization associated with the current token. This is useful for users who have access to multiple organizations.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOrganizationForToken(orgId: number, options?: RawAxiosRequestConfig): AxiosPromise<AuthGetTokenResponseModel> {
            return localVarFp.changeOrganizationForToken(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable Multi-Factor Authentication (MFA) for the currently authenticated user. This endpoint is used to turn off MFA.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMFA(options?: RawAxiosRequestConfig): AxiosPromise<CommonResponseModel> {
            return localVarFp.disableMFA(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Multi-Factor Authentication (MFA) status for the currentlyauthenticated user. Includes whether MFA is enabled.
         * @summary Get MFA status for authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMFAStatus(options?: RawAxiosRequestConfig): AxiosPromise<MFAStatusResponse> {
            return localVarFp.getUserMFAStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the organizations associated with a user by their user ID. This endpoint is useful for understanding the user\'s organizational affiliations.
         * @summary Get User Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrganizations(options?: RawAxiosRequestConfig): AxiosPromise<UserOrganizationsResponse> {
            return localVarFp.getUserOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about the currently authenticated user. For additional information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/auth).
         * @summary Retrieve Authenticated User Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAuthenticatedUserDetails(options?: RawAxiosRequestConfig): AxiosPromise<AuthUserInfoResponseModel> {
            return localVarFp.retrieveAuthenticatedUserDetails(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Change the organization associated with the current token. This is useful for users who have access to multiple organizations.
     * @param {number} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changeOrganizationForToken(orgId: number, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).changeOrganizationForToken(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable Multi-Factor Authentication (MFA) for the currently authenticated user. This endpoint is used to turn off MFA.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public disableMFA(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).disableMFA(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the Multi-Factor Authentication (MFA) status for the currentlyauthenticated user. Includes whether MFA is enabled.
     * @summary Get MFA status for authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserMFAStatus(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getUserMFAStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the organizations associated with a user by their user ID. This endpoint is useful for understanding the user\'s organizational affiliations.
     * @summary Get User Organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserOrganizations(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getUserOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about the currently authenticated user. For additional information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/auth).
     * @summary Retrieve Authenticated User Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public retrieveAuthenticatedUserDetails(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).retrieveAuthenticatedUserDetails(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BetaAccessApi - axios parameter creator
 * @export
 */
export const BetaAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new beta access request for the current user
         * @summary Create a new beta access request
         * @param {BetaAccessRequestPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBetaAccessRequest: async (payload: BetaAccessRequestPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createBetaAccessRequest', 'payload', payload)
            const localVarPath = `/auth/beta-access/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the status of a particular beta access requests.
         * @summary Check the status of beta access requests
         * @param {string} program 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessRequests: async (program: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'program' is not null or undefined
            assertParamExists('getBetaAccessRequests', 'program', program)
            const localVarPath = `/auth/beta-access/requests/{program}`
                .replace(`{${"program"}}`, encodeURIComponent(String(program)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the status of all beta access requests.
         * @summary Check the status of all beta access requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/beta-access/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BetaAccessApi - functional programming interface
 * @export
 */
export const BetaAccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BetaAccessApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new beta access request for the current user
         * @summary Create a new beta access request
         * @param {BetaAccessRequestPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBetaAccessRequest(payload: BetaAccessRequestPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BetaAccessRequestResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBetaAccessRequest(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BetaAccessApi.createBetaAccessRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check the status of a particular beta access requests.
         * @summary Check the status of beta access requests
         * @param {string} program 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBetaAccessRequests(program: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BetaAccessStatusResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBetaAccessRequests(program, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BetaAccessApi.getBetaAccessRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check the status of all beta access requests.
         * @summary Check the status of all beta access requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBetaAccessStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BetaAccessStatusResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBetaAccessStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BetaAccessApi.getBetaAccessStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BetaAccessApi - factory interface
 * @export
 */
export const BetaAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BetaAccessApiFp(configuration)
    return {
        /**
         * Creates a new beta access request for the current user
         * @summary Create a new beta access request
         * @param {BetaAccessRequestPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBetaAccessRequest(payload: BetaAccessRequestPayload, options?: RawAxiosRequestConfig): AxiosPromise<BetaAccessRequestResponseModel> {
            return localVarFp.createBetaAccessRequest(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the status of a particular beta access requests.
         * @summary Check the status of beta access requests
         * @param {string} program 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessRequests(program: string, options?: RawAxiosRequestConfig): AxiosPromise<BetaAccessStatusResponseModel> {
            return localVarFp.getBetaAccessRequests(program, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the status of all beta access requests.
         * @summary Check the status of all beta access requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBetaAccessStatus(options?: RawAxiosRequestConfig): AxiosPromise<BetaAccessStatusResponseModel> {
            return localVarFp.getBetaAccessStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BetaAccessApi - object-oriented interface
 * @export
 * @class BetaAccessApi
 * @extends {BaseAPI}
 */
export class BetaAccessApi extends BaseAPI {
    /**
     * Creates a new beta access request for the current user
     * @summary Create a new beta access request
     * @param {BetaAccessRequestPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BetaAccessApi
     */
    public createBetaAccessRequest(payload: BetaAccessRequestPayload, options?: RawAxiosRequestConfig) {
        return BetaAccessApiFp(this.configuration).createBetaAccessRequest(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the status of a particular beta access requests.
     * @summary Check the status of beta access requests
     * @param {string} program 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BetaAccessApi
     */
    public getBetaAccessRequests(program: string, options?: RawAxiosRequestConfig) {
        return BetaAccessApiFp(this.configuration).getBetaAccessRequests(program, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the status of all beta access requests.
     * @summary Check the status of all beta access requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BetaAccessApi
     */
    public getBetaAccessStatus(options?: RawAxiosRequestConfig) {
        return BetaAccessApiFp(this.configuration).getBetaAccessStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User will receive hourly cost datapoints for a Bucket for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Bucket for a specific billing cycle
         * @param {number} bucketId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBillingHistoryHourlyChart: async (bucketId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bucketId' is not null or undefined
            assertParamExists('bucketsBillingHistoryHourlyChart', 'bucketId', bucketId)
            const localVarPath = `/billing/billing/history/bucket/{bucket_id}/graph`
                .replace(`{${"bucket_id"}}`, encodeURIComponent(String(bucketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve billing history of a specific Bucket for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} bucketId 
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketBillingHistory: async (bucketId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bucketId' is not null or undefined
            assertParamExists('getBucketBillingHistory', 'bucketId', bucketId)
            const localVarPath = `/billing/billing/history/bucket/{bucket_id}`
                .replace(`{${"bucket_id"}}`, encodeURIComponent(String(bucketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of a specific Cluster for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'.
         * @summary Retrieve Billing History of a Specific Cluster for a specific Billing Cycle
         * @param {number} clusterId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterBillingHistory: async (clusterId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterBillingHistory', 'clusterId', clusterId)
            const localVarPath = `/billing/billing/history/cluster/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive hourly cost datapoints for a Cluster for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a specific Cluster for a specific billing cycle
         * @param {number} clusterId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterBillingHistoryGraph: async (clusterId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterBillingHistoryGraph', 'clusterId', clusterId)
            const localVarPath = `/billing/billing/history/cluster/{cluster_id}/graph`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of data_synthesis for the specified billing cycle.
         * @summary Retrieve Billing History of data synthesis for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSynthesisBillingHistory: async (startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/data_synthesis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive hourly cost datapoints for a data synthesis job for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Data Synthesis for a specific
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSynthesisBillingHistoryGraph: async (resourceId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getDataSynthesisBillingHistoryGraph', 'resourceId', resourceId)
            const localVarPath = `/billing/billing/history/data_synthesis/{resource_id}/graph`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve billing history for a specific Data Synthesis resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId 
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSynthesisHistoryForResource: async (resourceId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getDataSynthesisHistoryForResource', 'resourceId', resourceId)
            const localVarPath = `/billing/billing/history/data_synthesis/{resource_id}`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of fine_tuning for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineTuningBillingHistory: async (startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/fine_tuning`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive hourly cost datapoints for a Fine Tunings for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Fine Tuning for a specific billing cycle
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineTuningBillingHistoryGraph: async (resourceId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getFineTuningBillingHistoryGraph', 'resourceId', resourceId)
            const localVarPath = `/billing/billing/history/fine_tuning/{resource_id}/graph`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the previous day\'s costs for instances, volumes, and clusters. Returns a breakdown of  the costs and the total cost for the last day. For additional information on Retrieve Previous Day Usage Costs, [**click here**](None/docs/api-reference/billing-resources/last-day-usage/)
         * @summary GET: Last Day Cost
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastDayCost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/last-day-cost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of model_evaluation for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelEvaluationBillingHistory: async (startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/model_evaluation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive hourly cost datapoints for a model evaluation for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Model Evaluation for a specific
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelEvaluationBillingHistoryGraph: async (resourceId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getModelEvaluationBillingHistoryGraph', 'resourceId', resourceId)
            const localVarPath = `/billing/billing/history/model_evaluation/{resource_id}/graph`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, you are subscribed to all the threshold values and you will be receiving the email notification for these default thresholds values. `false` indicates that the user will no longer receive notifications for this specific threshold, whereas `true` signifies that the user will receive notification emails.
         * @summary Update: Subscribe or Unsubscribe Notification Threshold
         * @param {number} thresholdId 
         * @param {SubscribeOrUnsubscribeUpdatePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationThreshold: async (thresholdId: number, payload: SubscribeOrUnsubscribeUpdatePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thresholdId' is not null or undefined
            assertParamExists('getNotificationThreshold', 'thresholdId', thresholdId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('getNotificationThreshold', 'payload', payload)
            const localVarPath = `/billing/billing/threshold/{threshold_id}`
                .replace(`{${"threshold_id"}}`, encodeURIComponent(String(thresholdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve billing history of a specific Fine tuning for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Fine Tuning for a specific Billing Cycle
         * @param {number} resourceId 
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceFineTuningBillingHistory: async (resourceId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getResourceFineTuningBillingHistory', 'resourceId', resourceId)
            const localVarPath = `/billing/billing/history/fine_tuning/{resource_id}`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve billing history for a specific Model Evaluation resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId 
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceModelEvaluationBillingHistory: async (resourceId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getResourceModelEvaluationBillingHistory', 'resourceId', resourceId)
            const localVarPath = `/billing/billing/history/model_evaluation/{resource_id}`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive hourly cost datapoints for a serverless inference for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Serverless Inference for a specific
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerlessInferenceBillingHistoryGraph: async (resourceId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getServerlessInferenceBillingHistoryGraph', 'resourceId', resourceId)
            const localVarPath = `/billing/billing/history/serverless_inference/{resource_id}/graph`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve billing history for a specific Serverless Inference resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId 
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerlessInferencesBillingHistory: async (resourceId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('getServerlessInferencesBillingHistory', 'resourceId', resourceId)
            const localVarPath = `/billing/billing/history/serverless_inference/{resource_id}`
                .replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve billing history of a specific Snapshot for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} snapshotId 
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotBillingHistory: async (snapshotId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('getSnapshotBillingHistory', 'snapshotId', snapshotId)
            const localVarPath = `/billing/billing/history/snapshot/{snapshot_id}`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive hourly cost datapoints for a Snapshot for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Snapshot for a specific billing cycle
         * @param {number} snapshotId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotBillingHistoryGraph: async (snapshotId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('getSnapshotBillingHistoryGraph', 'snapshotId', snapshotId)
            const localVarPath = `/billing/billing/history/snapshot/{snapshot_id}/graph`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve active billing metrics for the organization\'s resources, including pricing, uptime, and total cost. Returns usage details for each active resource by defualt(`deleted=false` will return active resources). Additionally, adding `deleted=true` in query parameter will return inactive resources. For additional information on view usage costs for all resources, [**click here**](None/docs/billing/pricebook/)
         * @summary GET: Billing usage
         * @param {string} [deleted] &#x60;true&#x60; will return inactive resources and &#x60;false&#x60; will return active resources. By defualt(&#x60;deleted&#x3D;false&#x60;)
         * @param {string} [environment] Filter resources by environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage: async (deleted?: string, environment?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history for the specified billing cycle. This data will include \'incurred_bill\', \'non_discounted_bill\', \'vm_cost\', \'volume_cost\'
         * @summary Retrieve Billing History for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [graph] Set this value to \&quot;true\&quot; for getting graph value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistory: async (startDate?: string, endDate?: string, graph?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (graph !== undefined) {
                localVarQueryParameter['graph'] = graph;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of a specific Virtual Machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'
         * @summary Retrieve Billing History of a Specific Virtual Machine for a specific Billing Cycle
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMBillingDetails: async (vmId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('getVMBillingDetails', 'vmId', vmId)
            const localVarPath = `/billing/billing/history/virtual-machine/{vm_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive vm billing events history
         * @summary Retrieve VM billing events history
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMBillingEvents: async (vmId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('getVMBillingEvents', 'vmId', vmId)
            const localVarPath = `/billing/billing/virtual-machine/{vm_id}/billing-events`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive hourly cost datapoints for a VM for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Virtual Machine for a specific billing cycle
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMBillingGraph: async (vmId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('getVMBillingGraph', 'vmId', vmId)
            const localVarPath = `/billing/billing/history/virtual-machine/{vm_id}/graph`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of virtual machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Virtual Machine for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMBillingHistory: async (startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/virtual-machine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will get total costs and non_discount costs of sub resources on a specific Virtual Machine for the specified billing cycle. on a Specific VM for the Specified Billing Cycle
         * @summary Retrieve Total Costs and Non Discount Costs for Sub Resources
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMSubResourceCosts: async (vmId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('getVMSubResourceCosts', 'vmId', vmId)
            const localVarPath = `/billing/billing/virtual-machine/{vm_id}/sub-resource`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive sub-resources historical cost datapoints for a VM sub resources for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. Machine sub resources for a specific billing cycle
         * @summary Retrieve Sub-Resources Historical Cost datapoints of a Virtual
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMSubResourceGraph: async (vmId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('getVMSubResourceGraph', 'vmId', vmId)
            const localVarPath = `/billing/billing/virtual-machine/{vm_id}/sub-resource/graph`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve billing history of a specific Volume for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Volume for a specific Billing Cycle
         * @param {number} volumeId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeBillingDetails: async (volumeId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeId' is not null or undefined
            assertParamExists('getVolumeBillingDetails', 'volumeId', volumeId)
            const localVarPath = `/billing/billing/history/volume/{volume_id}`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive volume billing events history
         * @summary Retrieve Volume billing events history
         * @param {number} volumeId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeBillingEvents: async (volumeId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeId' is not null or undefined
            assertParamExists('getVolumeBillingEvents', 'volumeId', volumeId)
            const localVarPath = `/billing/billing/volume/{volume_id}/billing-events`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of volumes for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Volume for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeBillingHistory: async (startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/volume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive hourly cost datapoints for a Volume for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Volume for a specific billing cycle
         * @param {number} volumeId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeBillingHistoryGraph: async (volumeId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeId' is not null or undefined
            assertParamExists('getVolumeBillingHistoryGraph', 'volumeId', volumeId)
            const localVarPath = `/billing/billing/history/volume/{volume_id}/graph`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of contracts for the specified billing cycle. This data will include \'description\', gpu_type\',\'infrahub_id\', \'status\', \'incurred_bill\', \'price_per_hour\'
         * @summary Retrieve Billing History of Contract for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by Contract \&quot;Description\&quot; or \&quot;ID\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillingContractHistory: async (startDate?: string, endDate?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of buckets for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of a Bucket for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBucketBillingHistory: async (startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of clusters for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Clusters for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClustersBillingHistory: async (startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/cluster`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all the notification thresholds for an organization.
         * @summary GET: All Thresholds for Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgNotificationThresholds: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/threshold`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of serverless_inference for the specified billing cycle.
         * @summary Retrieve Billing History of serverless inference for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerlessInferenceBillingHistory: async (startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/serverless_inference`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User will receive billing history of snapshots for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Snapshot for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshotBillingHistory: async (startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/billing/history/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * User will receive hourly cost datapoints for a Bucket for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Bucket for a specific billing cycle
         * @param {number} bucketId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bucketsBillingHistoryHourlyChart(bucketId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelGraphBillingDetailsBucket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bucketsBillingHistoryHourlyChart(bucketId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.bucketsBillingHistoryHourlyChart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve billing history of a specific Bucket for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} bucketId 
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBucketBillingHistory(bucketId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelBucketBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBucketBillingHistory(bucketId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getBucketBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of a specific Cluster for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'.
         * @summary Retrieve Billing History of a Specific Cluster for a specific Billing Cycle
         * @param {number} clusterId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterBillingHistory(clusterId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelClusterBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterBillingHistory(clusterId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getClusterBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive hourly cost datapoints for a Cluster for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a specific Cluster for a specific billing cycle
         * @param {number} clusterId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterBillingHistoryGraph(clusterId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelClusterGraphBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterBillingHistoryGraph(clusterId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getClusterBillingHistoryGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of data_synthesis for the specified billing cycle.
         * @summary Retrieve Billing History of data synthesis for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSynthesisBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenBasedBillingHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSynthesisBillingHistory(startDate, endDate, search, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getDataSynthesisBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive hourly cost datapoints for a data synthesis job for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Data Synthesis for a specific
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSynthesisBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSynthesisBillingHistoryDetailsResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSynthesisBillingHistoryGraph(resourceId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getDataSynthesisBillingHistoryGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve billing history for a specific Data Synthesis resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId 
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSynthesisHistoryForResource(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSynthesisBillingHistoryDetailsResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSynthesisHistoryForResource(resourceId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getDataSynthesisHistoryForResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of fine_tuning for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFineTuningBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadBillingHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFineTuningBillingHistory(startDate, endDate, search, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getFineTuningBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive hourly cost datapoints for a Fine Tunings for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Fine Tuning for a specific billing cycle
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFineTuningBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVolumeGraphBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFineTuningBillingHistoryGraph(resourceId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getFineTuningBillingHistoryGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the previous day\'s costs for instances, volumes, and clusters. Returns a breakdown of  the costs and the total cost for the last day. For additional information on Retrieve Previous Day Usage Costs, [**click here**](None/docs/api-reference/billing-resources/last-day-usage/)
         * @summary GET: Last Day Cost
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastDayCost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastDayCostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastDayCost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getLastDayCost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of model_evaluation for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelEvaluationBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenBasedBillingHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelEvaluationBillingHistory(startDate, endDate, search, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getModelEvaluationBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive hourly cost datapoints for a model evaluation for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Model Evaluation for a specific
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelEvaluationBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelEvaluationBillingHistoryDetailsResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelEvaluationBillingHistoryGraph(resourceId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getModelEvaluationBillingHistoryGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * By default, you are subscribed to all the threshold values and you will be receiving the email notification for these default thresholds values. `false` indicates that the user will no longer receive notifications for this specific threshold, whereas `true` signifies that the user will receive notification emails.
         * @summary Update: Subscribe or Unsubscribe Notification Threshold
         * @param {number} thresholdId 
         * @param {SubscribeOrUnsubscribeUpdatePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationThreshold(thresholdId: number, payload: SubscribeOrUnsubscribeUpdatePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationThresholdUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationThreshold(thresholdId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getNotificationThreshold']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve billing history of a specific Fine tuning for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Fine Tuning for a specific Billing Cycle
         * @param {number} resourceId 
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceFineTuningBillingHistory(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVolumeBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceFineTuningBillingHistory(resourceId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getResourceFineTuningBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve billing history for a specific Model Evaluation resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId 
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceModelEvaluationBillingHistory(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelEvaluationBillingHistoryDetailsResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceModelEvaluationBillingHistory(resourceId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getResourceModelEvaluationBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive hourly cost datapoints for a serverless inference for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Serverless Inference for a specific
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerlessInferenceBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerlessInferencedBillingHistoryDetailsResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerlessInferenceBillingHistoryGraph(resourceId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getServerlessInferenceBillingHistoryGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve billing history for a specific Serverless Inference resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId 
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerlessInferencesBillingHistory(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerlessInferencedBillingHistoryDetailsResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerlessInferencesBillingHistory(resourceId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getServerlessInferencesBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve billing history of a specific Snapshot for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} snapshotId 
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshotBillingHistory(snapshotId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVolumeBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshotBillingHistory(snapshotId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getSnapshotBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive hourly cost datapoints for a Snapshot for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Snapshot for a specific billing cycle
         * @param {number} snapshotId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshotBillingHistoryGraph(snapshotId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVolumeGraphBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshotBillingHistoryGraph(snapshotId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getSnapshotBillingHistoryGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve active billing metrics for the organization\'s resources, including pricing, uptime, and total cost. Returns usage details for each active resource by defualt(`deleted=false` will return active resources). Additionally, adding `deleted=true` in query parameter will return inactive resources. For additional information on view usage costs for all resources, [**click here**](None/docs/billing/pricebook/)
         * @summary GET: Billing usage
         * @param {string} [deleted] &#x60;true&#x60; will return inactive resources and &#x60;false&#x60; will return active resources. By defualt(&#x60;deleted&#x3D;false&#x60;)
         * @param {string} [environment] Filter resources by environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsage(deleted?: string, environment?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingMetricesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsage(deleted, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history for the specified billing cycle. This data will include \'incurred_bill\', \'non_discounted_bill\', \'vm_cost\', \'volume_cost\'
         * @summary Retrieve Billing History for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [graph] Set this value to \&quot;true\&quot; for getting graph value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBillingHistory(startDate?: string, endDate?: string, graph?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationLevelBillingHistoryResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBillingHistory(startDate, endDate, graph, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getUserBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of a specific Virtual Machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'
         * @summary Retrieve Billing History of a Specific Virtual Machine for a specific Billing Cycle
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVMBillingDetails(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVMBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVMBillingDetails(vmId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVMBillingDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive vm billing events history
         * @summary Retrieve VM billing events history
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVMBillingEvents(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceBillingEventsHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVMBillingEvents(vmId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVMBillingEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive hourly cost datapoints for a VM for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Virtual Machine for a specific billing cycle
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVMBillingGraph(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVmGraphBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVMBillingGraph(vmId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVMBillingGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of virtual machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Virtual Machine for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVMBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVmBillingHistoryResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVMBillingHistory(startDate, endDate, search, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVMBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will get total costs and non_discount costs of sub resources on a specific Virtual Machine for the specified billing cycle. on a Specific VM for the Specified Billing Cycle
         * @summary Retrieve Total Costs and Non Discount Costs for Sub Resources
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVMSubResourceCosts(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubResourcesCostsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVMSubResourceCosts(vmId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVMSubResourceCosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive sub-resources historical cost datapoints for a VM sub resources for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. Machine sub resources for a specific billing cycle
         * @summary Retrieve Sub-Resources Historical Cost datapoints of a Virtual
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVMSubResourceGraph(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubResourcesGraphResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVMSubResourceGraph(vmId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVMSubResourceGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve billing history of a specific Volume for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Volume for a specific Billing Cycle
         * @param {number} volumeId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolumeBillingDetails(volumeId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVolumeBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolumeBillingDetails(volumeId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVolumeBillingDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive volume billing events history
         * @summary Retrieve Volume billing events history
         * @param {number} volumeId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolumeBillingEvents(volumeId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceBillingEventsHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolumeBillingEvents(volumeId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVolumeBillingEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of volumes for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Volume for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolumeBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVolumeBillingHistoryResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolumeBillingHistory(startDate, endDate, search, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVolumeBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive hourly cost datapoints for a Volume for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Volume for a specific billing cycle
         * @param {number} volumeId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolumeBillingHistoryGraph(volumeId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVolumeGraphBillingDetailsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolumeBillingHistoryGraph(volumeId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getVolumeBillingHistoryGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of contracts for the specified billing cycle. This data will include \'description\', gpu_type\',\'infrahub_id\', \'status\', \'incurred_bill\', \'price_per_hour\'
         * @summary Retrieve Billing History of Contract for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by Contract \&quot;Description\&quot; or \&quot;ID\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBillingContractHistory(startDate?: string, endDate?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBillingContractHistory(startDate, endDate, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.listBillingContractHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of buckets for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of a Bucket for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBucketBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelBucketBillingHistoryResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBucketBillingHistory(startDate, endDate, search, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.listBucketBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of clusters for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Clusters for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClustersBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelClusterBillingHistoryResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClustersBillingHistory(startDate, endDate, search, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.listClustersBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all the notification thresholds for an organization.
         * @summary GET: All Thresholds for Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgNotificationThresholds(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationThresholdsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgNotificationThresholds(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.listOrgNotificationThresholds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of serverless_inference for the specified billing cycle.
         * @summary Retrieve Billing History of serverless inference for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerlessInferenceBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenBasedBillingHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerlessInferenceBillingHistory(startDate, endDate, search, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.listServerlessInferenceBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User will receive billing history of snapshots for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Snapshot for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSnapshotBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceLevelVolumeBillingHistoryResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSnapshotBillingHistory(startDate, endDate, search, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.listSnapshotBillingHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * User will receive hourly cost datapoints for a Bucket for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Bucket for a specific billing cycle
         * @param {number} bucketId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucketsBillingHistoryHourlyChart(bucketId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelGraphBillingDetailsBucket> {
            return localVarFp.bucketsBillingHistoryHourlyChart(bucketId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history of a specific Bucket for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} bucketId 
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketBillingHistory(bucketId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelBucketBillingDetailsResponseModel> {
            return localVarFp.getBucketBillingHistory(bucketId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of a specific Cluster for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'.
         * @summary Retrieve Billing History of a Specific Cluster for a specific Billing Cycle
         * @param {number} clusterId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterBillingHistory(clusterId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelClusterBillingDetailsResponseModel> {
            return localVarFp.getClusterBillingHistory(clusterId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a Cluster for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a specific Cluster for a specific billing cycle
         * @param {number} clusterId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterBillingHistoryGraph(clusterId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelClusterGraphBillingDetailsResponseModel> {
            return localVarFp.getClusterBillingHistoryGraph(clusterId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of data_synthesis for the specified billing cycle.
         * @summary Retrieve Billing History of data synthesis for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSynthesisBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<TokenBasedBillingHistoryResponse> {
            return localVarFp.getDataSynthesisBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a data synthesis job for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Data Synthesis for a specific
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSynthesisBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<DataSynthesisBillingHistoryDetailsResponseSchema> {
            return localVarFp.getDataSynthesisBillingHistoryGraph(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history for a specific Data Synthesis resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId 
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSynthesisHistoryForResource(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<DataSynthesisBillingHistoryDetailsResponseSchema> {
            return localVarFp.getDataSynthesisHistoryForResource(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of fine_tuning for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineTuningBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<WorkloadBillingHistoryResponse> {
            return localVarFp.getFineTuningBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a Fine Tunings for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Fine Tuning for a specific billing cycle
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineTuningBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVolumeGraphBillingDetailsResponseModel> {
            return localVarFp.getFineTuningBillingHistoryGraph(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the previous day\'s costs for instances, volumes, and clusters. Returns a breakdown of  the costs and the total cost for the last day. For additional information on Retrieve Previous Day Usage Costs, [**click here**](None/docs/api-reference/billing-resources/last-day-usage/)
         * @summary GET: Last Day Cost
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastDayCost(options?: RawAxiosRequestConfig): AxiosPromise<LastDayCostResponse> {
            return localVarFp.getLastDayCost(options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of model_evaluation for the specified billing cycle.
         * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelEvaluationBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<TokenBasedBillingHistoryResponse> {
            return localVarFp.getModelEvaluationBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a model evaluation for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Model Evaluation for a specific
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelEvaluationBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ModelEvaluationBillingHistoryDetailsResponseSchema> {
            return localVarFp.getModelEvaluationBillingHistoryGraph(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, you are subscribed to all the threshold values and you will be receiving the email notification for these default thresholds values. `false` indicates that the user will no longer receive notifications for this specific threshold, whereas `true` signifies that the user will receive notification emails.
         * @summary Update: Subscribe or Unsubscribe Notification Threshold
         * @param {number} thresholdId 
         * @param {SubscribeOrUnsubscribeUpdatePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationThreshold(thresholdId: number, payload: SubscribeOrUnsubscribeUpdatePayload, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationThresholdUpdateResponse> {
            return localVarFp.getNotificationThreshold(thresholdId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history of a specific Fine tuning for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Fine Tuning for a specific Billing Cycle
         * @param {number} resourceId 
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceFineTuningBillingHistory(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVolumeBillingDetailsResponseModel> {
            return localVarFp.getResourceFineTuningBillingHistory(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history for a specific Model Evaluation resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId 
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceModelEvaluationBillingHistory(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ModelEvaluationBillingHistoryDetailsResponseSchema> {
            return localVarFp.getResourceModelEvaluationBillingHistory(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a serverless inference for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
         * @summary Retrieve hourly cost datapoints of a Specific Serverless Inference for a specific
         * @param {number} resourceId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerlessInferenceBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerlessInferencedBillingHistoryDetailsResponseSchema> {
            return localVarFp.getServerlessInferenceBillingHistoryGraph(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history for a specific Serverless Inference resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
         * @param {number} resourceId 
         * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerlessInferencesBillingHistory(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerlessInferencedBillingHistoryDetailsResponseSchema> {
            return localVarFp.getServerlessInferencesBillingHistory(resourceId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history of a specific Snapshot for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
         * @param {number} snapshotId 
         * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotBillingHistory(snapshotId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVolumeBillingDetailsResponseModel> {
            return localVarFp.getSnapshotBillingHistory(snapshotId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a Snapshot for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Snapshot for a specific billing cycle
         * @param {number} snapshotId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotBillingHistoryGraph(snapshotId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVolumeGraphBillingDetailsResponseModel> {
            return localVarFp.getSnapshotBillingHistoryGraph(snapshotId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve active billing metrics for the organization\'s resources, including pricing, uptime, and total cost. Returns usage details for each active resource by defualt(`deleted=false` will return active resources). Additionally, adding `deleted=true` in query parameter will return inactive resources. For additional information on view usage costs for all resources, [**click here**](None/docs/billing/pricebook/)
         * @summary GET: Billing usage
         * @param {string} [deleted] &#x60;true&#x60; will return inactive resources and &#x60;false&#x60; will return active resources. By defualt(&#x60;deleted&#x3D;false&#x60;)
         * @param {string} [environment] Filter resources by environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage(deleted?: string, environment?: string, options?: RawAxiosRequestConfig): AxiosPromise<BillingMetricesResponse> {
            return localVarFp.getUsage(deleted, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history for the specified billing cycle. This data will include \'incurred_bill\', \'non_discounted_bill\', \'vm_cost\', \'volume_cost\'
         * @summary Retrieve Billing History for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [graph] Set this value to \&quot;true\&quot; for getting graph value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingHistory(startDate?: string, endDate?: string, graph?: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationLevelBillingHistoryResponseModel> {
            return localVarFp.getUserBillingHistory(startDate, endDate, graph, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of a specific Virtual Machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'
         * @summary Retrieve Billing History of a Specific Virtual Machine for a specific Billing Cycle
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMBillingDetails(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVMBillingDetailsResponseModel> {
            return localVarFp.getVMBillingDetails(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive vm billing events history
         * @summary Retrieve VM billing events history
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMBillingEvents(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceBillingEventsHistoryResponse> {
            return localVarFp.getVMBillingEvents(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a VM for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Virtual Machine for a specific billing cycle
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMBillingGraph(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVmGraphBillingDetailsResponseModel> {
            return localVarFp.getVMBillingGraph(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of virtual machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Virtual Machine for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVmBillingHistoryResponseModel> {
            return localVarFp.getVMBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * User will get total costs and non_discount costs of sub resources on a specific Virtual Machine for the specified billing cycle. on a Specific VM for the Specified Billing Cycle
         * @summary Retrieve Total Costs and Non Discount Costs for Sub Resources
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMSubResourceCosts(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<SubResourcesCostsResponseModel> {
            return localVarFp.getVMSubResourceCosts(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive sub-resources historical cost datapoints for a VM sub resources for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. Machine sub resources for a specific billing cycle
         * @summary Retrieve Sub-Resources Historical Cost datapoints of a Virtual
         * @param {number} vmId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMSubResourceGraph(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<SubResourcesGraphResponseModel> {
            return localVarFp.getVMSubResourceGraph(vmId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve billing history of a specific Volume for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
         * @summary Retrieve Billing History of a Specific Volume for a specific Billing Cycle
         * @param {number} volumeId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeBillingDetails(volumeId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVolumeBillingDetailsResponseModel> {
            return localVarFp.getVolumeBillingDetails(volumeId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive volume billing events history
         * @summary Retrieve Volume billing events history
         * @param {number} volumeId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeBillingEvents(volumeId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceBillingEventsHistoryResponse> {
            return localVarFp.getVolumeBillingEvents(volumeId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of volumes for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Volume for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVolumeBillingHistoryResponseModel> {
            return localVarFp.getVolumeBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive hourly cost datapoints for a Volume for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
         * @summary Retrieve hourly cost datapoints of a Specific Volume for a specific billing cycle
         * @param {number} volumeId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolumeBillingHistoryGraph(volumeId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVolumeGraphBillingDetailsResponseModel> {
            return localVarFp.getVolumeBillingHistoryGraph(volumeId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of contracts for the specified billing cycle. This data will include \'description\', gpu_type\',\'infrahub_id\', \'status\', \'incurred_bill\', \'price_per_hour\'
         * @summary Retrieve Billing History of Contract for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by Contract \&quot;Description\&quot; or \&quot;ID\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillingContractHistory(startDate?: string, endDate?: string, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listBillingContractHistory(startDate, endDate, search, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of buckets for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of a Bucket for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBucketBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelBucketBillingHistoryResponseModel> {
            return localVarFp.listBucketBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of clusters for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Clusters for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClustersBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelClusterBillingHistoryResponseModel> {
            return localVarFp.listClustersBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all the notification thresholds for an organization.
         * @summary GET: All Thresholds for Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgNotificationThresholds(options?: RawAxiosRequestConfig): AxiosPromise<OrganizationThresholdsResponse> {
            return localVarFp.listOrgNotificationThresholds(options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of serverless_inference for the specified billing cycle.
         * @summary Retrieve Billing History of serverless inference for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerlessInferenceBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<TokenBasedBillingHistoryResponse> {
            return localVarFp.listServerlessInferenceBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * User will receive billing history of snapshots for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
         * @summary Retrieve Billing History of Snapshot for a specific Billing Cycle
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
         * @param {number} [perPage] Number of items to return per page
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshotBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ResourceLevelVolumeBillingHistoryResponseModel> {
            return localVarFp.listSnapshotBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * User will receive hourly cost datapoints for a Bucket for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Bucket for a specific billing cycle
     * @param {number} bucketId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public bucketsBillingHistoryHourlyChart(bucketId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).bucketsBillingHistoryHourlyChart(bucketId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve billing history of a specific Bucket for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
     * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
     * @param {number} bucketId 
     * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getBucketBillingHistory(bucketId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getBucketBillingHistory(bucketId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of a specific Cluster for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'.
     * @summary Retrieve Billing History of a Specific Cluster for a specific Billing Cycle
     * @param {number} clusterId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getClusterBillingHistory(clusterId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getClusterBillingHistory(clusterId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive hourly cost datapoints for a Cluster for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a specific Cluster for a specific billing cycle
     * @param {number} clusterId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getClusterBillingHistoryGraph(clusterId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getClusterBillingHistoryGraph(clusterId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of data_synthesis for the specified billing cycle.
     * @summary Retrieve Billing History of data synthesis for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getDataSynthesisBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getDataSynthesisBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive hourly cost datapoints for a data synthesis job for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
     * @summary Retrieve hourly cost datapoints of a Specific Data Synthesis for a specific
     * @param {number} resourceId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getDataSynthesisBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getDataSynthesisBillingHistoryGraph(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve billing history for a specific Data Synthesis resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
     * @param {number} resourceId 
     * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getDataSynthesisHistoryForResource(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getDataSynthesisHistoryForResource(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of fine_tuning for the specified billing cycle.
     * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getFineTuningBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getFineTuningBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive hourly cost datapoints for a Fine Tunings for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Fine Tuning for a specific billing cycle
     * @param {number} resourceId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getFineTuningBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getFineTuningBillingHistoryGraph(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the previous day\'s costs for instances, volumes, and clusters. Returns a breakdown of  the costs and the total cost for the last day. For additional information on Retrieve Previous Day Usage Costs, [**click here**](None/docs/api-reference/billing-resources/last-day-usage/)
     * @summary GET: Last Day Cost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getLastDayCost(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getLastDayCost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of model_evaluation for the specified billing cycle.
     * @summary Retrieve Billing History of model evaluation for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getModelEvaluationBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getModelEvaluationBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive hourly cost datapoints for a model evaluation for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
     * @summary Retrieve hourly cost datapoints of a Specific Model Evaluation for a specific
     * @param {number} resourceId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getModelEvaluationBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getModelEvaluationBillingHistoryGraph(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, you are subscribed to all the threshold values and you will be receiving the email notification for these default thresholds values. `false` indicates that the user will no longer receive notifications for this specific threshold, whereas `true` signifies that the user will receive notification emails.
     * @summary Update: Subscribe or Unsubscribe Notification Threshold
     * @param {number} thresholdId 
     * @param {SubscribeOrUnsubscribeUpdatePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getNotificationThreshold(thresholdId: number, payload: SubscribeOrUnsubscribeUpdatePayload, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getNotificationThreshold(thresholdId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve billing history of a specific Fine tuning for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
     * @summary Retrieve Billing History of a Specific Fine Tuning for a specific Billing Cycle
     * @param {number} resourceId 
     * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getResourceFineTuningBillingHistory(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getResourceFineTuningBillingHistory(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve billing history for a specific Model Evaluation resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
     * @param {number} resourceId 
     * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getResourceModelEvaluationBillingHistory(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getResourceModelEvaluationBillingHistory(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive hourly cost datapoints for a serverless inference for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. billing cycle
     * @summary Retrieve hourly cost datapoints of a Specific Serverless Inference for a specific
     * @param {number} resourceId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getServerlessInferenceBillingHistoryGraph(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getServerlessInferenceBillingHistoryGraph(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve billing history for a specific Serverless Inference resource. Includes: \'resource_name\', \'infrahub_id\', \'base_model\', \'base_model_display_name\', \'lora_adapter\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'input_tokens\', \'output_tokens\', \'input_tokens_incurred_bill\', \'input_tokens_non_discounted_bill\', \'output_tokens_incurred_bill\', \'output_tokens_non_discounted_bill\'
     * @param {number} resourceId 
     * @param {string} [startDate] YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getServerlessInferencesBillingHistory(resourceId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getServerlessInferencesBillingHistory(resourceId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve billing history of a specific Snapshot for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
     * @summary Retrieve Billing History of a Specific Snapshot for a specific Billing Cycle
     * @param {number} snapshotId 
     * @param {string} [startDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Datetime should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSnapshotBillingHistory(snapshotId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getSnapshotBillingHistory(snapshotId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive hourly cost datapoints for a Snapshot for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Snapshot for a specific billing cycle
     * @param {number} snapshotId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getSnapshotBillingHistoryGraph(snapshotId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getSnapshotBillingHistoryGraph(snapshotId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve active billing metrics for the organization\'s resources, including pricing, uptime, and total cost. Returns usage details for each active resource by defualt(`deleted=false` will return active resources). Additionally, adding `deleted=true` in query parameter will return inactive resources. For additional information on view usage costs for all resources, [**click here**](None/docs/billing/pricebook/)
     * @summary GET: Billing usage
     * @param {string} [deleted] &#x60;true&#x60; will return inactive resources and &#x60;false&#x60; will return active resources. By defualt(&#x60;deleted&#x3D;false&#x60;)
     * @param {string} [environment] Filter resources by environment ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getUsage(deleted?: string, environment?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getUsage(deleted, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history for the specified billing cycle. This data will include \'incurred_bill\', \'non_discounted_bill\', \'vm_cost\', \'volume_cost\'
     * @summary Retrieve Billing History for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [graph] Set this value to \&quot;true\&quot; for getting graph value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getUserBillingHistory(startDate?: string, endDate?: string, graph?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getUserBillingHistory(startDate, endDate, graph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of a specific Virtual Machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'non_discounted_price_per_hour\', \'incurred_bill\', \'non_discounted_bill\', \'usage_time\', \'usage_time_ACTIVE\', \'usage_time_SHUTOFF\', \'usage_time_HIBERNATED\'
     * @summary Retrieve Billing History of a Specific Virtual Machine for a specific Billing Cycle
     * @param {number} vmId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVMBillingDetails(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVMBillingDetails(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive vm billing events history
     * @summary Retrieve VM billing events history
     * @param {number} vmId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVMBillingEvents(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVMBillingEvents(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive hourly cost datapoints for a VM for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Virtual Machine for a specific billing cycle
     * @param {number} vmId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVMBillingGraph(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVMBillingGraph(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of virtual machine for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of Virtual Machine for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVMBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVMBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will get total costs and non_discount costs of sub resources on a specific Virtual Machine for the specified billing cycle. on a Specific VM for the Specified Billing Cycle
     * @summary Retrieve Total Costs and Non Discount Costs for Sub Resources
     * @param {number} vmId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVMSubResourceCosts(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVMSubResourceCosts(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive sub-resources historical cost datapoints for a VM sub resources for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints. Machine sub resources for a specific billing cycle
     * @summary Retrieve Sub-Resources Historical Cost datapoints of a Virtual
     * @param {number} vmId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVMSubResourceGraph(vmId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVMSubResourceGraph(vmId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve billing history of a specific Volume for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'price_per_hour\', \'incurred_bill\', \'usage_time\', \'non_discounted_price_per_hour\', \'non_discounted_bill\'.
     * @summary Retrieve Billing History of a Specific Volume for a specific Billing Cycle
     * @param {number} volumeId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVolumeBillingDetails(volumeId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVolumeBillingDetails(volumeId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive volume billing events history
     * @summary Retrieve Volume billing events history
     * @param {number} volumeId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVolumeBillingEvents(volumeId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVolumeBillingEvents(volumeId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of volumes for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of Volume for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVolumeBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVolumeBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive hourly cost datapoints for a Volume for a specified billing cycle. This data will include \'incurred_bill\' graph datapoints.
     * @summary Retrieve hourly cost datapoints of a Specific Volume for a specific billing cycle
     * @param {number} volumeId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getVolumeBillingHistoryGraph(volumeId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getVolumeBillingHistoryGraph(volumeId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of contracts for the specified billing cycle. This data will include \'description\', gpu_type\',\'infrahub_id\', \'status\', \'incurred_bill\', \'price_per_hour\'
     * @summary Retrieve Billing History of Contract for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by Contract \&quot;Description\&quot; or \&quot;ID\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listBillingContractHistory(startDate?: string, endDate?: string, search?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).listBillingContractHistory(startDate, endDate, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of buckets for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of a Bucket for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listBucketBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).listBucketBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of clusters for the specified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of Clusters for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listClustersBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).listClustersBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all the notification thresholds for an organization.
     * @summary GET: All Thresholds for Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listOrgNotificationThresholds(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).listOrgNotificationThresholds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of serverless_inference for the specified billing cycle.
     * @summary Retrieve Billing History of serverless inference for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listServerlessInferenceBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).listServerlessInferenceBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User will receive billing history of snapshots for thespecified billing cycle. This data will include \'resource_name\', \'infrahub_id\', \'status\', \'incurred_bill\', \'usage_time\', \'price_per_hour\'
     * @summary Retrieve Billing History of Snapshot for a specific Billing Cycle
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [search] Search by resource \&quot;Name\&quot; or \&quot;ID\&quot;
     * @param {number} [perPage] Number of items to return per page
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listSnapshotBillingHistory(startDate?: string, endDate?: string, search?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).listSnapshotBillingHistory(startDate, endDate, search, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CalculateApi - axios parameter creator
 * @export
 */
export const CalculateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calculate the hourly billing rate of a specified resource by including the resource ID in the path.
         * @summary Retrieve Billing Rate for Resource
         * @param {string} resourceType 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateResourceBillingRate: async (resourceType: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceType' is not null or undefined
            assertParamExists('calculateResourceBillingRate', 'resourceType', resourceType)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('calculateResourceBillingRate', 'id', id)
            const localVarPath = `/pricebook/calculate/resource/{resource_type}/{id}`
                .replace(`{${"resource_type"}}`, encodeURIComponent(String(resourceType)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalculateApi - functional programming interface
 * @export
 */
export const CalculateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalculateApiAxiosParamCreator(configuration)
    return {
        /**
         * Calculate the hourly billing rate of a specified resource by including the resource ID in the path.
         * @summary Retrieve Billing Rate for Resource
         * @param {string} resourceType 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateResourceBillingRate(resourceType: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceBillingResponseForCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateResourceBillingRate(resourceType, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalculateApi.calculateResourceBillingRate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CalculateApi - factory interface
 * @export
 */
export const CalculateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalculateApiFp(configuration)
    return {
        /**
         * Calculate the hourly billing rate of a specified resource by including the resource ID in the path.
         * @summary Retrieve Billing Rate for Resource
         * @param {string} resourceType 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateResourceBillingRate(resourceType: string, id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResourceBillingResponseForCustomer> {
            return localVarFp.calculateResourceBillingRate(resourceType, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalculateApi - object-oriented interface
 * @export
 * @class CalculateApi
 * @extends {BaseAPI}
 */
export class CalculateApi extends BaseAPI {
    /**
     * Calculate the hourly billing rate of a specified resource by including the resource ID in the path.
     * @summary Retrieve Billing Rate for Resource
     * @param {string} resourceType 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalculateApi
     */
    public calculateResourceBillingRate(resourceType: string, id: number, options?: RawAxiosRequestConfig) {
        return CalculateApiFp(this.configuration).calculateResourceBillingRate(resourceType, id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallbacksApi - axios parameter creator
 * @export
 */
export const CallbacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a callback URL for a specified virtual machine, enabling the posting of action events executed on the virtual machine to the specified URL. Provide the callback URL in the request body and the ID of the virtual machine to which it is being attached in the path. For more details on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/attach-callback-vm).
         * @summary Attach callback to virtual machine
         * @param {number} vmId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVM: async (vmId: number, payload: AttachCallbackPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('attachCallbackToVM', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('attachCallbackToVM', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/attach-callback`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a callback URL for a specified volume, enabling the posting of action events executed on the volume to the specified URL. Provide the callback URL in the request body and the ID of the volume to which it is being attached in the path. For more details on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/attach-callback-volume).
         * @summary Attach callback to volume
         * @param {number} volumeId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVolume: async (volumeId: number, payload: AttachCallbackPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeId' is not null or undefined
            assertParamExists('attachCallbackToVolume', 'volumeId', volumeId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('attachCallbackToVolume', 'payload', payload)
            const localVarPath = `/core/volumes/{volume_id}/attach-callback`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes the callback URL associated with a specified virtual machine by providing the virtual machine ID in the request path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/delete-callback-vm).
         * @summary Delete virtual machine callback
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVMCallback: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('deleteVMCallback', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/delete-callback`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes the callback URL associated with a specified volume by providing the volume ID in the request path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/delete-callback-volume).
         * @summary Delete volume callback
         * @param {number} volumeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolumeCallback: async (volumeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeId' is not null or undefined
            assertParamExists('deleteVolumeCallback', 'volumeId', volumeId)
            const localVarPath = `/core/volumes/{volume_id}/delete-callback`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the callback URL for a specified virtual machine. Provide the new callback URL in the request body, along with the ID of the associated virtual machine in the path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms).
         * @summary Update virtual machine callback
         * @param {number} vmId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVMCallback: async (vmId: number, payload: AttachCallbackPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('updateVMCallback', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateVMCallback', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/update-callback`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the callback URL for a specified volume. Provide the new callback URL in the request body, along with the ID of the associated volume in the path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/update-callback-volume/).
         * @summary Update volume callback
         * @param {number} volumeId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolumeCallback: async (volumeId: number, payload: AttachCallbackPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeId' is not null or undefined
            assertParamExists('updateVolumeCallback', 'volumeId', volumeId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateVolumeCallback', 'payload', payload)
            const localVarPath = `/core/volumes/{volume_id}/update-callback`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallbacksApi - functional programming interface
 * @export
 */
export const CallbacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallbacksApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a callback URL for a specified virtual machine, enabling the posting of action events executed on the virtual machine to the specified URL. Provide the callback URL in the request body and the ID of the virtual machine to which it is being attached in the path. For more details on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/attach-callback-vm).
         * @summary Attach callback to virtual machine
         * @param {number} vmId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachCallbackToVM(vmId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachCallbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachCallbackToVM(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallbacksApi.attachCallbackToVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a callback URL for a specified volume, enabling the posting of action events executed on the volume to the specified URL. Provide the callback URL in the request body and the ID of the volume to which it is being attached in the path. For more details on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/attach-callback-volume).
         * @summary Attach callback to volume
         * @param {number} volumeId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachCallbackToVolume(volumeId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachCallbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachCallbackToVolume(volumeId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallbacksApi.attachCallbackToVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes the callback URL associated with a specified virtual machine by providing the virtual machine ID in the request path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/delete-callback-vm).
         * @summary Delete virtual machine callback
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVMCallback(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVMCallback(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallbacksApi.deleteVMCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes the callback URL associated with a specified volume by providing the volume ID in the request path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/delete-callback-volume).
         * @summary Delete volume callback
         * @param {number} volumeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVolumeCallback(volumeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVolumeCallback(volumeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallbacksApi.deleteVolumeCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the callback URL for a specified virtual machine. Provide the new callback URL in the request body, along with the ID of the associated virtual machine in the path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms).
         * @summary Update virtual machine callback
         * @param {number} vmId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVMCallback(vmId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachCallbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVMCallback(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallbacksApi.updateVMCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the callback URL for a specified volume. Provide the new callback URL in the request body, along with the ID of the associated volume in the path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/update-callback-volume/).
         * @summary Update volume callback
         * @param {number} volumeId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVolumeCallback(volumeId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachCallbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVolumeCallback(volumeId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallbacksApi.updateVolumeCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallbacksApi - factory interface
 * @export
 */
export const CallbacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallbacksApiFp(configuration)
    return {
        /**
         * Creates a callback URL for a specified virtual machine, enabling the posting of action events executed on the virtual machine to the specified URL. Provide the callback URL in the request body and the ID of the virtual machine to which it is being attached in the path. For more details on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/attach-callback-vm).
         * @summary Attach callback to virtual machine
         * @param {number} vmId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVM(vmId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig): AxiosPromise<AttachCallbackResponse> {
            return localVarFp.attachCallbackToVM(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a callback URL for a specified volume, enabling the posting of action events executed on the volume to the specified URL. Provide the callback URL in the request body and the ID of the volume to which it is being attached in the path. For more details on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/attach-callback-volume).
         * @summary Attach callback to volume
         * @param {number} volumeId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCallbackToVolume(volumeId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig): AxiosPromise<AttachCallbackResponse> {
            return localVarFp.attachCallbackToVolume(volumeId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes the callback URL associated with a specified virtual machine by providing the virtual machine ID in the request path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/delete-callback-vm).
         * @summary Delete virtual machine callback
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVMCallback(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteVMCallback(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes the callback URL associated with a specified volume by providing the volume ID in the request path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/delete-callback-volume).
         * @summary Delete volume callback
         * @param {number} volumeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolumeCallback(volumeId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteVolumeCallback(volumeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the callback URL for a specified virtual machine. Provide the new callback URL in the request body, along with the ID of the associated virtual machine in the path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms).
         * @summary Update virtual machine callback
         * @param {number} vmId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVMCallback(vmId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig): AxiosPromise<AttachCallbackResponse> {
            return localVarFp.updateVMCallback(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the callback URL for a specified volume. Provide the new callback URL in the request body, along with the ID of the associated volume in the path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/update-callback-volume/).
         * @summary Update volume callback
         * @param {number} volumeId 
         * @param {AttachCallbackPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolumeCallback(volumeId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig): AxiosPromise<AttachCallbackResponse> {
            return localVarFp.updateVolumeCallback(volumeId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CallbacksApi - object-oriented interface
 * @export
 * @class CallbacksApi
 * @extends {BaseAPI}
 */
export class CallbacksApi extends BaseAPI {
    /**
     * Creates a callback URL for a specified virtual machine, enabling the posting of action events executed on the virtual machine to the specified URL. Provide the callback URL in the request body and the ID of the virtual machine to which it is being attached in the path. For more details on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/attach-callback-vm).
     * @summary Attach callback to virtual machine
     * @param {number} vmId 
     * @param {AttachCallbackPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    public attachCallbackToVM(vmId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig) {
        return CallbacksApiFp(this.configuration).attachCallbackToVM(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a callback URL for a specified volume, enabling the posting of action events executed on the volume to the specified URL. Provide the callback URL in the request body and the ID of the volume to which it is being attached in the path. For more details on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/attach-callback-volume).
     * @summary Attach callback to volume
     * @param {number} volumeId 
     * @param {AttachCallbackPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    public attachCallbackToVolume(volumeId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig) {
        return CallbacksApiFp(this.configuration).attachCallbackToVolume(volumeId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes the callback URL associated with a specified virtual machine by providing the virtual machine ID in the request path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms/delete-callback-vm).
     * @summary Delete virtual machine callback
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    public deleteVMCallback(vmId: number, options?: RawAxiosRequestConfig) {
        return CallbacksApiFp(this.configuration).deleteVMCallback(vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes the callback URL associated with a specified volume by providing the volume ID in the request path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/delete-callback-volume).
     * @summary Delete volume callback
     * @param {number} volumeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    public deleteVolumeCallback(volumeId: number, options?: RawAxiosRequestConfig) {
        return CallbacksApiFp(this.configuration).deleteVolumeCallback(volumeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the callback URL for a specified virtual machine. Provide the new callback URL in the request body, along with the ID of the associated virtual machine in the path. For additional information on virtual machine callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/callbacks-vms).
     * @summary Update virtual machine callback
     * @param {number} vmId 
     * @param {AttachCallbackPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    public updateVMCallback(vmId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig) {
        return CallbacksApiFp(this.configuration).updateVMCallback(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the callback URL for a specified volume. Provide the new callback URL in the request body, along with the ID of the associated volume in the path. For additional information on volume callback URLs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-callbacks/update-callback-volume/).
     * @summary Update volume callback
     * @param {number} volumeId 
     * @param {AttachCallbackPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbacksApi
     */
    public updateVolumeCallback(volumeId: number, payload: AttachCallbackPayload, options?: RawAxiosRequestConfig) {
        return CallbacksApiFp(this.configuration).updateVolumeCallback(volumeId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterEventsApi - axios parameter creator
 * @export
 */
export const ClusterEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch all of a cluster events
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterEvents: async (clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listClusterEvents', 'clusterId', clusterId)
            const localVarPath = `/core/clusters/{cluster_id}/events`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterEventsApi - functional programming interface
 * @export
 */
export const ClusterEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch all of a cluster events
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusterEvents(clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterEvents>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusterEvents(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterEventsApi.listClusterEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterEventsApi - factory interface
 * @export
 */
export const ClusterEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterEventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch all of a cluster events
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterEvents(clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterEvents> {
            return localVarFp.listClusterEvents(clusterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterEventsApi - object-oriented interface
 * @export
 * @class ClusterEventsApi
 * @extends {BaseAPI}
 */
export class ClusterEventsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch all of a cluster events
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterEventsApi
     */
    public listClusterEvents(clusterId: string, options?: RawAxiosRequestConfig) {
        return ClusterEventsApiFp(this.configuration).listClusterEvents(clusterId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClustersApi - axios parameter creator
 * @export
 */
export const ClustersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Cluster
         * @param {CreateClusterPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster: async (payload: CreateClusterPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createCluster', 'payload', payload)
            const localVarPath = `/core/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Node
         * @param {number} clusterId 
         * @param {CreateClusterNodeFields} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode: async (clusterId: number, payload: CreateClusterNodeFields, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createNode', 'clusterId', clusterId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createNode', 'payload', payload)
            const localVarPath = `/core/clusters/{cluster_id}/nodes`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a node group in a cluster
         * @param {number} clusterId 
         * @param {CreateClusterNodeGroupPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNodeGroup: async (clusterId: number, payload: CreateClusterNodeGroupPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createNodeGroup', 'clusterId', clusterId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createNodeGroup', 'payload', payload)
            const localVarPath = `/core/clusters/{cluster_id}/node-groups`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCluster', 'id', id)
            const localVarPath = `/core/clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Cluster Node
         * @param {number} clusterId 
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterNode: async (clusterId: number, nodeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteClusterNode', 'clusterId', clusterId)
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('deleteClusterNode', 'nodeId', nodeId)
            const localVarPath = `/core/clusters/{cluster_id}/nodes/{node_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Multiple Cluster Nodes
         * @param {number} clusterId 
         * @param {DeleteClusterNodesFields} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterNodes: async (clusterId: number, payload: DeleteClusterNodesFields, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteClusterNodes', 'clusterId', clusterId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('deleteClusterNodes', 'payload', payload)
            const localVarPath = `/core/clusters/{cluster_id}/nodes/delete`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a node group
         * @param {number} clusterId 
         * @param {number} nodeGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNodeGroup: async (clusterId: number, nodeGroupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteNodeGroup', 'clusterId', clusterId)
            // verify required parameter 'nodeGroupId' is not null or undefined
            assertParamExists('deleteNodeGroup', 'nodeGroupId', nodeGroupId)
            const localVarPath = `/core/clusters/{cluster_id}/node-groups/{node_group_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_group_id"}}`, encodeURIComponent(String(nodeGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a Cluster name is available
         * @summary Fetch cluster name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterNameAvailability: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('fetchClusterNameAvailability', 'name', name)
            const localVarPath = `/core/clusters/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cluster Master Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMasterFlavors: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/clusters/master-flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cluster Nodes
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterNodes: async (clusterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterNodes', 'clusterId', clusterId)
            const localVarPath = `/core/clusters/{cluster_id}/nodes`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists available Kubernetes versions, optionally filtered by region.
         * @summary List Cluster Versions
         * @param {string} [region] Filter versions by region name (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterVersions: async (region?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/clusters/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a node group in a cluster
         * @param {number} clusterId 
         * @param {number} nodeGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeGroup: async (clusterId: number, nodeGroupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getNodeGroup', 'clusterId', clusterId)
            // verify required parameter 'nodeGroupId' is not null or undefined
            assertParamExists('getNodeGroup', 'nodeGroupId', nodeGroupId)
            const localVarPath = `/core/clusters/{cluster_id}/node-groups/{node_group_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_group_id"}}`, encodeURIComponent(String(nodeGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Getting Cluster Detail
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gettingClusterDetail: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gettingClusterDetail', 'id', id)
            const localVarPath = `/core/clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Clusters
         * @param {number} [page] Page number for pagination
         * @param {number} [pageSize] Number of items per page
         * @param {string} [environment] Environment Filter
         * @param {string} [search] Search query to filter cluster by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters: async (page?: number, pageSize?: number, environment?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List node groups for a cluster
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeGroups: async (clusterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listNodeGroups', 'clusterId', clusterId)
            const localVarPath = `/core/clusters/{cluster_id}/node-groups`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reconcile a cluster
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reconcileCluster: async (clusterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('reconcileCluster', 'clusterId', clusterId)
            const localVarPath = `/core/clusters/{cluster_id}/reconcile`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a node group in a cluster
         * @param {number} clusterId 
         * @param {number} nodeGroupId 
         * @param {UpdateClusterNodeGroupPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeGroup: async (clusterId: number, nodeGroupId: number, payload: UpdateClusterNodeGroupPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('updateNodeGroup', 'clusterId', clusterId)
            // verify required parameter 'nodeGroupId' is not null or undefined
            assertParamExists('updateNodeGroup', 'nodeGroupId', nodeGroupId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateNodeGroup', 'payload', payload)
            const localVarPath = `/core/clusters/{cluster_id}/node-groups/{node_group_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_group_id"}}`, encodeURIComponent(String(nodeGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClustersApi - functional programming interface
 * @export
 */
export const ClustersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClustersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Cluster
         * @param {CreateClusterPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCluster(payload: CreateClusterPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCluster(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.createCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Node
         * @param {number} clusterId 
         * @param {CreateClusterNodeFields} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNode(clusterId: number, payload: CreateClusterNodeFields, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterNodesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNode(clusterId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.createNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a node group in a cluster
         * @param {number} clusterId 
         * @param {CreateClusterNodeGroupPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNodeGroup(clusterId: number, payload: CreateClusterNodeGroupPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterNodeGroupsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNodeGroup(clusterId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.createNodeGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCluster(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCluster(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.deleteCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Cluster Node
         * @param {number} clusterId 
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClusterNode(clusterId: number, nodeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClusterNode(clusterId, nodeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.deleteClusterNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Multiple Cluster Nodes
         * @param {number} clusterId 
         * @param {DeleteClusterNodesFields} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClusterNodes(clusterId: number, payload: DeleteClusterNodesFields, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClusterNodes(clusterId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.deleteClusterNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a node group
         * @param {number} clusterId 
         * @param {number} nodeGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNodeGroup(clusterId: number, nodeGroupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNodeGroup(clusterId, nodeGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.deleteNodeGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if a Cluster name is available
         * @summary Fetch cluster name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchClusterNameAvailability(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NameAvailableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchClusterNameAvailability(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.fetchClusterNameAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Cluster Master Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterMasterFlavors(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterFlavorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterMasterFlavors(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterMasterFlavors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Cluster Nodes
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterNodes(clusterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterNodesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterNodes(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists available Kubernetes versions, optionally filtered by region.
         * @summary List Cluster Versions
         * @param {string} [region] Filter versions by region name (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterVersions(region?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterVersions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterVersions(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a node group in a cluster
         * @param {number} clusterId 
         * @param {number} nodeGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeGroup(clusterId: number, nodeGroupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterNodeGroupsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeGroup(clusterId, nodeGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getNodeGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Getting Cluster Detail
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gettingClusterDetail(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gettingClusterDetail(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.gettingClusterDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Clusters
         * @param {number} [page] Page number for pagination
         * @param {number} [pageSize] Number of items per page
         * @param {string} [environment] Environment Filter
         * @param {string} [search] Search query to filter cluster by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusters(page?: number, pageSize?: number, environment?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusters(page, pageSize, environment, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.listClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List node groups for a cluster
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNodeGroups(clusterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterNodeGroupsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNodeGroups(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.listNodeGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reconcile a cluster
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reconcileCluster(clusterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualReconciliationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reconcileCluster(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.reconcileCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a node group in a cluster
         * @param {number} clusterId 
         * @param {number} nodeGroupId 
         * @param {UpdateClusterNodeGroupPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNodeGroup(clusterId: number, nodeGroupId: number, payload: UpdateClusterNodeGroupPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterNodeGroupsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNodeGroup(clusterId, nodeGroupId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.updateNodeGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClustersApi - factory interface
 * @export
 */
export const ClustersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClustersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Cluster
         * @param {CreateClusterPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(payload: CreateClusterPayload, options?: RawAxiosRequestConfig): AxiosPromise<ClusterResponse> {
            return localVarFp.createCluster(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Node
         * @param {number} clusterId 
         * @param {CreateClusterNodeFields} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(clusterId: number, payload: CreateClusterNodeFields, options?: RawAxiosRequestConfig): AxiosPromise<ClusterNodesListResponse> {
            return localVarFp.createNode(clusterId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a node group in a cluster
         * @param {number} clusterId 
         * @param {CreateClusterNodeGroupPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNodeGroup(clusterId: number, payload: CreateClusterNodeGroupPayload, options?: RawAxiosRequestConfig): AxiosPromise<ClusterNodeGroupsCreateResponse> {
            return localVarFp.createNodeGroup(clusterId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteCluster(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Cluster Node
         * @param {number} clusterId 
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterNode(clusterId: number, nodeId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteClusterNode(clusterId, nodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Multiple Cluster Nodes
         * @param {number} clusterId 
         * @param {DeleteClusterNodesFields} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterNodes(clusterId: number, payload: DeleteClusterNodesFields, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteClusterNodes(clusterId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a node group
         * @param {number} clusterId 
         * @param {number} nodeGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNodeGroup(clusterId: number, nodeGroupId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteNodeGroup(clusterId, nodeGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Cluster name is available
         * @summary Fetch cluster name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchClusterNameAvailability(name: string, options?: RawAxiosRequestConfig): AxiosPromise<NameAvailableModel> {
            return localVarFp.fetchClusterNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cluster Master Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMasterFlavors(options?: RawAxiosRequestConfig): AxiosPromise<MasterFlavorsResponse> {
            return localVarFp.getClusterMasterFlavors(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cluster Nodes
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterNodes(clusterId: number, options?: RawAxiosRequestConfig): AxiosPromise<ClusterNodesListResponse> {
            return localVarFp.getClusterNodes(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists available Kubernetes versions, optionally filtered by region.
         * @summary List Cluster Versions
         * @param {string} [region] Filter versions by region name (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterVersions(region?: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterVersions> {
            return localVarFp.getClusterVersions(region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a node group in a cluster
         * @param {number} clusterId 
         * @param {number} nodeGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeGroup(clusterId: number, nodeGroupId: number, options?: RawAxiosRequestConfig): AxiosPromise<ClusterNodeGroupsGetResponse> {
            return localVarFp.getNodeGroup(clusterId, nodeGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Getting Cluster Detail
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gettingClusterDetail(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ClusterResponse> {
            return localVarFp.gettingClusterDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Clusters
         * @param {number} [page] Page number for pagination
         * @param {number} [pageSize] Number of items per page
         * @param {string} [environment] Environment Filter
         * @param {string} [search] Search query to filter cluster by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(page?: number, pageSize?: number, environment?: string, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterListResponse> {
            return localVarFp.listClusters(page, pageSize, environment, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List node groups for a cluster
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeGroups(clusterId: number, options?: RawAxiosRequestConfig): AxiosPromise<ClusterNodeGroupsListResponse> {
            return localVarFp.listNodeGroups(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reconcile a cluster
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reconcileCluster(clusterId: number, options?: RawAxiosRequestConfig): AxiosPromise<ManualReconciliationModel> {
            return localVarFp.reconcileCluster(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a node group in a cluster
         * @param {number} clusterId 
         * @param {number} nodeGroupId 
         * @param {UpdateClusterNodeGroupPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeGroup(clusterId: number, nodeGroupId: number, payload: UpdateClusterNodeGroupPayload, options?: RawAxiosRequestConfig): AxiosPromise<ClusterNodeGroupsCreateResponse> {
            return localVarFp.updateNodeGroup(clusterId, nodeGroupId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
export class ClustersApi extends BaseAPI {
    /**
     * 
     * @summary Create Cluster
     * @param {CreateClusterPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public createCluster(payload: CreateClusterPayload, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).createCluster(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Node
     * @param {number} clusterId 
     * @param {CreateClusterNodeFields} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public createNode(clusterId: number, payload: CreateClusterNodeFields, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).createNode(clusterId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a node group in a cluster
     * @param {number} clusterId 
     * @param {CreateClusterNodeGroupPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public createNodeGroup(clusterId: number, payload: CreateClusterNodeGroupPayload, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).createNodeGroup(clusterId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a cluster
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteCluster(id: number, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deleteCluster(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Cluster Node
     * @param {number} clusterId 
     * @param {number} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteClusterNode(clusterId: number, nodeId: number, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deleteClusterNode(clusterId, nodeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Multiple Cluster Nodes
     * @param {number} clusterId 
     * @param {DeleteClusterNodesFields} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteClusterNodes(clusterId: number, payload: DeleteClusterNodesFields, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deleteClusterNodes(clusterId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a node group
     * @param {number} clusterId 
     * @param {number} nodeGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteNodeGroup(clusterId: number, nodeGroupId: number, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deleteNodeGroup(clusterId, nodeGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a Cluster name is available
     * @summary Fetch cluster name availability
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public fetchClusterNameAvailability(name: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).fetchClusterNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cluster Master Flavors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterMasterFlavors(options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterMasterFlavors(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cluster Nodes
     * @param {number} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterNodes(clusterId: number, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterNodes(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists available Kubernetes versions, optionally filtered by region.
     * @summary List Cluster Versions
     * @param {string} [region] Filter versions by region name (optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterVersions(region?: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterVersions(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a node group in a cluster
     * @param {number} clusterId 
     * @param {number} nodeGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getNodeGroup(clusterId: number, nodeGroupId: number, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getNodeGroup(clusterId, nodeGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Getting Cluster Detail
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public gettingClusterDetail(id: number, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).gettingClusterDetail(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Clusters
     * @param {number} [page] Page number for pagination
     * @param {number} [pageSize] Number of items per page
     * @param {string} [environment] Environment Filter
     * @param {string} [search] Search query to filter cluster by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listClusters(page?: number, pageSize?: number, environment?: string, search?: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).listClusters(page, pageSize, environment, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List node groups for a cluster
     * @param {number} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listNodeGroups(clusterId: number, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).listNodeGroups(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reconcile a cluster
     * @param {number} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public reconcileCluster(clusterId: number, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).reconcileCluster(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a node group in a cluster
     * @param {number} clusterId 
     * @param {number} nodeGroupId 
     * @param {UpdateClusterNodeGroupPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public updateNodeGroup(clusterId: number, nodeGroupId: number, payload: UpdateClusterNodeGroupPayload, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).updateNodeGroup(clusterId, nodeGroupId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ComplianceApi - axios parameter creator
 * @export
 */
export const ComplianceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create compliance
         * @param {CompliancePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompliance: async (payload: CompliancePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createCompliance', 'payload', payload)
            const localVarPath = `/core/compliance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a compliance
         * @param {string} gpuModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompliance: async (gpuModel: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gpuModel' is not null or undefined
            assertParamExists('deleteCompliance', 'gpuModel', gpuModel)
            const localVarPath = `/core/compliance/{gpu_model}`
                .replace(`{${"gpu_model"}}`, encodeURIComponent(String(gpuModel)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of compliance objects each corresponding to available GPU models. These compliance objects contain minimum and maximum values for RAM in GB, number of vCPUs, and system disk capacity in GB. Use the optional `gpu` model parameter in the query string to filter responses by GPU model. For additional details on GPU compliance, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#adhering-to-gpu-compliance).
         * @summary Retrieve GPU compliance
         * @param {string} [gpu] This is for gpu model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompliance: async (gpu?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/compliance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (gpu !== undefined) {
                localVarQueryParameter['gpu'] = gpu;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a compliance
         * @param {CompliancePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompliance: async (payload: CompliancePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateCompliance', 'payload', payload)
            const localVarPath = `/core/compliance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComplianceApi - functional programming interface
 * @export
 */
export const ComplianceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ComplianceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create compliance
         * @param {CompliancePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompliance(payload: CompliancePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUpdateComplianceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompliance(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComplianceApi.createCompliance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a compliance
         * @param {string} gpuModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCompliance(gpuModel: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompliance(gpuModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComplianceApi.deleteCompliance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of compliance objects each corresponding to available GPU models. These compliance objects contain minimum and maximum values for RAM in GB, number of vCPUs, and system disk capacity in GB. Use the optional `gpu` model parameter in the query string to filter responses by GPU model. For additional details on GPU compliance, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#adhering-to-gpu-compliance).
         * @summary Retrieve GPU compliance
         * @param {string} [gpu] This is for gpu model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompliance(gpu?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ComplianceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompliance(gpu, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComplianceApi.getCompliance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a compliance
         * @param {CompliancePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompliance(payload: CompliancePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUpdateComplianceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompliance(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComplianceApi.updateCompliance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ComplianceApi - factory interface
 * @export
 */
export const ComplianceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ComplianceApiFp(configuration)
    return {
        /**
         * 
         * @summary Create compliance
         * @param {CompliancePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompliance(payload: CompliancePayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateUpdateComplianceResponse> {
            return localVarFp.createCompliance(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a compliance
         * @param {string} gpuModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompliance(gpuModel: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteCompliance(gpuModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of compliance objects each corresponding to available GPU models. These compliance objects contain minimum and maximum values for RAM in GB, number of vCPUs, and system disk capacity in GB. Use the optional `gpu` model parameter in the query string to filter responses by GPU model. For additional details on GPU compliance, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#adhering-to-gpu-compliance).
         * @summary Retrieve GPU compliance
         * @param {string} [gpu] This is for gpu model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompliance(gpu?: string, options?: RawAxiosRequestConfig): AxiosPromise<ComplianceResponse> {
            return localVarFp.getCompliance(gpu, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a compliance
         * @param {CompliancePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompliance(payload: CompliancePayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateUpdateComplianceResponse> {
            return localVarFp.updateCompliance(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComplianceApi - object-oriented interface
 * @export
 * @class ComplianceApi
 * @extends {BaseAPI}
 */
export class ComplianceApi extends BaseAPI {
    /**
     * 
     * @summary Create compliance
     * @param {CompliancePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public createCompliance(payload: CompliancePayload, options?: RawAxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).createCompliance(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a compliance
     * @param {string} gpuModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public deleteCompliance(gpuModel: string, options?: RawAxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).deleteCompliance(gpuModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of compliance objects each corresponding to available GPU models. These compliance objects contain minimum and maximum values for RAM in GB, number of vCPUs, and system disk capacity in GB. Use the optional `gpu` model parameter in the query string to filter responses by GPU model. For additional details on GPU compliance, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#adhering-to-gpu-compliance).
     * @summary Retrieve GPU compliance
     * @param {string} [gpu] This is for gpu model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getCompliance(gpu?: string, options?: RawAxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getCompliance(gpu, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a compliance
     * @param {CompliancePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public updateCompliance(payload: CompliancePayload, options?: RawAxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).updateCompliance(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CreditApi - axios parameter creator
 * @export
 */
export const CreditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the current credit balance for your [**organization**](/docs/rbac/organization). Ensuring a positive credit balance allows you to create resources. However, for prepaid accounts, if the credit balance falls below $0, all associated resources will be temporarily suspended until a [**payment**](/docs/api-reference/billing-resources/create-payment) is made. For additional information, [**click here**](None/docs/api-reference/billing-resources/retrieve-credit-balance/).
         * @summary GET: View credit and threshold
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCredit: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/user-credit/credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditApi - functional programming interface
 * @export
 */
export const CreditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the current credit balance for your [**organization**](/docs/rbac/organization). Ensuring a positive credit balance allows you to create resources. However, for prepaid accounts, if the credit balance falls below $0, all associated resources will be temporarily suspended until a [**payment**](/docs/api-reference/billing-resources/create-payment) is made. For additional information, [**click here**](None/docs/api-reference/billing-resources/retrieve-credit-balance/).
         * @summary GET: View credit and threshold
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCredit(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCreditAndThresholdInfoInResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCredit(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.getUserCredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditApi - factory interface
 * @export
 */
export const CreditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditApiFp(configuration)
    return {
        /**
         * Retrieves the current credit balance for your [**organization**](/docs/rbac/organization). Ensuring a positive credit balance allows you to create resources. However, for prepaid accounts, if the credit balance falls below $0, all associated resources will be temporarily suspended until a [**payment**](/docs/api-reference/billing-resources/create-payment) is made. For additional information, [**click here**](None/docs/api-reference/billing-resources/retrieve-credit-balance/).
         * @summary GET: View credit and threshold
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCredit(options?: RawAxiosRequestConfig): AxiosPromise<GetCreditAndThresholdInfoInResponse> {
            return localVarFp.getUserCredit(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
export class CreditApi extends BaseAPI {
    /**
     * Retrieves the current credit balance for your [**organization**](/docs/rbac/organization). Ensuring a positive credit balance allows you to create resources. However, for prepaid accounts, if the credit balance falls below $0, all associated resources will be temporarily suspended until a [**payment**](/docs/api-reference/billing-resources/create-payment) is made. For additional information, [**click here**](None/docs/api-reference/billing-resources/retrieve-credit-balance/).
     * @summary GET: View credit and threshold
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public getUserCredit(options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).getUserCredit(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomerContractApi - axios parameter creator
 * @export
 */
export const CustomerContractApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve GPU allocation count graph for a specific contract by providing the contract ID in the path. The endpoint returns the GPU allocation count graph for the contract within the specified date range.
         * @summary Retrieve GPU Allocation Graph for Contract
         * @param {number} contractId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractGPUAllocationGraph: async (contractId: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractGPUAllocationGraph', 'contractId', contractId)
            const localVarPath = `/pricebook/contracts/{contract_id}/gpu_allocation_graph`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of contracts and their details, including the terms of each contract and the discounts applied to all resources under each contract. Pagination can be controlled using the `page` and `per_page` query parameters. For additional information about contracts, click [**here**](None/docs/billing-and-payment/contracts).
         * @summary List Contracts
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerContracts: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pricebook/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific contract by providing the contract ID in the path. The endpoint returns the contract object along with its associated discount plans. For more information, [**click here**](None/docs/api-reference/pricebook-resources/retrieve-contract-details).
         * @summary Retrieve Contract Details
         * @param {number} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveContract: async (contractId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('retrieveContract', 'contractId', contractId)
            const localVarPath = `/pricebook/contracts/{contract_id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerContractApi - functional programming interface
 * @export
 */
export const CustomerContractApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerContractApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve GPU allocation count graph for a specific contract by providing the contract ID in the path. The endpoint returns the GPU allocation count graph for the contract within the specified date range.
         * @summary Retrieve GPU Allocation Graph for Contract
         * @param {number} contractId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractGPUAllocationGraph(contractId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractGPUAllocationGraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractGPUAllocationGraph(contractId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerContractApi.getContractGPUAllocationGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of contracts and their details, including the terms of each contract and the discounts applied to all resources under each contract. Pagination can be controlled using the `page` and `per_page` query parameters. For additional information about contracts, click [**here**](None/docs/billing-and-payment/contracts).
         * @summary List Contracts
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomerContracts(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerContractsListResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomerContracts(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerContractApi.listCustomerContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific contract by providing the contract ID in the path. The endpoint returns the contract object along with its associated discount plans. For more information, [**click here**](None/docs/api-reference/pricebook-resources/retrieve-contract-details).
         * @summary Retrieve Contract Details
         * @param {number} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveContract(contractId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerContractDetailResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveContract(contractId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerContractApi.retrieveContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerContractApi - factory interface
 * @export
 */
export const CustomerContractApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerContractApiFp(configuration)
    return {
        /**
         * Retrieve GPU allocation count graph for a specific contract by providing the contract ID in the path. The endpoint returns the GPU allocation count graph for the contract within the specified date range.
         * @summary Retrieve GPU Allocation Graph for Contract
         * @param {number} contractId 
         * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractGPUAllocationGraph(contractId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractGPUAllocationGraphResponse> {
            return localVarFp.getContractGPUAllocationGraph(contractId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of contracts and their details, including the terms of each contract and the discounts applied to all resources under each contract. Pagination can be controlled using the `page` and `per_page` query parameters. For additional information about contracts, click [**here**](None/docs/billing-and-payment/contracts).
         * @summary List Contracts
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomerContracts(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetCustomerContractsListResponseModel> {
            return localVarFp.listCustomerContracts(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific contract by providing the contract ID in the path. The endpoint returns the contract object along with its associated discount plans. For more information, [**click here**](None/docs/api-reference/pricebook-resources/retrieve-contract-details).
         * @summary Retrieve Contract Details
         * @param {number} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveContract(contractId: number, options?: RawAxiosRequestConfig): AxiosPromise<CustomerContractDetailResponseModel> {
            return localVarFp.retrieveContract(contractId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerContractApi - object-oriented interface
 * @export
 * @class CustomerContractApi
 * @extends {BaseAPI}
 */
export class CustomerContractApi extends BaseAPI {
    /**
     * Retrieve GPU allocation count graph for a specific contract by providing the contract ID in the path. The endpoint returns the GPU allocation count graph for the contract within the specified date range.
     * @summary Retrieve GPU Allocation Graph for Contract
     * @param {number} contractId 
     * @param {string} [startDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {string} [endDate] Date should be formatted in YYYY-MM-DDTHH:MM:SS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerContractApi
     */
    public getContractGPUAllocationGraph(contractId: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return CustomerContractApiFp(this.configuration).getContractGPUAllocationGraph(contractId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of contracts and their details, including the terms of each contract and the discounts applied to all resources under each contract. Pagination can be controlled using the `page` and `per_page` query parameters. For additional information about contracts, click [**here**](None/docs/billing-and-payment/contracts).
     * @summary List Contracts
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerContractApi
     */
    public listCustomerContracts(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CustomerContractApiFp(this.configuration).listCustomerContracts(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a specific contract by providing the contract ID in the path. The endpoint returns the contract object along with its associated discount plans. For more information, [**click here**](None/docs/api-reference/pricebook-resources/retrieve-contract-details).
     * @summary Retrieve Contract Details
     * @param {number} contractId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerContractApi
     */
    public retrieveContract(contractId: number, options?: RawAxiosRequestConfig) {
        return CustomerContractApiFp(this.configuration).retrieveContract(contractId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns hardware and pricing overview for your active resources, includingvirtual machines, containers, and volumes. For more details on the Dashboard feature, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/dashboard/).
         * @summary Retrieve Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns hardware and pricing overview for your active resources, includingvirtual machines, containers, and volumes. For more details on the Dashboard feature, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/dashboard/).
         * @summary Retrieve Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboard(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboard(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * Returns hardware and pricing overview for your active resources, includingvirtual machines, containers, and volumes. For more details on the Dashboard feature, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/dashboard/).
         * @summary Retrieve Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(options?: RawAxiosRequestConfig): AxiosPromise<DashboardInfoResponse> {
            return localVarFp.getDashboard(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * Returns hardware and pricing overview for your active resources, includingvirtual machines, containers, and volumes. For more details on the Dashboard feature, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/dashboard/).
     * @summary Retrieve Dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboard(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboard(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Deployment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDeployment', 'id', id)
            const localVarPath = `/core/marketplace/deployments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Details of Deployment by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeployment', 'id', id)
            const localVarPath = `/core/marketplace/deployments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deployments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeployments: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/marketplace/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start Deployment
         * @param {StartDeploymentPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startDeployment: async (payload: StartDeploymentPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('startDeployment', 'payload', payload)
            const localVarPath = `/core/marketplace/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Deployment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeployment(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeployment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentApi.deleteDeployment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Details of Deployment by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployment(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartDeployment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentApi.getDeployment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Deployments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeployments(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deployments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeployments(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentApi.listDeployments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start Deployment
         * @param {StartDeploymentPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startDeployment(payload: StartDeploymentPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartDeployment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startDeployment(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentApi.startDeployment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Deployment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteDeployment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Details of Deployment by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(id: number, options?: RawAxiosRequestConfig): AxiosPromise<StartDeployment> {
            return localVarFp.getDeployment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deployments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeployments(options?: RawAxiosRequestConfig): AxiosPromise<Deployments> {
            return localVarFp.listDeployments(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start Deployment
         * @param {StartDeploymentPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startDeployment(payload: StartDeploymentPayload, options?: RawAxiosRequestConfig): AxiosPromise<StartDeployment> {
            return localVarFp.startDeployment(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @summary Delete Deployment
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deleteDeployment(id: number, options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).deleteDeployment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Details of Deployment by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeployment(id: number, options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeployment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deployments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public listDeployments(options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).listDeployments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start Deployment
     * @param {StartDeploymentPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public startDeployment(payload: StartDeploymentPayload, options?: RawAxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).startDeployment(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an environmenta container to organize your resources, including SSH key pairs, virtual machines, and volumes. To create your environment, provide your desired environment name, and [**region**](https://docs.hyperstack.cloud/docs/resource-management/regions/) in the request body.
         * @summary Create environment
         * @param {CreateEnvironment} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (payload: CreateEnvironment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createEnvironment', 'payload', payload)
            const localVarPath = `/core/environments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an environment permanently. Provide the environment ID in the path to remove the specified environment.
         * @summary Delete environment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEnvironment', 'id', id)
            const localVarPath = `/core/environments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a Environment name is available
         * @summary Fetch environment name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchEnvironmentNameAvailability: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('fetchEnvironmentNameAvailability', 'name', name)
            const localVarPath = `/core/environments/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details about a specific environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Retrieve environment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEnvironment', 'id', id)
            const localVarPath = `/core/environments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your existing environments, providing the following details for each; environment ID, name, [**region**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/), and the date and time of creation. For more information on environments, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/).
         * @summary List environments
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By ID or Name or Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments: async (page?: string, pageSize?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/environments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the name of an existing environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Update environment
         * @param {number} id 
         * @param {UpdateEnvironment} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment: async (id: number, payload: UpdateEnvironment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEnvironment', 'id', id)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateEnvironment', 'payload', payload)
            const localVarPath = `/core/environments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an environmenta container to organize your resources, including SSH key pairs, virtual machines, and volumes. To create your environment, provide your desired environment name, and [**region**](https://docs.hyperstack.cloud/docs/resource-management/regions/) in the request body.
         * @summary Create environment
         * @param {CreateEnvironment} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(payload: CreateEnvironment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.createEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an environment permanently. Provide the environment ID in the path to remove the specified environment.
         * @summary Delete environment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.deleteEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if a Environment name is available
         * @summary Fetch environment name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchEnvironmentNameAvailability(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NameAvailableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchEnvironmentNameAvailability(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.fetchEnvironmentNameAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves details about a specific environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Retrieve environment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.getEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of your existing environments, providing the following details for each; environment ID, name, [**region**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/), and the date and time of creation. For more information on environments, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/).
         * @summary List environments
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By ID or Name or Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironments(page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironments(page, pageSize, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.listEnvironments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the name of an existing environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Update environment
         * @param {number} id 
         * @param {UpdateEnvironment} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironment(id: number, payload: UpdateEnvironment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironment(id, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.updateEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentApiFp(configuration)
    return {
        /**
         * Creates an environmenta container to organize your resources, including SSH key pairs, virtual machines, and volumes. To create your environment, provide your desired environment name, and [**region**](https://docs.hyperstack.cloud/docs/resource-management/regions/) in the request body.
         * @summary Create environment
         * @param {CreateEnvironment} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(payload: CreateEnvironment, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.createEnvironment(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an environment permanently. Provide the environment ID in the path to remove the specified environment.
         * @summary Delete environment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteEnvironment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Environment name is available
         * @summary Fetch environment name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchEnvironmentNameAvailability(name: string, options?: RawAxiosRequestConfig): AxiosPromise<NameAvailableModel> {
            return localVarFp.fetchEnvironmentNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details about a specific environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Retrieve environment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.getEnvironment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your existing environments, providing the following details for each; environment ID, name, [**region**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/), and the date and time of creation. For more information on environments, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/).
         * @summary List environments
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By ID or Name or Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments(page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<Environments> {
            return localVarFp.listEnvironments(page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the name of an existing environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
         * @summary Update environment
         * @param {number} id 
         * @param {UpdateEnvironment} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment(id: number, payload: UpdateEnvironment, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.updateEnvironment(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * Creates an environmenta container to organize your resources, including SSH key pairs, virtual machines, and volumes. To create your environment, provide your desired environment name, and [**region**](https://docs.hyperstack.cloud/docs/resource-management/regions/) in the request body.
     * @summary Create environment
     * @param {CreateEnvironment} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public createEnvironment(payload: CreateEnvironment, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).createEnvironment(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an environment permanently. Provide the environment ID in the path to remove the specified environment.
     * @summary Delete environment
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public deleteEnvironment(id: number, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).deleteEnvironment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a Environment name is available
     * @summary Fetch environment name availability
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public fetchEnvironmentNameAvailability(name: string, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).fetchEnvironmentNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves details about a specific environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
     * @summary Retrieve environment
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getEnvironment(id: number, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).getEnvironment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your existing environments, providing the following details for each; environment ID, name, [**region**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/), and the date and time of creation. For more information on environments, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/).
     * @summary List environments
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search] Search By ID or Name or Region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public listEnvironments(page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).listEnvironments(page, pageSize, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the name of an existing environment. Provide the environment ID in the path and the new environment `name` in the request body to modify the specified environment.
     * @summary Update environment
     * @param {number} id 
     * @param {UpdateEnvironment} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public updateEnvironment(id: number, payload: UpdateEnvironment, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).updateEnvironment(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FIPExclusionsApi - axios parameter creator
 * @export
 */
export const FIPExclusionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * is org excluded from floating ip detachment
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIfOrgIsExcludedFromFloatingIPDetachment: async (orgId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('checkIfOrgIsExcludedFromFloatingIPDetachment', 'orgId', orgId)
            const localVarPath = `/core/fip-detachment-exclusions/org/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FIPExclusionsApi - functional programming interface
 * @export
 */
export const FIPExclusionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FIPExclusionsApiAxiosParamCreator(configuration)
    return {
        /**
         * is org excluded from floating ip detachment
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkIfOrgIsExcludedFromFloatingIPDetachment(orgId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkIfOrgIsExcludedFromFloatingIPDetachment(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FIPExclusionsApi.checkIfOrgIsExcludedFromFloatingIPDetachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FIPExclusionsApi - factory interface
 * @export
 */
export const FIPExclusionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FIPExclusionsApiFp(configuration)
    return {
        /**
         * is org excluded from floating ip detachment
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIfOrgIsExcludedFromFloatingIPDetachment(orgId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.checkIfOrgIsExcludedFromFloatingIPDetachment(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FIPExclusionsApi - object-oriented interface
 * @export
 * @class FIPExclusionsApi
 * @extends {BaseAPI}
 */
export class FIPExclusionsApi extends BaseAPI {
    /**
     * is org excluded from floating ip detachment
     * @param {number} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FIPExclusionsApi
     */
    public checkIfOrgIsExcludedFromFloatingIPDetachment(orgId: number, options?: RawAxiosRequestConfig) {
        return FIPExclusionsApiFp(this.configuration).checkIfOrgIsExcludedFromFloatingIPDetachment(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FirewallAttachmentApi - axios parameter creator
 * @export
 */
export const FirewallAttachmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attach a firewall to one or more virtual machines by providing the virtual machine IDs in the request body and the firewall ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/attach-firewall-to-vms).
         * @summary Attach Firewalls to VMs
         * @param {number} firewallId 
         * @param {AttachFirewallWithVM} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachFirewallToVMs: async (firewallId: number, payload: AttachFirewallWithVM, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('attachFirewallToVMs', 'firewallId', firewallId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('attachFirewallToVMs', 'payload', payload)
            const localVarPath = `/core/firewalls/{firewall_id}/update-attachments`
                .replace(`{${"firewall_id"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FirewallAttachmentApi - functional programming interface
 * @export
 */
export const FirewallAttachmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FirewallAttachmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Attach a firewall to one or more virtual machines by providing the virtual machine IDs in the request body and the firewall ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/attach-firewall-to-vms).
         * @summary Attach Firewalls to VMs
         * @param {number} firewallId 
         * @param {AttachFirewallWithVM} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachFirewallToVMs(firewallId: number, payload: AttachFirewallWithVM, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachFirewallToVMs(firewallId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallAttachmentApi.attachFirewallToVMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FirewallAttachmentApi - factory interface
 * @export
 */
export const FirewallAttachmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FirewallAttachmentApiFp(configuration)
    return {
        /**
         * Attach a firewall to one or more virtual machines by providing the virtual machine IDs in the request body and the firewall ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/attach-firewall-to-vms).
         * @summary Attach Firewalls to VMs
         * @param {number} firewallId 
         * @param {AttachFirewallWithVM} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachFirewallToVMs(firewallId: number, payload: AttachFirewallWithVM, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.attachFirewallToVMs(firewallId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FirewallAttachmentApi - object-oriented interface
 * @export
 * @class FirewallAttachmentApi
 * @extends {BaseAPI}
 */
export class FirewallAttachmentApi extends BaseAPI {
    /**
     * Attach a firewall to one or more virtual machines by providing the virtual machine IDs in the request body and the firewall ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/attach-firewall-to-vms).
     * @summary Attach Firewalls to VMs
     * @param {number} firewallId 
     * @param {AttachFirewallWithVM} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallAttachmentApi
     */
    public attachFirewallToVMs(firewallId: number, payload: AttachFirewallWithVM, options?: RawAxiosRequestConfig) {
        return FirewallAttachmentApiFp(this.configuration).attachFirewallToVMs(firewallId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FirewallsApi - axios parameter creator
 * @export
 */
export const FirewallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a [**firewall rule**](https://docs.hyperstack.cloud/docs/network-security/security-rules) and adds it to an existing firewall. Include the firewall ID in the path, and provide the firewall rule configuration in the request body.
         * @summary Add firewall rule to firewall
         * @param {number} firewallId 
         * @param {CreateFirewallRulePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRuleToFirewall: async (firewallId: number, payload: CreateFirewallRulePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('addRuleToFirewall', 'firewallId', firewallId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('addRuleToFirewall', 'payload', payload)
            const localVarPath = `/core/firewalls/{firewall_id}/firewall-rules`
                .replace(`{${"firewall_id"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a firewall to which firewall rules can be added. A firewall can be attached to one or more virtual machines to control inbound and outbound traffic. In the body of the request, include the name of the firewall, the ID of the environment within which the firewall will be created, and an optional description. To obtain the ID of the environment, make a request to the [**list environments**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/list-environments) endpoint.
         * @summary Create firewall
         * @param {CreateFirewallPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewall: async (payload: CreateFirewallPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createFirewall', 'payload', payload)
            const localVarPath = `/core/firewalls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a firewall by specifying the firewall ID in the path. If the firewall is currently attached to a virtual machine, it must be detached before deletion. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/delete-firewall).
         * @summary Delete firewall
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExistingFirewall: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteExistingFirewall', 'id', id)
            const localVarPath = `/core/firewalls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a firewall rule from firewall by providing the firewall ID and firewall rule ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/remove-firewall-rule-from-firewall).
         * @summary Delete firewall rules from firewall
         * @param {number} firewallId 
         * @param {number} firewallRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleFromFirewall: async (firewallId: number, firewallRuleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('deleteRuleFromFirewall', 'firewallId', firewallId)
            // verify required parameter 'firewallRuleId' is not null or undefined
            assertParamExists('deleteRuleFromFirewall', 'firewallRuleId', firewallRuleId)
            const localVarPath = `/core/firewalls/{firewall_id}/firewall-rules/{firewall_rule_id}`
                .replace(`{${"firewall_id"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"firewall_rule_id"}}`, encodeURIComponent(String(firewallRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing firewall, including the security rules it contains and information about the virtual machines to which it is attached.
         * @summary Retrieve firewall details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewall: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFirewall', 'id', id)
            const localVarPath = `/core/firewalls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of existing firewalls and their details, including the security rules they contain and information about the virtual machines to which they are attached. For more information about the firewalls features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/network-security/security-groups).
         * @summary List firewalls
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExistingFirewalls: async (page?: number, pageSize?: number, search?: string, environment?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/firewalls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FirewallsApi - functional programming interface
 * @export
 */
export const FirewallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FirewallsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a [**firewall rule**](https://docs.hyperstack.cloud/docs/network-security/security-rules) and adds it to an existing firewall. Include the firewall ID in the path, and provide the firewall rule configuration in the request body.
         * @summary Add firewall rule to firewall
         * @param {number} firewallId 
         * @param {CreateFirewallRulePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRuleToFirewall(firewallId: number, payload: CreateFirewallRulePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRuleToFirewall(firewallId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallsApi.addRuleToFirewall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a firewall to which firewall rules can be added. A firewall can be attached to one or more virtual machines to control inbound and outbound traffic. In the body of the request, include the name of the firewall, the ID of the environment within which the firewall will be created, and an optional description. To obtain the ID of the environment, make a request to the [**list environments**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/list-environments) endpoint.
         * @summary Create firewall
         * @param {CreateFirewallPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewall(payload: CreateFirewallPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewall(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallsApi.createFirewall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a firewall by specifying the firewall ID in the path. If the firewall is currently attached to a virtual machine, it must be detached before deletion. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/delete-firewall).
         * @summary Delete firewall
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExistingFirewall(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExistingFirewall(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallsApi.deleteExistingFirewall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a firewall rule from firewall by providing the firewall ID and firewall rule ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/remove-firewall-rule-from-firewall).
         * @summary Delete firewall rules from firewall
         * @param {number} firewallId 
         * @param {number} firewallRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRuleFromFirewall(firewallId: number, firewallRuleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRuleFromFirewall(firewallId, firewallRuleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallsApi.deleteRuleFromFirewall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of an existing firewall, including the security rules it contains and information about the virtual machines to which it is attached.
         * @summary Retrieve firewall details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewall(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewall(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallsApi.getFirewall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of existing firewalls and their details, including the security rules they contain and information about the virtual machines to which they are attached. For more information about the firewalls features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/network-security/security-groups).
         * @summary List firewalls
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExistingFirewalls(page?: number, pageSize?: number, search?: string, environment?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExistingFirewalls(page, pageSize, search, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirewallsApi.listExistingFirewalls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FirewallsApi - factory interface
 * @export
 */
export const FirewallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FirewallsApiFp(configuration)
    return {
        /**
         * Creates a [**firewall rule**](https://docs.hyperstack.cloud/docs/network-security/security-rules) and adds it to an existing firewall. Include the firewall ID in the path, and provide the firewall rule configuration in the request body.
         * @summary Add firewall rule to firewall
         * @param {number} firewallId 
         * @param {CreateFirewallRulePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRuleToFirewall(firewallId: number, payload: CreateFirewallRulePayload, options?: RawAxiosRequestConfig): AxiosPromise<FirewallRule> {
            return localVarFp.addRuleToFirewall(firewallId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a firewall to which firewall rules can be added. A firewall can be attached to one or more virtual machines to control inbound and outbound traffic. In the body of the request, include the name of the firewall, the ID of the environment within which the firewall will be created, and an optional description. To obtain the ID of the environment, make a request to the [**list environments**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/list-environments) endpoint.
         * @summary Create firewall
         * @param {CreateFirewallPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewall(payload: CreateFirewallPayload, options?: RawAxiosRequestConfig): AxiosPromise<FirewallResponse> {
            return localVarFp.createFirewall(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a firewall by specifying the firewall ID in the path. If the firewall is currently attached to a virtual machine, it must be detached before deletion. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/delete-firewall).
         * @summary Delete firewall
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExistingFirewall(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteExistingFirewall(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a firewall rule from firewall by providing the firewall ID and firewall rule ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/remove-firewall-rule-from-firewall).
         * @summary Delete firewall rules from firewall
         * @param {number} firewallId 
         * @param {number} firewallRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleFromFirewall(firewallId: number, firewallRuleId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteRuleFromFirewall(firewallId, firewallRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing firewall, including the security rules it contains and information about the virtual machines to which it is attached.
         * @summary Retrieve firewall details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewall(id: number, options?: RawAxiosRequestConfig): AxiosPromise<FirewallDetailResponse> {
            return localVarFp.getFirewall(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of existing firewalls and their details, including the security rules they contain and information about the virtual machines to which they are attached. For more information about the firewalls features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/network-security/security-groups).
         * @summary List firewalls
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExistingFirewalls(page?: number, pageSize?: number, search?: string, environment?: string, options?: RawAxiosRequestConfig): AxiosPromise<FirewallsListResponse> {
            return localVarFp.listExistingFirewalls(page, pageSize, search, environment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FirewallsApi - object-oriented interface
 * @export
 * @class FirewallsApi
 * @extends {BaseAPI}
 */
export class FirewallsApi extends BaseAPI {
    /**
     * Creates a [**firewall rule**](https://docs.hyperstack.cloud/docs/network-security/security-rules) and adds it to an existing firewall. Include the firewall ID in the path, and provide the firewall rule configuration in the request body.
     * @summary Add firewall rule to firewall
     * @param {number} firewallId 
     * @param {CreateFirewallRulePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    public addRuleToFirewall(firewallId: number, payload: CreateFirewallRulePayload, options?: RawAxiosRequestConfig) {
        return FirewallsApiFp(this.configuration).addRuleToFirewall(firewallId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a firewall to which firewall rules can be added. A firewall can be attached to one or more virtual machines to control inbound and outbound traffic. In the body of the request, include the name of the firewall, the ID of the environment within which the firewall will be created, and an optional description. To obtain the ID of the environment, make a request to the [**list environments**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/environments/list-environments) endpoint.
     * @summary Create firewall
     * @param {CreateFirewallPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    public createFirewall(payload: CreateFirewallPayload, options?: RawAxiosRequestConfig) {
        return FirewallsApiFp(this.configuration).createFirewall(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a firewall by specifying the firewall ID in the path. If the firewall is currently attached to a virtual machine, it must be detached before deletion. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/delete-firewall).
     * @summary Delete firewall
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    public deleteExistingFirewall(id: number, options?: RawAxiosRequestConfig) {
        return FirewallsApiFp(this.configuration).deleteExistingFirewall(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a firewall rule from firewall by providing the firewall ID and firewall rule ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/firewalls/remove-firewall-rule-from-firewall).
     * @summary Delete firewall rules from firewall
     * @param {number} firewallId 
     * @param {number} firewallRuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    public deleteRuleFromFirewall(firewallId: number, firewallRuleId: number, options?: RawAxiosRequestConfig) {
        return FirewallsApiFp(this.configuration).deleteRuleFromFirewall(firewallId, firewallRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing firewall, including the security rules it contains and information about the virtual machines to which it is attached.
     * @summary Retrieve firewall details
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    public getFirewall(id: number, options?: RawAxiosRequestConfig) {
        return FirewallsApiFp(this.configuration).getFirewall(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of existing firewalls and their details, including the security rules they contain and information about the virtual machines to which they are attached. For more information about the firewalls features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/network-security/security-groups).
     * @summary List firewalls
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {string} [environment] Filter Environment ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirewallsApi
     */
    public listExistingFirewalls(page?: number, pageSize?: number, search?: string, environment?: string, options?: RawAxiosRequestConfig) {
        return FirewallsApiFp(this.configuration).listExistingFirewalls(page, pageSize, search, environment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlavorApi - axios parameter creator
 * @export
 */
export const FlavorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of available virtual machine hardware configurations, known as**flavors**. You can specify a `region_name` in the query string of the request toretrieve flavors available only in the specified region; by default, it returnsflavors available in all regions. For more details on flavors,[**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors).
         * @summary List Flavors
         * @param {string} [region] Region Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors: async (region?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlavorApi - functional programming interface
 * @export
 */
export const FlavorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlavorApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of available virtual machine hardware configurations, known as**flavors**. You can specify a `region_name` in the query string of the request toretrieve flavors available only in the specified region; by default, it returnsflavors available in all regions. For more details on flavors,[**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors).
         * @summary List Flavors
         * @param {string} [region] Region Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFlavors(region?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFlavors(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlavorApi.listFlavors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlavorApi - factory interface
 * @export
 */
export const FlavorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlavorApiFp(configuration)
    return {
        /**
         * Returns a list of available virtual machine hardware configurations, known as**flavors**. You can specify a `region_name` in the query string of the request toretrieve flavors available only in the specified region; by default, it returnsflavors available in all regions. For more details on flavors,[**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors).
         * @summary List Flavors
         * @param {string} [region] Region Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors(region?: string, options?: RawAxiosRequestConfig): AxiosPromise<FlavorListResponse> {
            return localVarFp.listFlavors(region, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlavorApi - object-oriented interface
 * @export
 * @class FlavorApi
 * @extends {BaseAPI}
 */
export class FlavorApi extends BaseAPI {
    /**
     * Returns a list of available virtual machine hardware configurations, known as**flavors**. You can specify a `region_name` in the query string of the request toretrieve flavors available only in the specified region; by default, it returnsflavors available in all regions. For more details on flavors,[**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors).
     * @summary List Flavors
     * @param {string} [region] Region Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorApi
     */
    public listFlavors(region?: string, options?: RawAxiosRequestConfig) {
        return FlavorApiFp(this.configuration).listFlavors(region, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FloatingIpApi - axios parameter creator
 * @export
 */
export const FloatingIpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates the creation of a public IP address and attaches it to an existing virtual machine, making it accessible through the internet. Include the virtual machine ID in the path to attach a public IP to the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/attach-floating-ip/).
         * @summary Attach public IP to virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPublicIPToVM: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('attachPublicIPToVM', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/attach-floatingip`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a public IP address from an existing virtual machine, disabling internet accessibility to the VM. Include the virtual machine ID in the path to detach the public IP from the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/public-ip).
         * @summary Detach public IP from virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPublicIPFromVM: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('detachPublicIPFromVM', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/detach-floatingip`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FloatingIpApi - functional programming interface
 * @export
 */
export const FloatingIpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FloatingIpApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiates the creation of a public IP address and attaches it to an existing virtual machine, making it accessible through the internet. Include the virtual machine ID in the path to attach a public IP to the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/attach-floating-ip/).
         * @summary Attach public IP to virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPublicIPToVM(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPublicIPToVM(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FloatingIpApi.attachPublicIPToVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a public IP address from an existing virtual machine, disabling internet accessibility to the VM. Include the virtual machine ID in the path to detach the public IP from the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/public-ip).
         * @summary Detach public IP from virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachPublicIPFromVM(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachPublicIPFromVM(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FloatingIpApi.detachPublicIPFromVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FloatingIpApi - factory interface
 * @export
 */
export const FloatingIpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FloatingIpApiFp(configuration)
    return {
        /**
         * Initiates the creation of a public IP address and attaches it to an existing virtual machine, making it accessible through the internet. Include the virtual machine ID in the path to attach a public IP to the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/attach-floating-ip/).
         * @summary Attach public IP to virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPublicIPToVM(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.attachPublicIPToVM(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a public IP address from an existing virtual machine, disabling internet accessibility to the VM. Include the virtual machine ID in the path to detach the public IP from the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/public-ip).
         * @summary Detach public IP from virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPublicIPFromVM(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.detachPublicIPFromVM(vmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FloatingIpApi - object-oriented interface
 * @export
 * @class FloatingIpApi
 * @extends {BaseAPI}
 */
export class FloatingIpApi extends BaseAPI {
    /**
     * Initiates the creation of a public IP address and attaches it to an existing virtual machine, making it accessible through the internet. Include the virtual machine ID in the path to attach a public IP to the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/floating-ip/attach-floating-ip/).
     * @summary Attach public IP to virtual machine
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingIpApi
     */
    public attachPublicIPToVM(vmId: number, options?: RawAxiosRequestConfig) {
        return FloatingIpApiFp(this.configuration).attachPublicIPToVM(vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a public IP address from an existing virtual machine, disabling internet accessibility to the VM. Include the virtual machine ID in the path to detach the public IP from the specified VM. For more information on public IP addresses, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/public-ip).
     * @summary Detach public IP from virtual machine
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingIpApi
     */
    public detachPublicIPFromVM(vmId: number, options?: RawAxiosRequestConfig) {
        return FloatingIpApiFp(this.configuration).detachPublicIPFromVM(vmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GpuApi - axios parameter creator
 * @export
 */
export const GpuApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available GPUs that can be utilized in the creation of custom virtual machine configurations.
         * @summary List GPUs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGPUs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/gpus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GpuApi - functional programming interface
 * @export
 */
export const GpuApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GpuApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all available GPUs that can be utilized in the creation of custom virtual machine configurations.
         * @summary List GPUs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGPUs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPUList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGPUs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GpuApi.listGPUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GpuApi - factory interface
 * @export
 */
export const GpuApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GpuApiFp(configuration)
    return {
        /**
         * Returns a list of all available GPUs that can be utilized in the creation of custom virtual machine configurations.
         * @summary List GPUs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGPUs(options?: RawAxiosRequestConfig): AxiosPromise<GPUList> {
            return localVarFp.listGPUs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GpuApi - object-oriented interface
 * @export
 * @class GpuApi
 * @extends {BaseAPI}
 */
export class GpuApi extends BaseAPI {
    /**
     * Returns a list of all available GPUs that can be utilized in the creation of custom virtual machine configurations.
     * @summary List GPUs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GpuApi
     */
    public listGPUs(options?: RawAxiosRequestConfig) {
        return GpuApiFp(this.configuration).listGPUs(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an image permanently. Provide the image ID in the path to specify the image to be deleted.
         * @summary Delete an image
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteImage', 'id', id)
            const localVarPath = `/core/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if an Image name is available
         * @summary Fetch name availability for Images
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchImageNameAvailability: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('fetchImageNameAvailability', 'name', name)
            const localVarPath = `/core/image/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific image by providing the image ID.
         * @summary Get Private Image Details
         * @param {number} id 
         * @param {boolean} [includeRelatedVms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage: async (id: number, includeRelatedVms?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImage', 'id', id)
            const localVarPath = `/core/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (includeRelatedVms !== undefined) {
                localVarQueryParameter['include_related_vms'] = includeRelatedVms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all available operating system (OS) images, providing details about each image\'s corresponding virtual machine operating system. You can include the optional `region` parameter in the query string of the request to specifically return OS images from the designated region. Additionally, use the `include_public` parameter to specify whether to include public images in the response. For more information onOS images, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/images).
         * @summary List Images
         * @param {string} [region] Region Name
         * @param {boolean} [includePublic] Flag to include public images in the response (true/false). Default is true.
         * @param {string} [search] Search query to filter images by name
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of Images per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages: async (region?: string, includePublic?: boolean, search?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (includePublic !== undefined) {
                localVarQueryParameter['include_public'] = includePublic;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes an image permanently. Provide the image ID in the path to specify the image to be deleted.
         * @summary Delete an image
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImage(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.deleteImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if an Image name is available
         * @summary Fetch name availability for Images
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchImageNameAvailability(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NameAvailableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchImageNameAvailability(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.fetchImageNameAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific image by providing the image ID.
         * @summary Get Private Image Details
         * @param {number} id 
         * @param {boolean} [includeRelatedVms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImage(id: number, includeRelatedVms?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(id, includeRelatedVms, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all available operating system (OS) images, providing details about each image\'s corresponding virtual machine operating system. You can include the optional `region` parameter in the query string of the request to specifically return OS images from the designated region. Additionally, use the `include_public` parameter to specify whether to include public images in the response. For more information onOS images, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/images).
         * @summary List Images
         * @param {string} [region] Region Name
         * @param {boolean} [includePublic] Flag to include public images in the response (true/false). Default is true.
         * @param {string} [search] Search query to filter images by name
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of Images per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImages(region?: string, includePublic?: boolean, search?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Images>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImages(region, includePublic, search, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.listImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * Deletes an image permanently. Provide the image ID in the path to specify the image to be deleted.
         * @summary Delete an image
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if an Image name is available
         * @summary Fetch name availability for Images
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchImageNameAvailability(name: string, options?: RawAxiosRequestConfig): AxiosPromise<NameAvailableModel> {
            return localVarFp.fetchImageNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific image by providing the image ID.
         * @summary Get Private Image Details
         * @param {number} id 
         * @param {boolean} [includeRelatedVms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage(id: number, includeRelatedVms?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.getImage(id, includeRelatedVms, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all available operating system (OS) images, providing details about each image\'s corresponding virtual machine operating system. You can include the optional `region` parameter in the query string of the request to specifically return OS images from the designated region. Additionally, use the `include_public` parameter to specify whether to include public images in the response. For more information onOS images, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/images).
         * @summary List Images
         * @param {string} [region] Region Name
         * @param {boolean} [includePublic] Flag to include public images in the response (true/false). Default is true.
         * @param {string} [search] Search query to filter images by name
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of Images per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages(region?: string, includePublic?: boolean, search?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Images> {
            return localVarFp.listImages(region, includePublic, search, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * Deletes an image permanently. Provide the image ID in the path to specify the image to be deleted.
     * @summary Delete an image
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteImage(id: number, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).deleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if an Image name is available
     * @summary Fetch name availability for Images
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public fetchImageNameAvailability(name: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).fetchImageNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a specific image by providing the image ID.
     * @summary Get Private Image Details
     * @param {number} id 
     * @param {boolean} [includeRelatedVms] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getImage(id: number, includeRelatedVms?: boolean, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getImage(id, includeRelatedVms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all available operating system (OS) images, providing details about each image\'s corresponding virtual machine operating system. You can include the optional `region` parameter in the query string of the request to specifically return OS images from the designated region. Additionally, use the `include_public` parameter to specify whether to include public images in the response. For more information onOS images, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/images).
     * @summary List Images
     * @param {string} [region] Region Name
     * @param {boolean} [includePublic] Flag to include public images in the response (true/false). Default is true.
     * @param {string} [search] Search query to filter images by name
     * @param {number} [page] Page number for pagination
     * @param {number} [perPage] Number of Images per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public listImages(region?: string, includePublic?: boolean, search?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).listImages(region, includePublic, search, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InviteApi - axios parameter creator
 * @export
 */
export const InviteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept an invitation for a user to join your organization.
         * @summary Accept Invite
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('acceptInvite', 'id', id)
            const localVarPath = `/auth/invites/{id}/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an invitation for a user to join your organization. For additional information on deleting an invitation, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/delete-invite).
         * @summary Accept Invite
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvite', 'id', id)
            const localVarPath = `/auth/invites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invites a user to join your organization. For additional information on inviting users to the organization, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/invite-member).
         * @summary Invite User to Organization
         * @param {InviteUserPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToOrganization: async (payload: InviteUserPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('inviteUserToOrganization', 'payload', payload)
            const localVarPath = `/auth/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of email invitations from your organization. For additional information on listing invited users, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/list-invites).
         * @summary List Invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvites: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteApi - functional programming interface
 * @export
 */
export const InviteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InviteApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept an invitation for a user to join your organization.
         * @summary Accept Invite
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteApi.acceptInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an invitation for a user to join your organization. For additional information on deleting an invitation, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/delete-invite).
         * @summary Accept Invite
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvite(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvite(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteApi.deleteInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invites a user to join your organization. For additional information on inviting users to the organization, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/invite-member).
         * @summary Invite User to Organization
         * @param {InviteUserPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUserToOrganization(payload: InviteUserPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteUserResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUserToOrganization(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteApi.inviteUserToOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of email invitations from your organization. For additional information on listing invited users, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/list-invites).
         * @summary List Invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvites(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvitesResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvites(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteApi.listInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InviteApi - factory interface
 * @export
 */
export const InviteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InviteApiFp(configuration)
    return {
        /**
         * Accept an invitation for a user to join your organization.
         * @summary Accept Invite
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(id: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponseModel> {
            return localVarFp.acceptInvite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an invitation for a user to join your organization. For additional information on deleting an invitation, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/delete-invite).
         * @summary Accept Invite
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite(id: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponseModel> {
            return localVarFp.deleteInvite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Invites a user to join your organization. For additional information on inviting users to the organization, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/invite-member).
         * @summary Invite User to Organization
         * @param {InviteUserPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToOrganization(payload: InviteUserPayload, options?: RawAxiosRequestConfig): AxiosPromise<InviteUserResponseModel> {
            return localVarFp.inviteUserToOrganization(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of email invitations from your organization. For additional information on listing invited users, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/list-invites).
         * @summary List Invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvites(options?: RawAxiosRequestConfig): AxiosPromise<GetInvitesResponseModel> {
            return localVarFp.listInvites(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InviteApi - object-oriented interface
 * @export
 * @class InviteApi
 * @extends {BaseAPI}
 */
export class InviteApi extends BaseAPI {
    /**
     * Accept an invitation for a user to join your organization.
     * @summary Accept Invite
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public acceptInvite(id: number, options?: RawAxiosRequestConfig) {
        return InviteApiFp(this.configuration).acceptInvite(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an invitation for a user to join your organization. For additional information on deleting an invitation, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/delete-invite).
     * @summary Accept Invite
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public deleteInvite(id: number, options?: RawAxiosRequestConfig) {
        return InviteApiFp(this.configuration).deleteInvite(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invites a user to join your organization. For additional information on inviting users to the organization, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/invite-member).
     * @summary Invite User to Organization
     * @param {InviteUserPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public inviteUserToOrganization(payload: InviteUserPayload, options?: RawAxiosRequestConfig) {
        return InviteApiFp(this.configuration).inviteUserToOrganization(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of email invitations from your organization. For additional information on listing invited users, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/invites/list-invites).
     * @summary List Invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    public listInvites(options?: RawAxiosRequestConfig) {
        return InviteApiFp(this.configuration).listInvites(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KeypairApi - axios parameter creator
 * @export
 */
export const KeypairApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permanently deletes a specified key pair. Provide the key pair ID in the path to remove the designated key pair.
         * @summary Delete key pair
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeyPair: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKeyPair', 'id', id)
            const localVarPath = `/core/keypair/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports a new key pair for secure shell (SSH) access to your resources. Provide the key name, environment name, and public key in the request body. For more details on importing SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/import-keypair).
         * @summary Import key pair
         * @param {ImportKeypairPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importKeyPair: async (payload: ImportKeypairPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('importKeyPair', 'payload', payload)
            const localVarPath = `/core/keypairs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of your existing SSH key pairs, providing details for each. For more information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
         * @summary List key pairs
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeyPairs: async (page?: string, pageSize?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/keypairs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the name of a specified key pair. Provide the key pair ID in the path, and include the new `name` in the request body.
         * @summary Update key pair name
         * @param {number} id 
         * @param {UpdateKeypairName} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyPairName: async (id: number, payload: UpdateKeypairName, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKeyPairName', 'id', id)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateKeyPairName', 'payload', payload)
            const localVarPath = `/core/keypair/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeypairApi - functional programming interface
 * @export
 */
export const KeypairApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeypairApiAxiosParamCreator(configuration)
    return {
        /**
         * Permanently deletes a specified key pair. Provide the key pair ID in the path to remove the designated key pair.
         * @summary Delete key pair
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKeyPair(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKeyPair(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeypairApi.deleteKeyPair']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Imports a new key pair for secure shell (SSH) access to your resources. Provide the key name, environment name, and public key in the request body. For more details on importing SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/import-keypair).
         * @summary Import key pair
         * @param {ImportKeypairPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importKeyPair(payload: ImportKeypairPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportKeypairResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importKeyPair(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeypairApi.importKeyPair']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of your existing SSH key pairs, providing details for each. For more information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
         * @summary List key pairs
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeyPairs(page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keypairs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeyPairs(page, pageSize, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeypairApi.listKeyPairs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the name of a specified key pair. Provide the key pair ID in the path, and include the new `name` in the request body.
         * @summary Update key pair name
         * @param {number} id 
         * @param {UpdateKeypairName} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKeyPairName(id: number, payload: UpdateKeypairName, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateKeypairNameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKeyPairName(id, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeypairApi.updateKeyPairName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KeypairApi - factory interface
 * @export
 */
export const KeypairApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeypairApiFp(configuration)
    return {
        /**
         * Permanently deletes a specified key pair. Provide the key pair ID in the path to remove the designated key pair.
         * @summary Delete key pair
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeyPair(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteKeyPair(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports a new key pair for secure shell (SSH) access to your resources. Provide the key name, environment name, and public key in the request body. For more details on importing SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/import-keypair).
         * @summary Import key pair
         * @param {ImportKeypairPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importKeyPair(payload: ImportKeypairPayload, options?: RawAxiosRequestConfig): AxiosPromise<ImportKeypairResponse> {
            return localVarFp.importKeyPair(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of your existing SSH key pairs, providing details for each. For more information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
         * @summary List key pairs
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeyPairs(page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<Keypairs> {
            return localVarFp.listKeyPairs(page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the name of a specified key pair. Provide the key pair ID in the path, and include the new `name` in the request body.
         * @summary Update key pair name
         * @param {number} id 
         * @param {UpdateKeypairName} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyPairName(id: number, payload: UpdateKeypairName, options?: RawAxiosRequestConfig): AxiosPromise<UpdateKeypairNameResponse> {
            return localVarFp.updateKeyPairName(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeypairApi - object-oriented interface
 * @export
 * @class KeypairApi
 * @extends {BaseAPI}
 */
export class KeypairApi extends BaseAPI {
    /**
     * Permanently deletes a specified key pair. Provide the key pair ID in the path to remove the designated key pair.
     * @summary Delete key pair
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    public deleteKeyPair(id: number, options?: RawAxiosRequestConfig) {
        return KeypairApiFp(this.configuration).deleteKeyPair(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports a new key pair for secure shell (SSH) access to your resources. Provide the key name, environment name, and public key in the request body. For more details on importing SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/import-keypair).
     * @summary Import key pair
     * @param {ImportKeypairPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    public importKeyPair(payload: ImportKeypairPayload, options?: RawAxiosRequestConfig) {
        return KeypairApiFp(this.configuration).importKeyPair(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of your existing SSH key pairs, providing details for each. For more information on SSH key pairs, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/keypairs/).
     * @summary List key pairs
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    public listKeyPairs(page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig) {
        return KeypairApiFp(this.configuration).listKeyPairs(page, pageSize, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the name of a specified key pair. Provide the key pair ID in the path, and include the new `name` in the request body.
     * @summary Update key pair name
     * @param {number} id 
     * @param {UpdateKeypairName} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeypairApi
     */
    public updateKeyPairName(id: number, payload: UpdateKeypairName, options?: RawAxiosRequestConfig) {
        return KeypairApiFp(this.configuration).updateKeyPairName(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a member from your organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/remove-member).
         * @summary Remove Organization Member
         * @param {RemoveMemberPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationMember: async (payload: RemoveMemberPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('removeOrganizationMember', 'payload', payload)
            const localVarPath = `/auth/organizations/remove-member`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about your organization, including current credit, threshold, number of instances, and number of volumes. For additional information on organizations, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/retrieve-org-details).
         * @summary Retrieve Organization Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrganizationInformation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the name of the organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/update-org-name).
         * @summary Update Organization Information
         * @param {UpdateOrganizationPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationInformation: async (payload: UpdateOrganizationPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateOrganizationInformation', 'payload', payload)
            const localVarPath = `/auth/organizations/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes a member from your organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/remove-member).
         * @summary Remove Organization Member
         * @param {RemoveMemberPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrganizationMember(payload: RemoveMemberPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveMemberFromOrganizationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrganizationMember(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.removeOrganizationMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about your organization, including current credit, threshold, number of instances, and number of volumes. For additional information on organizations, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/retrieve-org-details).
         * @summary Retrieve Organization Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOrganizationInformation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganizationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOrganizationInformation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.retrieveOrganizationInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the name of the organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/update-org-name).
         * @summary Update Organization Information
         * @param {UpdateOrganizationPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationInformation(payload: UpdateOrganizationPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateOrganizationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationInformation(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganizationInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * Removes a member from your organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/remove-member).
         * @summary Remove Organization Member
         * @param {RemoveMemberPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationMember(payload: RemoveMemberPayload, options?: RawAxiosRequestConfig): AxiosPromise<RemoveMemberFromOrganizationResponseModel> {
            return localVarFp.removeOrganizationMember(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about your organization, including current credit, threshold, number of instances, and number of volumes. For additional information on organizations, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/retrieve-org-details).
         * @summary Retrieve Organization Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrganizationInformation(options?: RawAxiosRequestConfig): AxiosPromise<GetOrganizationResponseModel> {
            return localVarFp.retrieveOrganizationInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the name of the organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/update-org-name).
         * @summary Update Organization Information
         * @param {UpdateOrganizationPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationInformation(payload: UpdateOrganizationPayload, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrganizationResponseModel> {
            return localVarFp.updateOrganizationInformation(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Removes a member from your organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/remove-member).
     * @summary Remove Organization Member
     * @param {RemoveMemberPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public removeOrganizationMember(payload: RemoveMemberPayload, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).removeOrganizationMember(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about your organization, including current credit, threshold, number of instances, and number of volumes. For additional information on organizations, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/retrieve-org-details).
     * @summary Retrieve Organization Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public retrieveOrganizationInformation(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).retrieveOrganizationInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the name of the organization. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/organization/update-org-name).
     * @summary Update Organization Information
     * @param {UpdateOrganizationPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganizationInformation(payload: UpdateOrganizationPayload, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganizationInformation(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerConfigApi - axios parameter creator
 * @export
 */
export const PartnerConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch the customised customer configuration for Hyperstack.
         * @summary Get partner config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/partner-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the partner config for a given domain.
         * @param {string} [domain] The domain to look up the partner config for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfigByDomain: async (domain?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/partner-config/docs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerConfigApi - functional programming interface
 * @export
 */
export const PartnerConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch the customised customer configuration for Hyperstack.
         * @summary Get partner config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartnerConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartnerConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerConfigApi.getPartnerConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch the partner config for a given domain.
         * @param {string} [domain] The domain to look up the partner config for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartnerConfigByDomain(domain?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartnerConfigByDomain(domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerConfigApi.getPartnerConfigByDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerConfigApi - factory interface
 * @export
 */
export const PartnerConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerConfigApiFp(configuration)
    return {
        /**
         * Fetch the customised customer configuration for Hyperstack.
         * @summary Get partner config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfig(options?: RawAxiosRequestConfig): AxiosPromise<PartnerConfig> {
            return localVarFp.getPartnerConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the partner config for a given domain.
         * @param {string} [domain] The domain to look up the partner config for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerConfigByDomain(domain?: string, options?: RawAxiosRequestConfig): AxiosPromise<PartnerConfig> {
            return localVarFp.getPartnerConfigByDomain(domain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerConfigApi - object-oriented interface
 * @export
 * @class PartnerConfigApi
 * @extends {BaseAPI}
 */
export class PartnerConfigApi extends BaseAPI {
    /**
     * Fetch the customised customer configuration for Hyperstack.
     * @summary Get partner config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerConfigApi
     */
    public getPartnerConfig(options?: RawAxiosRequestConfig) {
        return PartnerConfigApiFp(this.configuration).getPartnerConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the partner config for a given domain.
     * @param {string} [domain] The domain to look up the partner config for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerConfigApi
     */
    public getPartnerConfigByDomain(domain?: string, options?: RawAxiosRequestConfig) {
        return PartnerConfigApiFp(this.configuration).getPartnerConfigByDomain(domain, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the payment receipt from Stripe for a specific payment
         * @summary Retrieve Payment Receipt
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentReceipt: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPaymentReceipt', 'paymentId', paymentId)
            const localVarPath = `/billing/payment/receipt/{payment_id}`
                .replace(`{${"payment_id"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a payment for a specified amount, adding credit to the balance of your [**organization**](/docs/rbac/organization). Include the `amount` in the body of the request to make a payment for the specified value in dollars. View a history of past payments by calling the [**Retrieve Payment History**](/docs/api-reference/billing-resources/retrieve-payment-history) API. For additional information [**click here**](None/docs/api-reference/billing-resources/create-payment).
         * @summary POST: Initiate payment
         * @param {PaymentInitiatePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiatePayment: async (payload: PaymentInitiatePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('initiatePayment', 'payload', payload)
            const localVarPath = `/billing/payment/payment-initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all payments made within your [**organization**](/docs/rbac/organization) and their details, including the amount, payment status, and more. For additional information [**click here**](None/docs/api-reference/billing-resources/retrieve-payment-history/).
         * @summary GET: View payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentDetails: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/payment/payment-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the payment receipt from Stripe for a specific payment
         * @summary Retrieve Payment Receipt
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentReceipt(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentReceipt(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.getPaymentReceipt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a payment for a specified amount, adding credit to the balance of your [**organization**](/docs/rbac/organization). Include the `amount` in the body of the request to make a payment for the specified value in dollars. View a history of past payments by calling the [**Retrieve Payment History**](/docs/api-reference/billing-resources/retrieve-payment-history) API. For additional information [**click here**](None/docs/api-reference/billing-resources/create-payment).
         * @summary POST: Initiate payment
         * @param {PaymentInitiatePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiatePayment(payload: PaymentInitiatePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentInitiateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiatePayment(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.initiatePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all payments made within your [**organization**](/docs/rbac/organization) and their details, including the amount, payment status, and more. For additional information [**click here**](None/docs/api-reference/billing-resources/retrieve-payment-history/).
         * @summary GET: View payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentDetails(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentDetails(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.listPaymentDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * Retrieve the payment receipt from Stripe for a specific payment
         * @summary Retrieve Payment Receipt
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentReceipt(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPaymentReceipt(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a payment for a specified amount, adding credit to the balance of your [**organization**](/docs/rbac/organization). Include the `amount` in the body of the request to make a payment for the specified value in dollars. View a history of past payments by calling the [**Retrieve Payment History**](/docs/api-reference/billing-resources/retrieve-payment-history) API. For additional information [**click here**](None/docs/api-reference/billing-resources/create-payment).
         * @summary POST: Initiate payment
         * @param {PaymentInitiatePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiatePayment(payload: PaymentInitiatePayload, options?: RawAxiosRequestConfig): AxiosPromise<PaymentInitiateResponse> {
            return localVarFp.initiatePayment(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all payments made within your [**organization**](/docs/rbac/organization) and their details, including the amount, payment status, and more. For additional information [**click here**](None/docs/api-reference/billing-resources/retrieve-payment-history/).
         * @summary GET: View payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentDetails(options?: RawAxiosRequestConfig): AxiosPromise<PaymentDetailsResponse> {
            return localVarFp.listPaymentDetails(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * Retrieve the payment receipt from Stripe for a specific payment
     * @summary Retrieve Payment Receipt
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentReceipt(paymentId: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getPaymentReceipt(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a payment for a specified amount, adding credit to the balance of your [**organization**](/docs/rbac/organization). Include the `amount` in the body of the request to make a payment for the specified value in dollars. View a history of past payments by calling the [**Retrieve Payment History**](/docs/api-reference/billing-resources/retrieve-payment-history) API. For additional information [**click here**](None/docs/api-reference/billing-resources/create-payment).
     * @summary POST: Initiate payment
     * @param {PaymentInitiatePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public initiatePayment(payload: PaymentInitiatePayload, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).initiatePayment(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all payments made within your [**organization**](/docs/rbac/organization) and their details, including the amount, payment status, and more. For additional information [**click here**](None/docs/api-reference/billing-resources/retrieve-payment-history/).
     * @summary GET: View payment details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public listPaymentDetails(options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).listPaymentDetails(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionApi - axios parameter creator
 * @export
 */
export const PermissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of permissions that users can be granted to access a particular resource action. For additional information on permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/permissions).
         * @summary List Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionApi - functional programming interface
 * @export
 */
export const PermissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of permissions that users can be granted to access a particular resource action. For additional information on permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/permissions).
         * @summary List Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPermissionsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.listPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionApi - factory interface
 * @export
 */
export const PermissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionApiFp(configuration)
    return {
        /**
         * Retrieves a list of permissions that users can be granted to access a particular resource action. For additional information on permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/permissions).
         * @summary List Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(options?: RawAxiosRequestConfig): AxiosPromise<GetPermissionsResponseModel> {
            return localVarFp.listPermissions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionApi - object-oriented interface
 * @export
 * @class PermissionApi
 * @extends {BaseAPI}
 */
export class PermissionApi extends BaseAPI {
    /**
     * Retrieves a list of permissions that users can be granted to access a particular resource action. For additional information on permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/permissions).
     * @summary List Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public listPermissions(options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).listPermissions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PolicyApi - axios parameter creator
 * @export
 */
export const PolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of policies available for addition to RBAC roles. For additional information on policies, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/policies).
         * @summary List Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyApi - functional programming interface
 * @export
 */
export const PolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of policies available for addition to RBAC roles. For additional information on policies, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/policies).
         * @summary List Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPolicies(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPoliciesResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPolicies(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PolicyApi.listPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PolicyApi - factory interface
 * @export
 */
export const PolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicyApiFp(configuration)
    return {
        /**
         * Retrieves a list of policies available for addition to RBAC roles. For additional information on policies, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/policies).
         * @summary List Policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(options?: RawAxiosRequestConfig): AxiosPromise<GetPoliciesResponseModel> {
            return localVarFp.listPolicies(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolicyApi - object-oriented interface
 * @export
 * @class PolicyApi
 * @extends {BaseAPI}
 */
export class PolicyApi extends BaseAPI {
    /**
     * Retrieves a list of policies available for addition to RBAC roles. For additional information on policies, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/policies).
     * @summary List Policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public listPolicies(options?: RawAxiosRequestConfig) {
        return PolicyApiFp(this.configuration).listPolicies(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PricebookApi - axios parameter creator
 * @export
 */
export const PricebookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the Infrahub Pricebook, detailing hourly running costs for all resources offered by Infrahub. For more information on Pricebook [**click here**](None/docs/api-reference/pricebook-resources/pricebook/).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricebook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pricebook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricebookApi - functional programming interface
 * @export
 */
export const PricebookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricebookApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the Infrahub Pricebook, detailing hourly running costs for all resources offered by Infrahub. For more information on Pricebook [**click here**](None/docs/api-reference/pricebook-resources/pricebook/).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricebook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PricebookModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricebook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PricebookApi.getPricebook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PricebookApi - factory interface
 * @export
 */
export const PricebookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricebookApiFp(configuration)
    return {
        /**
         * Retrieves the Infrahub Pricebook, detailing hourly running costs for all resources offered by Infrahub. For more information on Pricebook [**click here**](None/docs/api-reference/pricebook-resources/pricebook/).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricebook(options?: RawAxiosRequestConfig): AxiosPromise<Array<PricebookModel>> {
            return localVarFp.getPricebook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricebookApi - object-oriented interface
 * @export
 * @class PricebookApi
 * @extends {BaseAPI}
 */
export class PricebookApi extends BaseAPI {
    /**
     * Retrieves the Infrahub Pricebook, detailing hourly running costs for all resources offered by Infrahub. For more information on Pricebook [**click here**](None/docs/api-reference/pricebook-resources/pricebook/).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricebookApi
     */
    public getPricebook(options?: RawAxiosRequestConfig) {
        return PricebookApiFp(this.configuration).getPricebook(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a provisioning profile to save the configuration of a virtual machinefor future use. Include the profile name, description, and virtual machine configuration details in the request body. For more information about virtual machine profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Create profile
         * @param {CreateProfilePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (payload: CreateProfilePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createProfile', 'payload', payload)
            const localVarPath = `/core/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a provisioning profile. Supply the profile ID in the path to delete the specified profile.
         * @summary Delete profile
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProfile', 'id', id)
            const localVarPath = `/core/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details for an existing provisioning profile by supplying the profile ID in the request path. For more information about profiles, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Retrieve profile details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProfile', 'id', id)
            const localVarPath = `/core/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your existing provisioning profiles, providing virtual machine configuration details for each. For additional information about profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles#load-a-provisioning-profile).
         * @summary List profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a provisioning profile to save the configuration of a virtual machinefor future use. Include the profile name, description, and virtual machine configuration details in the request body. For more information about virtual machine profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Create profile
         * @param {CreateProfilePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(payload: CreateProfilePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfile(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.createProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a provisioning profile. Supply the profile ID in the path to delete the specified profile.
         * @summary Delete profile
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfile(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.deleteProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves details for an existing provisioning profile by supplying the profile ID in the request path. For more information about profiles, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Retrieve profile details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.getProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of your existing provisioning profiles, providing virtual machine configuration details for each. For additional information about profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles#load-a-provisioning-profile).
         * @summary List profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProfiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProfiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.listProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Creates a provisioning profile to save the configuration of a virtual machinefor future use. Include the profile name, description, and virtual machine configuration details in the request body. For more information about virtual machine profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Create profile
         * @param {CreateProfilePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(payload: CreateProfilePayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateProfileResponse> {
            return localVarFp.createProfile(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a provisioning profile. Supply the profile ID in the path to delete the specified profile.
         * @summary Delete profile
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details for an existing provisioning profile by supplying the profile ID in the request path. For more information about profiles, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
         * @summary Retrieve profile details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(id: number, options?: RawAxiosRequestConfig): AxiosPromise<CreateProfileResponse> {
            return localVarFp.getProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your existing provisioning profiles, providing virtual machine configuration details for each. For additional information about profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles#load-a-provisioning-profile).
         * @summary List profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles(options?: RawAxiosRequestConfig): AxiosPromise<ProfileListResponse> {
            return localVarFp.listProfiles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Creates a provisioning profile to save the configuration of a virtual machinefor future use. Include the profile name, description, and virtual machine configuration details in the request body. For more information about virtual machine profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
     * @summary Create profile
     * @param {CreateProfilePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public createProfile(payload: CreateProfilePayload, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).createProfile(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a provisioning profile. Supply the profile ID in the path to delete the specified profile.
     * @summary Delete profile
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public deleteProfile(id: number, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).deleteProfile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves details for an existing provisioning profile by supplying the profile ID in the request path. For more information about profiles, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles).
     * @summary Retrieve profile details
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfile(id: number, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getProfile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your existing provisioning profiles, providing virtual machine configuration details for each. For additional information about profiles,[**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/provisioning-profiles#load-a-provisioning-profile).
     * @summary List profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public listProfiles(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).listProfiles(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RbacRoleApi - axios parameter creator
 * @export
 */
export const RbacRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an RBAC role that can be assigned to users, granting them access to specific resource actions. Provide the configuration of the RBAC role, including its name, description, and list of permissions and policy IDs in the request body. For additional information on creating RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/create-rbac-role).
         * @summary Create RBAC Role
         * @param {CreateUpdateRbacRolePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRBACRole: async (payload: CreateUpdateRbacRolePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createRBACRole', 'payload', payload)
            const localVarPath = `/auth/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an RBAC role by providing its ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/delete-rbac-role).
         * @summary Delete RBAC Role
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRBACRole: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRBACRole', 'id', id)
            const localVarPath = `/auth/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of RBAC roles that can be assigned to the users within an organization. For additional information on RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/list-rbac-roles).
         * @summary List RBAC Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRBACRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a specified RBAC role by providing the RBAC role ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/retrieve-rbac-details).
         * @summary Retrieve RBAC Role Details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRBACRoleDetails: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRBACRoleDetails', 'id', id)
            const localVarPath = `/auth/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an RBAC role by providing the role ID in the path and the modified role configuration in the request body, including its name, description, and list of permissions and policy IDs. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/update-rbac-role).
         * @summary Update RBAC Role
         * @param {number} id 
         * @param {CreateUpdateRbacRolePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRBACRole: async (id: number, payload: CreateUpdateRbacRolePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRBACRole', 'id', id)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateRBACRole', 'payload', payload)
            const localVarPath = `/auth/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RbacRoleApi - functional programming interface
 * @export
 */
export const RbacRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RbacRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an RBAC role that can be assigned to users, granting them access to specific resource actions. Provide the configuration of the RBAC role, including its name, description, and list of permissions and policy IDs in the request body. For additional information on creating RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/create-rbac-role).
         * @summary Create RBAC Role
         * @param {CreateUpdateRbacRolePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRBACRole(payload: CreateUpdateRbacRolePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacRoleDetailResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRBACRole(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RbacRoleApi.createRBACRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an RBAC role by providing its ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/delete-rbac-role).
         * @summary Delete RBAC Role
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRBACRole(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRBACRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RbacRoleApi.deleteRBACRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of RBAC roles that can be assigned to the users within an organization. For additional information on RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/list-rbac-roles).
         * @summary List RBAC Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRBACRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRbacRolesResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRBACRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RbacRoleApi.listRBACRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a specified RBAC role by providing the RBAC role ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/retrieve-rbac-details).
         * @summary Retrieve RBAC Role Details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRBACRoleDetails(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacRoleDetailResponseModelFixed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRBACRoleDetails(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RbacRoleApi.retrieveRBACRoleDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an RBAC role by providing the role ID in the path and the modified role configuration in the request body, including its name, description, and list of permissions and policy IDs. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/update-rbac-role).
         * @summary Update RBAC Role
         * @param {number} id 
         * @param {CreateUpdateRbacRolePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRBACRole(id: number, payload: CreateUpdateRbacRolePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacRoleDetailResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRBACRole(id, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RbacRoleApi.updateRBACRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RbacRoleApi - factory interface
 * @export
 */
export const RbacRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RbacRoleApiFp(configuration)
    return {
        /**
         * Creates an RBAC role that can be assigned to users, granting them access to specific resource actions. Provide the configuration of the RBAC role, including its name, description, and list of permissions and policy IDs in the request body. For additional information on creating RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/create-rbac-role).
         * @summary Create RBAC Role
         * @param {CreateUpdateRbacRolePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRBACRole(payload: CreateUpdateRbacRolePayload, options?: RawAxiosRequestConfig): AxiosPromise<RbacRoleDetailResponseModel> {
            return localVarFp.createRBACRole(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an RBAC role by providing its ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/delete-rbac-role).
         * @summary Delete RBAC Role
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRBACRole(id: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonResponseModel> {
            return localVarFp.deleteRBACRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of RBAC roles that can be assigned to the users within an organization. For additional information on RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/list-rbac-roles).
         * @summary List RBAC Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRBACRoles(options?: RawAxiosRequestConfig): AxiosPromise<GetRbacRolesResponseModel> {
            return localVarFp.listRBACRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a specified RBAC role by providing the RBAC role ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/retrieve-rbac-details).
         * @summary Retrieve RBAC Role Details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRBACRoleDetails(id: number, options?: RawAxiosRequestConfig): AxiosPromise<RbacRoleDetailResponseModelFixed> {
            return localVarFp.retrieveRBACRoleDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an RBAC role by providing the role ID in the path and the modified role configuration in the request body, including its name, description, and list of permissions and policy IDs. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/update-rbac-role).
         * @summary Update RBAC Role
         * @param {number} id 
         * @param {CreateUpdateRbacRolePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRBACRole(id: number, payload: CreateUpdateRbacRolePayload, options?: RawAxiosRequestConfig): AxiosPromise<RbacRoleDetailResponseModel> {
            return localVarFp.updateRBACRole(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RbacRoleApi - object-oriented interface
 * @export
 * @class RbacRoleApi
 * @extends {BaseAPI}
 */
export class RbacRoleApi extends BaseAPI {
    /**
     * Creates an RBAC role that can be assigned to users, granting them access to specific resource actions. Provide the configuration of the RBAC role, including its name, description, and list of permissions and policy IDs in the request body. For additional information on creating RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/create-rbac-role).
     * @summary Create RBAC Role
     * @param {CreateUpdateRbacRolePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    public createRBACRole(payload: CreateUpdateRbacRolePayload, options?: RawAxiosRequestConfig) {
        return RbacRoleApiFp(this.configuration).createRBACRole(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an RBAC role by providing its ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/delete-rbac-role).
     * @summary Delete RBAC Role
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    public deleteRBACRole(id: number, options?: RawAxiosRequestConfig) {
        return RbacRoleApiFp(this.configuration).deleteRBACRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of RBAC roles that can be assigned to the users within an organization. For additional information on RBAC roles, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/list-rbac-roles).
     * @summary List RBAC Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    public listRBACRoles(options?: RawAxiosRequestConfig) {
        return RbacRoleApiFp(this.configuration).listRBACRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a specified RBAC role by providing the RBAC role ID in the path. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/retrieve-rbac-details).
     * @summary Retrieve RBAC Role Details
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    public retrieveRBACRoleDetails(id: number, options?: RawAxiosRequestConfig) {
        return RbacRoleApiFp(this.configuration).retrieveRBACRoleDetails(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an RBAC role by providing the role ID in the path and the modified role configuration in the request body, including its name, description, and list of permissions and policy IDs. For additional information, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/rbac/update-rbac-role).
     * @summary Update RBAC Role
     * @param {number} id 
     * @param {CreateUpdateRbacRolePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacRoleApi
     */
    public updateRBACRole(id: number, payload: CreateUpdateRbacRolePayload, options?: RawAxiosRequestConfig) {
        return RbacRoleApiFp(this.configuration).updateRBACRole(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RegionApi - axios parameter creator
 * @export
 */
export const RegionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists the currently available regions, each representing a distinct geographic  location housing a data center. For additional information on regions, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/regions).
         * @summary List Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionApi - functional programming interface
 * @export
 */
export const RegionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegionApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists the currently available regions, each representing a distinct geographic  location housing a data center. For additional information on regions, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/regions).
         * @summary List Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRegions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Regions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRegions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegionApi.listRegions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RegionApi - factory interface
 * @export
 */
export const RegionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegionApiFp(configuration)
    return {
        /**
         * Lists the currently available regions, each representing a distinct geographic  location housing a data center. For additional information on regions, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/regions).
         * @summary List Regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegions(options?: RawAxiosRequestConfig): AxiosPromise<Regions> {
            return localVarFp.listRegions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegionApi - object-oriented interface
 * @export
 * @class RegionApi
 * @extends {BaseAPI}
 */
export class RegionApi extends BaseAPI {
    /**
     * Lists the currently available regions, each representing a distinct geographic  location housing a data center. For additional information on regions, [**click here**](https://docs.hyperstack.cloud/docs/resource-management/regions).
     * @summary List Regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public listRegions(options?: RawAxiosRequestConfig) {
        return RegionApiFp(this.configuration).listRegions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityRulesApi - axios parameter creator
 * @export
 */
export const SecurityRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available protocols that can be used in the creation of firewall rules for your virtual machines.
         * @summary List firewall rule protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFirewallRuleProtocols: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/sg-rules-protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityRulesApi - functional programming interface
 * @export
 */
export const SecurityRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all available protocols that can be used in the creation of firewall rules for your virtual machines.
         * @summary List firewall rule protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFirewallRuleProtocols(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityRulesProtocolFields>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFirewallRuleProtocols(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityRulesApi.listFirewallRuleProtocols']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityRulesApi - factory interface
 * @export
 */
export const SecurityRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityRulesApiFp(configuration)
    return {
        /**
         * Returns a list of all available protocols that can be used in the creation of firewall rules for your virtual machines.
         * @summary List firewall rule protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFirewallRuleProtocols(options?: RawAxiosRequestConfig): AxiosPromise<SecurityRulesProtocolFields> {
            return localVarFp.listFirewallRuleProtocols(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityRulesApi - object-oriented interface
 * @export
 * @class SecurityRulesApi
 * @extends {BaseAPI}
 */
export class SecurityRulesApi extends BaseAPI {
    /**
     * Returns a list of all available protocols that can be used in the creation of firewall rules for your virtual machines.
     * @summary List firewall rule protocols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityRulesApi
     */
    public listFirewallRuleProtocols(options?: RawAxiosRequestConfig) {
        return SecurityRulesApiFp(this.configuration).listFirewallRuleProtocols(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SnapshotEventsApi - axios parameter creator
 * @export
 */
export const SnapshotEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all events for a Snapshot\'s history, which records actions performed on the specific snapshot. Requires the snapshot ID in the path.
         * @summary Fetch all events for a snapshot
         * @param {number} snapshotId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshotEvents: async (snapshotId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('listSnapshotEvents', 'snapshotId', snapshotId)
            const localVarPath = `/core/snapshots/{snapshot_id}/events`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnapshotEventsApi - functional programming interface
 * @export
 */
export const SnapshotEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SnapshotEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all events for a Snapshot\'s history, which records actions performed on the specific snapshot. Requires the snapshot ID in the path.
         * @summary Fetch all events for a snapshot
         * @param {number} snapshotId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSnapshotEvents(snapshotId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSnapshotEvents(snapshotId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotEventsApi.listSnapshotEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SnapshotEventsApi - factory interface
 * @export
 */
export const SnapshotEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SnapshotEventsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all events for a Snapshot\'s history, which records actions performed on the specific snapshot. Requires the snapshot ID in the path.
         * @summary Fetch all events for a snapshot
         * @param {number} snapshotId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshotEvents(snapshotId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listSnapshotEvents(snapshotId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SnapshotEventsApi - object-oriented interface
 * @export
 * @class SnapshotEventsApi
 * @extends {BaseAPI}
 */
export class SnapshotEventsApi extends BaseAPI {
    /**
     * Retrieves a list of all events for a Snapshot\'s history, which records actions performed on the specific snapshot. Requires the snapshot ID in the path.
     * @summary Fetch all events for a snapshot
     * @param {number} snapshotId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotEventsApi
     */
    public listSnapshotEvents(snapshotId: number, options?: RawAxiosRequestConfig) {
        return SnapshotEventsApiFp(this.configuration).listSnapshotEvents(snapshotId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SnapshotsApi - axios parameter creator
 * @export
 */
export const SnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new custom image from an existing snapshot.Requires a name and any labels for your new custom image.
         * @summary Create an image from a snapshot
         * @param {number} snapshotId 
         * @param {CreateImagePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomImage: async (snapshotId: number, payload: CreateImagePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('createCustomImage', 'snapshotId', snapshotId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createCustomImage', 'payload', payload)
            const localVarPath = `/core/snapshots/{snapshot_id}/image`
                .replace(`{${"snapshot_id"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a snapshot. Provide the snapshot ID in the path to delete the specified snapshot. If the snapshot is connected with an image, that image will also bedeleted and the deleted image ID will be returned in the success message response.
         * @summary Delete snapshot
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSnapshot', 'id', id)
            const localVarPath = `/core/snapshots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a Snapshot name is available
         * @summary Fetch snapshot name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSnapshotNameAvailability: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('fetchSnapshotNameAvailability', 'name', name)
            const localVarPath = `/core/snapshots/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a snapshot.
         * @summary Retrieve a snapshot
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSnapshot', 'id', id)
            const localVarPath = `/core/snapshots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of snapshots, providing details such as snapshot name, timestamp, VM ID, and other relevant information.
         * @summary Retrieve list of snapshots with pagination
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Snapshot ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshots: async (page?: string, pageSize?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a snapshot.
         * @summary Restore a snapshot
         * @param {number} id 
         * @param {SnapshotRestoreRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshot: async (id: number, payload: SnapshotRestoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('restoreSnapshot', 'id', id)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('restoreSnapshot', 'payload', payload)
            const localVarPath = `/core/snapshots/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnapshotsApi - functional programming interface
 * @export
 */
export const SnapshotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SnapshotsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new custom image from an existing snapshot.Requires a name and any labels for your new custom image.
         * @summary Create an image from a snapshot
         * @param {number} snapshotId 
         * @param {CreateImagePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomImage(snapshotId: number, payload: CreateImagePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomImage(snapshotId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.createCustomImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a snapshot. Provide the snapshot ID in the path to delete the specified snapshot. If the snapshot is connected with an image, that image will also bedeleted and the deleted image ID will be returned in the success message response.
         * @summary Delete snapshot
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSnapshot(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSnapshot(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.deleteSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if a Snapshot name is available
         * @summary Fetch snapshot name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchSnapshotNameAvailability(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NameAvailableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchSnapshotNameAvailability(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.fetchSnapshotNameAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a snapshot.
         * @summary Retrieve a snapshot
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshot(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapshotRetrieve>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshot(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.getSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of snapshots, providing details such as snapshot name, timestamp, VM ID, and other relevant information.
         * @summary Retrieve list of snapshots with pagination
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Snapshot ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSnapshots(page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snapshots>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSnapshots(page, pageSize, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.listSnapshots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a snapshot.
         * @summary Restore a snapshot
         * @param {number} id 
         * @param {SnapshotRestoreRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreSnapshot(id: number, payload: SnapshotRestoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreSnapshot(id, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.restoreSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SnapshotsApi - factory interface
 * @export
 */
export const SnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SnapshotsApiFp(configuration)
    return {
        /**
         * Create a new custom image from an existing snapshot.Requires a name and any labels for your new custom image.
         * @summary Create an image from a snapshot
         * @param {number} snapshotId 
         * @param {CreateImagePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomImage(snapshotId: number, payload: CreateImagePayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateImage> {
            return localVarFp.createCustomImage(snapshotId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a snapshot. Provide the snapshot ID in the path to delete the specified snapshot. If the snapshot is connected with an image, that image will also bedeleted and the deleted image ID will be returned in the success message response.
         * @summary Delete snapshot
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteSnapshot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Snapshot name is available
         * @summary Fetch snapshot name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchSnapshotNameAvailability(name: string, options?: RawAxiosRequestConfig): AxiosPromise<NameAvailableModel> {
            return localVarFp.fetchSnapshotNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a snapshot.
         * @summary Retrieve a snapshot
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SnapshotRetrieve> {
            return localVarFp.getSnapshot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of snapshots, providing details such as snapshot name, timestamp, VM ID, and other relevant information.
         * @summary Retrieve list of snapshots with pagination
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Snapshot ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshots(page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<Snapshots> {
            return localVarFp.listSnapshots(page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a snapshot.
         * @summary Restore a snapshot
         * @param {number} id 
         * @param {SnapshotRestoreRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshot(id: number, payload: SnapshotRestoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<Instance> {
            return localVarFp.restoreSnapshot(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SnapshotsApi - object-oriented interface
 * @export
 * @class SnapshotsApi
 * @extends {BaseAPI}
 */
export class SnapshotsApi extends BaseAPI {
    /**
     * Create a new custom image from an existing snapshot.Requires a name and any labels for your new custom image.
     * @summary Create an image from a snapshot
     * @param {number} snapshotId 
     * @param {CreateImagePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public createCustomImage(snapshotId: number, payload: CreateImagePayload, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).createCustomImage(snapshotId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a snapshot. Provide the snapshot ID in the path to delete the specified snapshot. If the snapshot is connected with an image, that image will also bedeleted and the deleted image ID will be returned in the success message response.
     * @summary Delete snapshot
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public deleteSnapshot(id: number, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).deleteSnapshot(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a Snapshot name is available
     * @summary Fetch snapshot name availability
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public fetchSnapshotNameAvailability(name: string, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).fetchSnapshotNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a snapshot.
     * @summary Retrieve a snapshot
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public getSnapshot(id: number, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).getSnapshot(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of snapshots, providing details such as snapshot name, timestamp, VM ID, and other relevant information.
     * @summary Retrieve list of snapshots with pagination
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search] Search By Snapshot ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public listSnapshots(page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).listSnapshots(page, pageSize, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a snapshot.
     * @summary Restore a snapshot
     * @param {number} id 
     * @param {SnapshotRestoreRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public restoreSnapshot(id: number, payload: SnapshotRestoreRequest, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).restoreSnapshot(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StockApi - axios parameter creator
 * @export
 */
export const StockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information on current and upcoming GPU availability, organized byregion and GPU model. For additional information on GPU stocks,[**click here**](https://docs.hyperstack.cloud/docs/hardware/gpu-stock-information).
         * @summary Retrieve GPU stocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGPUStock: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockApi - functional programming interface
 * @export
 */
export const StockApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns information on current and upcoming GPU availability, organized byregion and GPU model. For additional information on GPU stocks,[**click here**](https://docs.hyperstack.cloud/docs/hardware/gpu-stock-information).
         * @summary Retrieve GPU stocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGPUStock(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewStockRetriveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGPUStock(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StockApi.getGPUStock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StockApi - factory interface
 * @export
 */
export const StockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockApiFp(configuration)
    return {
        /**
         * Returns information on current and upcoming GPU availability, organized byregion and GPU model. For additional information on GPU stocks,[**click here**](https://docs.hyperstack.cloud/docs/hardware/gpu-stock-information).
         * @summary Retrieve GPU stocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGPUStock(options?: RawAxiosRequestConfig): AxiosPromise<NewStockRetriveResponse> {
            return localVarFp.getGPUStock(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockApi - object-oriented interface
 * @export
 * @class StockApi
 * @extends {BaseAPI}
 */
export class StockApi extends BaseAPI {
    /**
     * Returns information on current and upcoming GPU availability, organized byregion and GPU model. For additional information on GPU stocks,[**click here**](https://docs.hyperstack.cloud/docs/hardware/gpu-stock-information).
     * @summary Retrieve GPU stocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public getGPUStock(options?: RawAxiosRequestConfig) {
        return StockApiFp(this.configuration).getGPUStock(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a resource template for deployment.
         * @summary Create template
         * @param {File} content YAML file is required
         * @param {string} description description is required
         * @param {string} isPublic is_public is required
         * @param {string} name name is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: async (content: File, description: string, isPublic: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('createTemplate', 'content', content)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createTemplate', 'description', description)
            // verify required parameter 'isPublic' is not null or undefined
            assertParamExists('createTemplate', 'isPublic', isPublic)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createTemplate', 'name', name)
            const localVarPath = `/core/marketplace/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


            if (content !== undefined) { 
                localVarFormParams.append('content', content as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (isPublic !== undefined) { 
                localVarFormParams.append('is_public', isPublic as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a template. Supply the template ID in the path to delete the specified template.
         * @summary Delete template
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTemplate', 'id', id)
            const localVarPath = `/core/marketplace/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the resource configuration details for a specified template.Provide the template ID in the path to retrieve details for the specified template.For additional information on template configuration details,[**click here**](https://docs.hyperstack.cloud/docs/api-references/).
         * @summary Retrieve template details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTemplate', 'id', id)
            const localVarPath = `/core/marketplace/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a comprehensive list of templates, providing resource configuration details for each. Optionally, specify the `visibility` as `public` or `private` to retrieve templates with the desired visibility status. To learn more about the templates feature, [**click here**](https://docs.hyperstack.cloud/docs/features/templates#view-a-list-of-templates).
         * @summary List templates
         * @param {string} [visibility] Specify the &#x60;visibility&#x60; status as either &#x60;public&#x60; or &#x60;private&#x60; to filter and retrieve templates with the desired visibility.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates: async (visibility?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/marketplace/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (visibility !== undefined) {
                localVarQueryParameter['visibility'] = visibility;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of a template. Modify the template name, description and/or`is_public` status to change the public/private visibility of the template.
         * @summary Update template
         * @param {number} id 
         * @param {UpdateTemplate} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: async (id: number, payload: UpdateTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTemplate', 'id', id)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateTemplate', 'payload', payload)
            const localVarPath = `/core/marketplace/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a resource template for deployment.
         * @summary Create template
         * @param {File} content YAML file is required
         * @param {string} description description is required
         * @param {string} isPublic is_public is required
         * @param {string} name name is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemplate(content: File, description: string, isPublic: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemplate(content, description, isPublic, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplateApi.createTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a template. Supply the template ID in the path to delete the specified template.
         * @summary Delete template
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplateApi.deleteTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the resource configuration details for a specified template.Provide the template ID in the path to retrieve details for the specified template.For additional information on template configuration details,[**click here**](https://docs.hyperstack.cloud/docs/api-references/).
         * @summary Retrieve template details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplateApi.getTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a comprehensive list of templates, providing resource configuration details for each. Optionally, specify the `visibility` as `public` or `private` to retrieve templates with the desired visibility status. To learn more about the templates feature, [**click here**](https://docs.hyperstack.cloud/docs/features/templates#view-a-list-of-templates).
         * @summary List templates
         * @param {string} [visibility] Specify the &#x60;visibility&#x60; status as either &#x60;public&#x60; or &#x60;private&#x60; to filter and retrieve templates with the desired visibility.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTemplates(visibility?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Templates>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTemplates(visibility, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplateApi.listTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the details of a template. Modify the template name, description and/or`is_public` status to change the public/private visibility of the template.
         * @summary Update template
         * @param {number} id 
         * @param {UpdateTemplate} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplate(id: number, payload: UpdateTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplate(id, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplateApi.updateTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateApiFp(configuration)
    return {
        /**
         * Creates a resource template for deployment.
         * @summary Create template
         * @param {File} content YAML file is required
         * @param {string} description description is required
         * @param {string} isPublic is_public is required
         * @param {string} name name is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(content: File, description: string, isPublic: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.createTemplate(content, description, isPublic, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a template. Supply the template ID in the path to delete the specified template.
         * @summary Delete template
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the resource configuration details for a specified template.Provide the template ID in the path to retrieve details for the specified template.For additional information on template configuration details,[**click here**](https://docs.hyperstack.cloud/docs/api-references/).
         * @summary Retrieve template details
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.getTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a comprehensive list of templates, providing resource configuration details for each. Optionally, specify the `visibility` as `public` or `private` to retrieve templates with the desired visibility status. To learn more about the templates feature, [**click here**](https://docs.hyperstack.cloud/docs/features/templates#view-a-list-of-templates).
         * @summary List templates
         * @param {string} [visibility] Specify the &#x60;visibility&#x60; status as either &#x60;public&#x60; or &#x60;private&#x60; to filter and retrieve templates with the desired visibility.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(visibility?: string, options?: RawAxiosRequestConfig): AxiosPromise<Templates> {
            return localVarFp.listTemplates(visibility, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of a template. Modify the template name, description and/or`is_public` status to change the public/private visibility of the template.
         * @summary Update template
         * @param {number} id 
         * @param {UpdateTemplate} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(id: number, payload: UpdateTemplate, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.updateTemplate(id, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     * Creates a resource template for deployment.
     * @summary Create template
     * @param {File} content YAML file is required
     * @param {string} description description is required
     * @param {string} isPublic is_public is required
     * @param {string} name name is required
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public createTemplate(content: File, description: string, isPublic: string, name: string, options?: RawAxiosRequestConfig) {
        return TemplateApiFp(this.configuration).createTemplate(content, description, isPublic, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a template. Supply the template ID in the path to delete the specified template.
     * @summary Delete template
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public deleteTemplate(id: number, options?: RawAxiosRequestConfig) {
        return TemplateApiFp(this.configuration).deleteTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the resource configuration details for a specified template.Provide the template ID in the path to retrieve details for the specified template.For additional information on template configuration details,[**click here**](https://docs.hyperstack.cloud/docs/api-references/).
     * @summary Retrieve template details
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public getTemplate(id: number, options?: RawAxiosRequestConfig) {
        return TemplateApiFp(this.configuration).getTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a comprehensive list of templates, providing resource configuration details for each. Optionally, specify the `visibility` as `public` or `private` to retrieve templates with the desired visibility status. To learn more about the templates feature, [**click here**](https://docs.hyperstack.cloud/docs/features/templates#view-a-list-of-templates).
     * @summary List templates
     * @param {string} [visibility] Specify the &#x60;visibility&#x60; status as either &#x60;public&#x60; or &#x60;private&#x60; to filter and retrieve templates with the desired visibility.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public listTemplates(visibility?: string, options?: RawAxiosRequestConfig) {
        return TemplateApiFp(this.configuration).listTemplates(visibility, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of a template. Modify the template name, description and/or`is_public` status to change the public/private visibility of the template.
     * @summary Update template
     * @param {number} id 
     * @param {UpdateTemplate} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public updateTemplate(id: number, payload: UpdateTemplate, options?: RawAxiosRequestConfig) {
        return TemplateApiFp(this.configuration).updateTemplate(id, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add billing details associated with your user in the request body.
         * @summary POST: Insert billing info
         * @param {UserInfoPostPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserBillingInfo: async (payload: UserInfoPostPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('addUserBillingInfo', 'payload', payload)
            const localVarPath = `/billing/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the billing details associated with your user.
         * @summary GET: Retrieve billing info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the billing information for your user in the request body.
         * @summary PUT: Update billing info
         * @param {UserInfoPostPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserBillingInfo: async (payload: UserInfoPostPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateUserBillingInfo', 'payload', payload)
            const localVarPath = `/billing/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Add billing details associated with your user in the request body.
         * @summary POST: Insert billing info
         * @param {UserInfoPostPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserBillingInfo(payload: UserInfoPostPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddUserInfoSuccessResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserBillingInfo(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.addUserBillingInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the billing details associated with your user.
         * @summary GET: Retrieve billing info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBillingInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersInfoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBillingInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserBillingInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the billing information for your user in the request body.
         * @summary PUT: Update billing info
         * @param {UserInfoPostPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserBillingInfo(payload: UserInfoPostPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddUserInfoSuccessResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserBillingInfo(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUserBillingInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Add billing details associated with your user in the request body.
         * @summary POST: Insert billing info
         * @param {UserInfoPostPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserBillingInfo(payload: UserInfoPostPayload, options?: RawAxiosRequestConfig): AxiosPromise<AddUserInfoSuccessResponseModel> {
            return localVarFp.addUserBillingInfo(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the billing details associated with your user.
         * @summary GET: Retrieve billing info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBillingInfo(options?: RawAxiosRequestConfig): AxiosPromise<UsersInfoListResponse> {
            return localVarFp.getUserBillingInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the billing information for your user in the request body.
         * @summary PUT: Update billing info
         * @param {UserInfoPostPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserBillingInfo(payload: UserInfoPostPayload, options?: RawAxiosRequestConfig): AxiosPromise<AddUserInfoSuccessResponseModel> {
            return localVarFp.updateUserBillingInfo(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Add billing details associated with your user in the request body.
     * @summary POST: Insert billing info
     * @param {UserInfoPostPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserBillingInfo(payload: UserInfoPostPayload, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).addUserBillingInfo(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the billing details associated with your user.
     * @summary GET: Retrieve billing info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserBillingInfo(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserBillingInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the billing information for your user in the request body.
     * @summary PUT: Update billing info
     * @param {UserInfoPostPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserBillingInfo(payload: UserInfoPostPayload, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserBillingInfo(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserDetailChoiceApi - axios parameter creator
 * @export
 */
export const UserDetailChoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the default options for virtual machine deployment, including the default region, flavor, and image.
         * @summary Retrieve Default Flavors and Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefaultFlavorsAndImages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/user/resources/defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserDetailChoiceApi - functional programming interface
 * @export
 */
export const UserDetailChoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserDetailChoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the default options for virtual machine deployment, including the default region, flavor, and image.
         * @summary Retrieve Default Flavors and Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDefaultFlavorsAndImages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDefaultChoicesForUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDefaultFlavorsAndImages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserDetailChoiceApi.listDefaultFlavorsAndImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserDetailChoiceApi - factory interface
 * @export
 */
export const UserDetailChoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserDetailChoiceApiFp(configuration)
    return {
        /**
         * Retrieves the default options for virtual machine deployment, including the default region, flavor, and image.
         * @summary Retrieve Default Flavors and Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefaultFlavorsAndImages(options?: RawAxiosRequestConfig): AxiosPromise<UserDefaultChoicesForUserResponse> {
            return localVarFp.listDefaultFlavorsAndImages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserDetailChoiceApi - object-oriented interface
 * @export
 * @class UserDetailChoiceApi
 * @extends {BaseAPI}
 */
export class UserDetailChoiceApi extends BaseAPI {
    /**
     * Retrieves the default options for virtual machine deployment, including the default region, flavor, and image.
     * @summary Retrieve Default Flavors and Images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDetailChoiceApi
     */
    public listDefaultFlavorsAndImages(options?: RawAxiosRequestConfig) {
        return UserDetailChoiceApiFp(this.configuration).listDefaultFlavorsAndImages(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPermissionApi - axios parameter creator
 * @export
 */
export const UserPermissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of permissions granted to your account. For additional information on your permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-my-permissions).
         * @summary List My User Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/users/me/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of permissions granted to a specific user within your organization. Provide the ID of the user in the path. For additional information on user permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-user-permissions).
         * @summary List User Permissions
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPermissions: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserPermissions', 'id', id)
            const localVarPath = `/auth/users/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPermissionApi - functional programming interface
 * @export
 */
export const UserPermissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPermissionApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of permissions granted to your account. For additional information on your permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-my-permissions).
         * @summary List My User Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyUserPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserPermissionsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyUserPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPermissionApi.listMyUserPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of permissions granted to a specific user within your organization. Provide the ID of the user in the path. For additional information on user permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-user-permissions).
         * @summary List User Permissions
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserPermissions(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserPermissionsResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserPermissions(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPermissionApi.listUserPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserPermissionApi - factory interface
 * @export
 */
export const UserPermissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPermissionApiFp(configuration)
    return {
        /**
         * Retrieves a list of permissions granted to your account. For additional information on your permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-my-permissions).
         * @summary List My User Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyUserPermissions(options?: RawAxiosRequestConfig): AxiosPromise<GetUserPermissionsResponseModel> {
            return localVarFp.listMyUserPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of permissions granted to a specific user within your organization. Provide the ID of the user in the path. For additional information on user permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-user-permissions).
         * @summary List User Permissions
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPermissions(id: number, options?: RawAxiosRequestConfig): AxiosPromise<GetUserPermissionsResponseModel> {
            return localVarFp.listUserPermissions(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPermissionApi - object-oriented interface
 * @export
 * @class UserPermissionApi
 * @extends {BaseAPI}
 */
export class UserPermissionApi extends BaseAPI {
    /**
     * Retrieves a list of permissions granted to your account. For additional information on your permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-my-permissions).
     * @summary List My User Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPermissionApi
     */
    public listMyUserPermissions(options?: RawAxiosRequestConfig) {
        return UserPermissionApiFp(this.configuration).listMyUserPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of permissions granted to a specific user within your organization. Provide the ID of the user in the path. For additional information on user permissions, [click here](https://docs.hyperstack.cloud/docs/api-reference/auth-resources/permission/list-user-permissions).
     * @summary List User Permissions
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPermissionApi
     */
    public listUserPermissions(id: number, options?: RawAxiosRequestConfig) {
        return UserPermissionApiFp(this.configuration).listUserPermissions(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VirtualMachineApi - axios parameter creator
 * @export
 */
export const VirtualMachineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds one or more labels to an existing virtual machine. Provide the virtual machine ID in the path to add labels to the specified VM. For multiple labels, add a space between each label in the request body.
         * @summary Edit virtual machine labels
         * @param {number} vmId 
         * @param {EditLabelOfAnExistingVMPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVMLabel: async (vmId: number, payload: EditLabelOfAnExistingVMPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('addVMLabel', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('addVMLabel', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/label`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach firewalls to a virtual machine by providing the virtual machine ID in the path and the IDs of the firewalls in the request body; any firewalls not included will be detached.
         * @summary Attach firewalls to a virtual machine
         * @param {number} vmId 
         * @param {AttachFirewallsToVMPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachFirewallsToVM: async (vmId: number, payload: AttachFirewallsToVMPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('attachFirewallsToVM', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('attachFirewallsToVM', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/attach-firewalls`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a Virtual Machine name is available
         * @summary Fetch virtual machine name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkVMNameAvailability: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('checkVMNameAvailability', 'name', name)
            const localVarPath = `/core/virtual-machines/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a firewall rule for a virtual machine. Include the virtual machine ID in the path, and provide the firewall rule configuration in the request body, as detailed below. For additional information on firewall rules, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vm-firewall-rules/add-firewall-rule-to-vm).
         * @summary Add firewall rule to virtual machine
         * @param {number} vmId 
         * @param {CreateSecurityRulePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleForVM: async (vmId: number, payload: CreateSecurityRulePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('createFirewallRuleForVM', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createFirewallRuleForVM', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/sg-rules`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create snapshots of a virtual machine by providing the virtual machine ID in the path
         * @summary Create snapshot from a virtual machine
         * @param {number} vmId 
         * @param {CreateSnapshotPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshotForVM: async (vmId: number, payload: CreateSnapshotPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('createSnapshotForVM', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createSnapshotForVM', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/snapshots`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates one or more virtual machines with the specified custom configuration and features provided in the request body. For more information about the virtual machine features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/virtual-machine-features#create-a-virtual-machine-with-custom-features).
         * @summary Create virtual machines
         * @param {CreateInstancesPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVMs: async (payload: CreateInstancesPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createVMs', 'payload', payload)
            const localVarPath = `/core/virtual-machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a firewall rule associated with a virtual machine. Provide the virtual machine ID and the firewall rule ID in the path to remove the specified rule from the specified virtual machine.
         * @summary Delete firewall rule from virtual machine
         * @param {number} vmId 
         * @param {number} sgRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleForVM: async (vmId: number, sgRuleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('deleteFirewallRuleForVM', 'vmId', vmId)
            // verify required parameter 'sgRuleId' is not null or undefined
            assertParamExists('deleteFirewallRuleForVM', 'sgRuleId', sgRuleId)
            const localVarPath = `/core/virtual-machines/{vm_id}/sg-rules/{sg_rule_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"sg_rule_id"}}`, encodeURIComponent(String(sgRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a virtual machine. Provide the virtual machine ID in the path to delete the specified virtual machine.
         * @summary Delete virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVM: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('deleteVM', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of virtual machines associated with a contract, providing details such as virtual machine name, timestamp, flavor name, and other relevant information. Please provide the ID of the relevant contract in the path.
         * @summary Retrieve virtual machines associated with a contract
         * @param {number} contractId 
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Instance ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractVMs: async (contractId: number, page?: string, pageSize?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractVMs', 'contractId', contractId)
            const localVarPath = `/core/virtual-machines/contract/{contract_id}/virtual-machines`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing virtual machine. Provide the virtual machine ID in the path, and Infrahub will return information about the corresponding VM.
         * @summary Retrieve virtual machine details
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVM: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('getVM', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve console logs for a virtual machine
         * @summary Get virtual machine logs
         * @param {number} vmId 
         * @param {number} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMLogs: async (vmId: number, requestId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('getVMLogs', 'vmId', vmId)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('getVMLogs', 'requestId', requestId)
            const localVarPath = `/core/virtual-machines/{vm_id}/logs`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['request_id'] = requestId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves performance metrics data for a virtual machine. Provide the virtual machine ID in the path to retrieve the following data for the specified virtual machine: CPU usage, memory usage (RAM), `network.in`, `network.out`, `disk.read`, and `disk.write`. The optional `duration` parameter can be used to specify the period for retrieving performance metrics; the default value will retrieve all available data. To learn more about virtual machine performance metrics, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#performance-metrics).
         * @summary Retrieve virtual machine performance metrics
         * @param {number} vmId 
         * @param {GetVMMetricsDurationEnum} [duration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMMetrics: async (vmId: number, duration?: GetVMMetricsDurationEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('getVMMetrics', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/metrics`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a hard reboot for a virtual machine, simulating the process of unplugging and rebooting a physical machine. Provide the virtual machine ID in the path to execute a hard reboot for the specified virtual machine.
         * @summary Hard reboot virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hardRebootVM: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('hardRebootVM', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/hard-reboot`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates the hibernation of a virtual machine, saving its current state to disk before powering off. Provide the virtual machine ID in the path to specify the virtual machine to be hibernated.
         * @summary Hibernate virtual machine
         * @param {number} vmId 
         * @param {string} [retainIp] false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hibernateVM: async (vmId: number, retainIp?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('hibernateVM', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/hibernate`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (retainIp !== undefined) {
                localVarQueryParameter['retain_ip'] = retainIp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your existing virtual machines, providing configuration details for each. The list is sorted by creation date, with the oldest virtual machines displayed first.
         * @summary List virtual machines
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {string} [environment] 
         * @param {Array<number>} [excludeFirewalls] Comma-separated list of Security Group IDs to ignore instances attached
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVMs: async (page?: number, pageSize?: number, search?: string, environment?: string, excludeFirewalls?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/virtual-machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            if (excludeFirewalls) {
                localVarQueryParameter['exclude_firewalls'] = excludeFirewalls;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request console logs for a virtual machine
         * @summary Request virtual machine logs
         * @param {number} vmId 
         * @param {RequestInstanceLogsPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestVMLogs: async (vmId: number, payload: RequestInstanceLogsPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('requestVMLogs', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('requestVMLogs', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/logs`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the hardware configuration for an existing virtual machine. Include the virtual machine ID in the path and provide the new configuration, referred to as a `flavor`, in the body of the request. For additional information resizing, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#modify-the-flavor-of-an-existing-virtual-machine).
         * @summary Resize virtual machine
         * @param {number} vmId 
         * @param {InstanceResizePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resizeVM: async (vmId: number, payload: InstanceResizePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('resizeVM', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('resizeVM', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/resize`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes a virtual machine from hibernation, bringing it back to an active state. Provide the virtual machine ID that you want to restore from hibernation.
         * @summary Restore virtual machine from hibernation
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreVMFromHibernation: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('restoreVMFromHibernation', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/hibernate-restore`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates the startup of a virtual machine. Provide the virtual machine ID in the path to initiate the starting of the specified virtual machine.
         * @summary Start virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startVM: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('startVM', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/start`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shuts down a virtual machine. Provide the virtual machine ID in the path to initiate the shutdown process for the specified virtual machine.
         * @summary Stop virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopVM: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('stopVM', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/stop`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualMachineApi - functional programming interface
 * @export
 */
export const VirtualMachineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualMachineApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds one or more labels to an existing virtual machine. Provide the virtual machine ID in the path to add labels to the specified VM. For multiple labels, add a space between each label in the request body.
         * @summary Edit virtual machine labels
         * @param {number} vmId 
         * @param {EditLabelOfAnExistingVMPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVMLabel(vmId: number, payload: EditLabelOfAnExistingVMPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVMLabel(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.addVMLabel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach firewalls to a virtual machine by providing the virtual machine ID in the path and the IDs of the firewalls in the request body; any firewalls not included will be detached.
         * @summary Attach firewalls to a virtual machine
         * @param {number} vmId 
         * @param {AttachFirewallsToVMPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachFirewallsToVM(vmId: number, payload: AttachFirewallsToVMPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachFirewallsToVM(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.attachFirewallsToVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if a Virtual Machine name is available
         * @summary Fetch virtual machine name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkVMNameAvailability(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NameAvailableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkVMNameAvailability(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.checkVMNameAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a firewall rule for a virtual machine. Include the virtual machine ID in the path, and provide the firewall rule configuration in the request body, as detailed below. For additional information on firewall rules, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vm-firewall-rules/add-firewall-rule-to-vm).
         * @summary Add firewall rule to virtual machine
         * @param {number} vmId 
         * @param {CreateSecurityRulePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleForVM(vmId: number, payload: CreateSecurityRulePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleForVM(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.createFirewallRuleForVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create snapshots of a virtual machine by providing the virtual machine ID in the path
         * @summary Create snapshot from a virtual machine
         * @param {number} vmId 
         * @param {CreateSnapshotPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSnapshotForVM(vmId: number, payload: CreateSnapshotPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSnapshotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSnapshotForVM(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.createSnapshotForVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates one or more virtual machines with the specified custom configuration and features provided in the request body. For more information about the virtual machine features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/virtual-machine-features#create-a-virtual-machine-with-custom-features).
         * @summary Create virtual machines
         * @param {CreateInstancesPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVMs(payload: CreateInstancesPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInstancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVMs(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.createVMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a firewall rule associated with a virtual machine. Provide the virtual machine ID and the firewall rule ID in the path to remove the specified rule from the specified virtual machine.
         * @summary Delete firewall rule from virtual machine
         * @param {number} vmId 
         * @param {number} sgRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleForVM(vmId: number, sgRuleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleForVM(vmId, sgRuleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.deleteFirewallRuleForVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a virtual machine. Provide the virtual machine ID in the path to delete the specified virtual machine.
         * @summary Delete virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVM(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVM(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.deleteVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of virtual machines associated with a contract, providing details such as virtual machine name, timestamp, flavor name, and other relevant information. Please provide the ID of the relevant contract in the path.
         * @summary Retrieve virtual machines associated with a contract
         * @param {number} contractId 
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Instance ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractVMs(contractId: number, page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractInstancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractVMs(contractId, page, pageSize, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.getContractVMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of an existing virtual machine. Provide the virtual machine ID in the path, and Infrahub will return information about the corresponding VM.
         * @summary Retrieve virtual machine details
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVM(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVM(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.getVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve console logs for a virtual machine
         * @summary Get virtual machine logs
         * @param {number} vmId 
         * @param {number} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVMLogs(vmId: number, requestId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInstanceLogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVMLogs(vmId, requestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.getVMLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves performance metrics data for a virtual machine. Provide the virtual machine ID in the path to retrieve the following data for the specified virtual machine: CPU usage, memory usage (RAM), `network.in`, `network.out`, `disk.read`, and `disk.write`. The optional `duration` parameter can be used to specify the period for retrieving performance metrics; the default value will retrieve all available data. To learn more about virtual machine performance metrics, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#performance-metrics).
         * @summary Retrieve virtual machine performance metrics
         * @param {number} vmId 
         * @param {GetVMMetricsDurationEnum} [duration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVMMetrics(vmId: number, duration?: GetVMMetricsDurationEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsFields>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVMMetrics(vmId, duration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.getVMMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates a hard reboot for a virtual machine, simulating the process of unplugging and rebooting a physical machine. Provide the virtual machine ID in the path to execute a hard reboot for the specified virtual machine.
         * @summary Hard reboot virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hardRebootVM(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hardRebootVM(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.hardRebootVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates the hibernation of a virtual machine, saving its current state to disk before powering off. Provide the virtual machine ID in the path to specify the virtual machine to be hibernated.
         * @summary Hibernate virtual machine
         * @param {number} vmId 
         * @param {string} [retainIp] false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hibernateVM(vmId: number, retainIp?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hibernateVM(vmId, retainIp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.hibernateVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of your existing virtual machines, providing configuration details for each. The list is sorted by creation date, with the oldest virtual machines displayed first.
         * @summary List virtual machines
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {string} [environment] 
         * @param {Array<number>} [excludeFirewalls] Comma-separated list of Security Group IDs to ignore instances attached
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVMs(page?: number, pageSize?: number, search?: string, environment?: string, excludeFirewalls?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instances>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVMs(page, pageSize, search, environment, excludeFirewalls, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.listVMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request console logs for a virtual machine
         * @summary Request virtual machine logs
         * @param {number} vmId 
         * @param {RequestInstanceLogsPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestVMLogs(vmId: number, payload: RequestInstanceLogsPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestInstanceLogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestVMLogs(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.requestVMLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the hardware configuration for an existing virtual machine. Include the virtual machine ID in the path and provide the new configuration, referred to as a `flavor`, in the body of the request. For additional information resizing, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#modify-the-flavor-of-an-existing-virtual-machine).
         * @summary Resize virtual machine
         * @param {number} vmId 
         * @param {InstanceResizePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resizeVM(vmId: number, payload: InstanceResizePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resizeVM(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.resizeVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resumes a virtual machine from hibernation, bringing it back to an active state. Provide the virtual machine ID that you want to restore from hibernation.
         * @summary Restore virtual machine from hibernation
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreVMFromHibernation(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreVMFromHibernation(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.restoreVMFromHibernation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates the startup of a virtual machine. Provide the virtual machine ID in the path to initiate the starting of the specified virtual machine.
         * @summary Start virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startVM(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startVM(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.startVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Shuts down a virtual machine. Provide the virtual machine ID in the path to initiate the shutdown process for the specified virtual machine.
         * @summary Stop virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopVM(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopVM(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineApi.stopVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtualMachineApi - factory interface
 * @export
 */
export const VirtualMachineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualMachineApiFp(configuration)
    return {
        /**
         * Adds one or more labels to an existing virtual machine. Provide the virtual machine ID in the path to add labels to the specified VM. For multiple labels, add a space between each label in the request body.
         * @summary Edit virtual machine labels
         * @param {number} vmId 
         * @param {EditLabelOfAnExistingVMPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVMLabel(vmId: number, payload: EditLabelOfAnExistingVMPayload, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.addVMLabel(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach firewalls to a virtual machine by providing the virtual machine ID in the path and the IDs of the firewalls in the request body; any firewalls not included will be detached.
         * @summary Attach firewalls to a virtual machine
         * @param {number} vmId 
         * @param {AttachFirewallsToVMPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachFirewallsToVM(vmId: number, payload: AttachFirewallsToVMPayload, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.attachFirewallsToVM(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Virtual Machine name is available
         * @summary Fetch virtual machine name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkVMNameAvailability(name: string, options?: RawAxiosRequestConfig): AxiosPromise<NameAvailableModel> {
            return localVarFp.checkVMNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a firewall rule for a virtual machine. Include the virtual machine ID in the path, and provide the firewall rule configuration in the request body, as detailed below. For additional information on firewall rules, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vm-firewall-rules/add-firewall-rule-to-vm).
         * @summary Add firewall rule to virtual machine
         * @param {number} vmId 
         * @param {CreateSecurityRulePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleForVM(vmId: number, payload: CreateSecurityRulePayload, options?: RawAxiosRequestConfig): AxiosPromise<SecurityGroupRule> {
            return localVarFp.createFirewallRuleForVM(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Create snapshots of a virtual machine by providing the virtual machine ID in the path
         * @summary Create snapshot from a virtual machine
         * @param {number} vmId 
         * @param {CreateSnapshotPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshotForVM(vmId: number, payload: CreateSnapshotPayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateSnapshotResponse> {
            return localVarFp.createSnapshotForVM(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates one or more virtual machines with the specified custom configuration and features provided in the request body. For more information about the virtual machine features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/virtual-machine-features#create-a-virtual-machine-with-custom-features).
         * @summary Create virtual machines
         * @param {CreateInstancesPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVMs(payload: CreateInstancesPayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateInstancesResponse> {
            return localVarFp.createVMs(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a firewall rule associated with a virtual machine. Provide the virtual machine ID and the firewall rule ID in the path to remove the specified rule from the specified virtual machine.
         * @summary Delete firewall rule from virtual machine
         * @param {number} vmId 
         * @param {number} sgRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleForVM(vmId: number, sgRuleId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteFirewallRuleForVM(vmId, sgRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a virtual machine. Provide the virtual machine ID in the path to delete the specified virtual machine.
         * @summary Delete virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVM(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteVM(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of virtual machines associated with a contract, providing details such as virtual machine name, timestamp, flavor name, and other relevant information. Please provide the ID of the relevant contract in the path.
         * @summary Retrieve virtual machines associated with a contract
         * @param {number} contractId 
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] Search By Instance ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractVMs(contractId: number, page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractInstancesResponse> {
            return localVarFp.getContractVMs(contractId, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing virtual machine. Provide the virtual machine ID in the path, and Infrahub will return information about the corresponding VM.
         * @summary Retrieve virtual machine details
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVM(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<Instance> {
            return localVarFp.getVM(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve console logs for a virtual machine
         * @summary Get virtual machine logs
         * @param {number} vmId 
         * @param {number} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMLogs(vmId: number, requestId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetInstanceLogsResponse> {
            return localVarFp.getVMLogs(vmId, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves performance metrics data for a virtual machine. Provide the virtual machine ID in the path to retrieve the following data for the specified virtual machine: CPU usage, memory usage (RAM), `network.in`, `network.out`, `disk.read`, and `disk.write`. The optional `duration` parameter can be used to specify the period for retrieving performance metrics; the default value will retrieve all available data. To learn more about virtual machine performance metrics, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#performance-metrics).
         * @summary Retrieve virtual machine performance metrics
         * @param {number} vmId 
         * @param {GetVMMetricsDurationEnum} [duration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVMMetrics(vmId: number, duration?: GetVMMetricsDurationEnum, options?: RawAxiosRequestConfig): AxiosPromise<MetricsFields> {
            return localVarFp.getVMMetrics(vmId, duration, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a hard reboot for a virtual machine, simulating the process of unplugging and rebooting a physical machine. Provide the virtual machine ID in the path to execute a hard reboot for the specified virtual machine.
         * @summary Hard reboot virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hardRebootVM(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.hardRebootVM(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates the hibernation of a virtual machine, saving its current state to disk before powering off. Provide the virtual machine ID in the path to specify the virtual machine to be hibernated.
         * @summary Hibernate virtual machine
         * @param {number} vmId 
         * @param {string} [retainIp] false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hibernateVM(vmId: number, retainIp?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.hibernateVM(vmId, retainIp, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your existing virtual machines, providing configuration details for each. The list is sorted by creation date, with the oldest virtual machines displayed first.
         * @summary List virtual machines
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {string} [environment] 
         * @param {Array<number>} [excludeFirewalls] Comma-separated list of Security Group IDs to ignore instances attached
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVMs(page?: number, pageSize?: number, search?: string, environment?: string, excludeFirewalls?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<Instances> {
            return localVarFp.listVMs(page, pageSize, search, environment, excludeFirewalls, options).then((request) => request(axios, basePath));
        },
        /**
         * Request console logs for a virtual machine
         * @summary Request virtual machine logs
         * @param {number} vmId 
         * @param {RequestInstanceLogsPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestVMLogs(vmId: number, payload: RequestInstanceLogsPayload, options?: RawAxiosRequestConfig): AxiosPromise<RequestInstanceLogsResponse> {
            return localVarFp.requestVMLogs(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the hardware configuration for an existing virtual machine. Include the virtual machine ID in the path and provide the new configuration, referred to as a `flavor`, in the body of the request. For additional information resizing, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#modify-the-flavor-of-an-existing-virtual-machine).
         * @summary Resize virtual machine
         * @param {number} vmId 
         * @param {InstanceResizePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resizeVM(vmId: number, payload: InstanceResizePayload, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.resizeVM(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a virtual machine from hibernation, bringing it back to an active state. Provide the virtual machine ID that you want to restore from hibernation.
         * @summary Restore virtual machine from hibernation
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreVMFromHibernation(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.restoreVMFromHibernation(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates the startup of a virtual machine. Provide the virtual machine ID in the path to initiate the starting of the specified virtual machine.
         * @summary Start virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startVM(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.startVM(vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Shuts down a virtual machine. Provide the virtual machine ID in the path to initiate the shutdown process for the specified virtual machine.
         * @summary Stop virtual machine
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopVM(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.stopVM(vmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualMachineApi - object-oriented interface
 * @export
 * @class VirtualMachineApi
 * @extends {BaseAPI}
 */
export class VirtualMachineApi extends BaseAPI {
    /**
     * Adds one or more labels to an existing virtual machine. Provide the virtual machine ID in the path to add labels to the specified VM. For multiple labels, add a space between each label in the request body.
     * @summary Edit virtual machine labels
     * @param {number} vmId 
     * @param {EditLabelOfAnExistingVMPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public addVMLabel(vmId: number, payload: EditLabelOfAnExistingVMPayload, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).addVMLabel(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attach firewalls to a virtual machine by providing the virtual machine ID in the path and the IDs of the firewalls in the request body; any firewalls not included will be detached.
     * @summary Attach firewalls to a virtual machine
     * @param {number} vmId 
     * @param {AttachFirewallsToVMPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public attachFirewallsToVM(vmId: number, payload: AttachFirewallsToVMPayload, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).attachFirewallsToVM(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a Virtual Machine name is available
     * @summary Fetch virtual machine name availability
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public checkVMNameAvailability(name: string, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).checkVMNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a firewall rule for a virtual machine. Include the virtual machine ID in the path, and provide the firewall rule configuration in the request body, as detailed below. For additional information on firewall rules, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vm-firewall-rules/add-firewall-rule-to-vm).
     * @summary Add firewall rule to virtual machine
     * @param {number} vmId 
     * @param {CreateSecurityRulePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public createFirewallRuleForVM(vmId: number, payload: CreateSecurityRulePayload, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).createFirewallRuleForVM(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create snapshots of a virtual machine by providing the virtual machine ID in the path
     * @summary Create snapshot from a virtual machine
     * @param {number} vmId 
     * @param {CreateSnapshotPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public createSnapshotForVM(vmId: number, payload: CreateSnapshotPayload, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).createSnapshotForVM(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates one or more virtual machines with the specified custom configuration and features provided in the request body. For more information about the virtual machine features offered by Infrahub, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/virtual-machine-features#create-a-virtual-machine-with-custom-features).
     * @summary Create virtual machines
     * @param {CreateInstancesPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public createVMs(payload: CreateInstancesPayload, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).createVMs(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a firewall rule associated with a virtual machine. Provide the virtual machine ID and the firewall rule ID in the path to remove the specified rule from the specified virtual machine.
     * @summary Delete firewall rule from virtual machine
     * @param {number} vmId 
     * @param {number} sgRuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public deleteFirewallRuleForVM(vmId: number, sgRuleId: number, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).deleteFirewallRuleForVM(vmId, sgRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a virtual machine. Provide the virtual machine ID in the path to delete the specified virtual machine.
     * @summary Delete virtual machine
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public deleteVM(vmId: number, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).deleteVM(vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of virtual machines associated with a contract, providing details such as virtual machine name, timestamp, flavor name, and other relevant information. Please provide the ID of the relevant contract in the path.
     * @summary Retrieve virtual machines associated with a contract
     * @param {number} contractId 
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search] Search By Instance ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public getContractVMs(contractId: number, page?: string, pageSize?: string, search?: string, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).getContractVMs(contractId, page, pageSize, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing virtual machine. Provide the virtual machine ID in the path, and Infrahub will return information about the corresponding VM.
     * @summary Retrieve virtual machine details
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public getVM(vmId: number, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).getVM(vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve console logs for a virtual machine
     * @summary Get virtual machine logs
     * @param {number} vmId 
     * @param {number} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public getVMLogs(vmId: number, requestId: number, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).getVMLogs(vmId, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves performance metrics data for a virtual machine. Provide the virtual machine ID in the path to retrieve the following data for the specified virtual machine: CPU usage, memory usage (RAM), `network.in`, `network.out`, `disk.read`, and `disk.write`. The optional `duration` parameter can be used to specify the period for retrieving performance metrics; the default value will retrieve all available data. To learn more about virtual machine performance metrics, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#performance-metrics).
     * @summary Retrieve virtual machine performance metrics
     * @param {number} vmId 
     * @param {GetVMMetricsDurationEnum} [duration] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public getVMMetrics(vmId: number, duration?: GetVMMetricsDurationEnum, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).getVMMetrics(vmId, duration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a hard reboot for a virtual machine, simulating the process of unplugging and rebooting a physical machine. Provide the virtual machine ID in the path to execute a hard reboot for the specified virtual machine.
     * @summary Hard reboot virtual machine
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public hardRebootVM(vmId: number, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).hardRebootVM(vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates the hibernation of a virtual machine, saving its current state to disk before powering off. Provide the virtual machine ID in the path to specify the virtual machine to be hibernated.
     * @summary Hibernate virtual machine
     * @param {number} vmId 
     * @param {string} [retainIp] false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public hibernateVM(vmId: number, retainIp?: string, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).hibernateVM(vmId, retainIp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your existing virtual machines, providing configuration details for each. The list is sorted by creation date, with the oldest virtual machines displayed first.
     * @summary List virtual machines
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {string} [environment] 
     * @param {Array<number>} [excludeFirewalls] Comma-separated list of Security Group IDs to ignore instances attached
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public listVMs(page?: number, pageSize?: number, search?: string, environment?: string, excludeFirewalls?: Array<number>, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).listVMs(page, pageSize, search, environment, excludeFirewalls, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request console logs for a virtual machine
     * @summary Request virtual machine logs
     * @param {number} vmId 
     * @param {RequestInstanceLogsPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public requestVMLogs(vmId: number, payload: RequestInstanceLogsPayload, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).requestVMLogs(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the hardware configuration for an existing virtual machine. Include the virtual machine ID in the path and provide the new configuration, referred to as a `flavor`, in the body of the request. For additional information resizing, [**click here**](https://docs.hyperstack.cloud/docs/hardware/flavors#modify-the-flavor-of-an-existing-virtual-machine).
     * @summary Resize virtual machine
     * @param {number} vmId 
     * @param {InstanceResizePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public resizeVM(vmId: number, payload: InstanceResizePayload, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).resizeVM(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes a virtual machine from hibernation, bringing it back to an active state. Provide the virtual machine ID that you want to restore from hibernation.
     * @summary Restore virtual machine from hibernation
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public restoreVMFromHibernation(vmId: number, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).restoreVMFromHibernation(vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates the startup of a virtual machine. Provide the virtual machine ID in the path to initiate the starting of the specified virtual machine.
     * @summary Start virtual machine
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public startVM(vmId: number, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).startVM(vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Shuts down a virtual machine. Provide the virtual machine ID in the path to initiate the shutdown process for the specified virtual machine.
     * @summary Stop virtual machine
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineApi
     */
    public stopVM(vmId: number, options?: RawAxiosRequestConfig) {
        return VirtualMachineApiFp(this.configuration).stopVM(vmId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetVMMetricsDurationEnum = {
    _1h: '1h',
    _2h: '2h',
    _4h: '4h',
    _6h: '6h',
    _12h: '12h',
    _1d: '1d',
    _3d: '3d',
    _7d: '7d',
    _15d: '15d',
    _30d: '30d'
} as const;
export type GetVMMetricsDurationEnum = typeof GetVMMetricsDurationEnum[keyof typeof GetVMMetricsDurationEnum];


/**
 * VirtualMachineEventsApi - axios parameter creator
 * @export
 */
export const VirtualMachineEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all events in a virtual machine\'s history, which records actions performed on the specified virtual machine. Include the virtual machine ID in the path to retrieve the history of events. For more details on virtual machine events history, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#events-history).
         * @summary List virtual machine events
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVMEvents: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('listVMEvents', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/events`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualMachineEventsApi - functional programming interface
 * @export
 */
export const VirtualMachineEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualMachineEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all events in a virtual machine\'s history, which records actions performed on the specified virtual machine. Include the virtual machine ID in the path to retrieve the history of events. For more details on virtual machine events history, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#events-history).
         * @summary List virtual machine events
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVMEvents(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceEvents>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVMEvents(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualMachineEventsApi.listVMEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtualMachineEventsApi - factory interface
 * @export
 */
export const VirtualMachineEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualMachineEventsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all events in a virtual machine\'s history, which records actions performed on the specified virtual machine. Include the virtual machine ID in the path to retrieve the history of events. For more details on virtual machine events history, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#events-history).
         * @summary List virtual machine events
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVMEvents(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<InstanceEvents> {
            return localVarFp.listVMEvents(vmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualMachineEventsApi - object-oriented interface
 * @export
 * @class VirtualMachineEventsApi
 * @extends {BaseAPI}
 */
export class VirtualMachineEventsApi extends BaseAPI {
    /**
     * Retrieves a list of all events in a virtual machine\'s history, which records actions performed on the specified virtual machine. Include the virtual machine ID in the path to retrieve the history of events. For more details on virtual machine events history, [**click here**](https://docs.hyperstack.cloud/docs/virtual-machines/vm-performance-metrics-and-events-history#events-history).
     * @summary List virtual machine events
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualMachineEventsApi
     */
    public listVMEvents(vmId: number, options?: RawAxiosRequestConfig) {
        return VirtualMachineEventsApiFp(this.configuration).listVMEvents(vmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VncUrlApi - axios parameter creator
 * @export
 */
export const VncUrlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the URL to access the VNC console for a specified virtual machine by providing the virtual machine ID and the job ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-vnc-url).
         * @summary Get VNC Console Link
         * @param {number} vmId 
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVNCURL: async (vmId: number, jobId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('getVNCURL', 'vmId', vmId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getVNCURL', 'jobId', jobId)
            const localVarPath = `/core/virtual-machines/{vm_id}/console/{job_id}`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the path of the VNC console for the given virtual machine ID by providing the virtual machine ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-console-path).
         * @summary Request Instance Console
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestVMConsole: async (vmId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('requestVMConsole', 'vmId', vmId)
            const localVarPath = `/core/virtual-machines/{vm_id}/request-console`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VncUrlApi - functional programming interface
 * @export
 */
export const VncUrlApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VncUrlApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the URL to access the VNC console for a specified virtual machine by providing the virtual machine ID and the job ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-vnc-url).
         * @summary Get VNC Console Link
         * @param {number} vmId 
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVNCURL(vmId: number, jobId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VNCURL>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVNCURL(vmId, jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VncUrlApi.getVNCURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the path of the VNC console for the given virtual machine ID by providing the virtual machine ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-console-path).
         * @summary Request Instance Console
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestVMConsole(vmId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestConsole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestVMConsole(vmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VncUrlApi.requestVMConsole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VncUrlApi - factory interface
 * @export
 */
export const VncUrlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VncUrlApiFp(configuration)
    return {
        /**
         * Retrieves the URL to access the VNC console for a specified virtual machine by providing the virtual machine ID and the job ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-vnc-url).
         * @summary Get VNC Console Link
         * @param {number} vmId 
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVNCURL(vmId: number, jobId: number, options?: RawAxiosRequestConfig): AxiosPromise<VNCURL> {
            return localVarFp.getVNCURL(vmId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the path of the VNC console for the given virtual machine ID by providing the virtual machine ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-console-path).
         * @summary Request Instance Console
         * @param {number} vmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestVMConsole(vmId: number, options?: RawAxiosRequestConfig): AxiosPromise<RequestConsole> {
            return localVarFp.requestVMConsole(vmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VncUrlApi - object-oriented interface
 * @export
 * @class VncUrlApi
 * @extends {BaseAPI}
 */
export class VncUrlApi extends BaseAPI {
    /**
     * Retrieves the URL to access the VNC console for a specified virtual machine by providing the virtual machine ID and the job ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-vnc-url).
     * @summary Get VNC Console Link
     * @param {number} vmId 
     * @param {number} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VncUrlApi
     */
    public getVNCURL(vmId: number, jobId: number, options?: RawAxiosRequestConfig) {
        return VncUrlApiFp(this.configuration).getVNCURL(vmId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the path of the VNC console for the given virtual machine ID by providing the virtual machine ID in the path. For more information, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/virtual-machines/vnc-console/retrieve-console-path).
     * @summary Request Instance Console
     * @param {number} vmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VncUrlApi
     */
    public requestVMConsole(vmId: number, options?: RawAxiosRequestConfig) {
        return VncUrlApiFp(this.configuration).requestVMConsole(vmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VolumeApi - axios parameter creator
 * @export
 */
export const VolumeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a volume that can be attached to a virtual machine, expanding its storage capacity. Specify the volume type and custom configuration in the request body. For additional details on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/create-volume).
         * @summary Create volume
         * @param {CreateVolumePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume: async (payload: CreateVolumePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createVolume', 'payload', payload)
            const localVarPath = `/core/volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a volume permanently. Provide the volume ID in the path to specify the volume to be deleted.
         * @summary Delete volume
         * @param {number} volumeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolume: async (volumeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeId' is not null or undefined
            assertParamExists('deleteVolume', 'volumeId', volumeId)
            const localVarPath = `/core/volumes/{volume_id}`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a Volume name is available
         * @summary Fetch volume name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVolumeNameAvailability: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('fetchVolumeNameAvailability', 'name', name)
            const localVarPath = `/core/volume/name-availability/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch volume details for specific volume. This endpoint returns id, name, volume size, volume type, status, description, image_id, os_image, created_at, updated_at etc.
         * @summary Fetch Volume Details
         * @param {number} volumeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolume: async (volumeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeId' is not null or undefined
            assertParamExists('getVolume', 'volumeId', volumeId)
            const localVarPath = `/core/volumes/{volume_id}`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of available volume types that can be used in the creation of a new volume.
         * @summary List volume types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/volume-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your existing volumes, providing details for each. For more information on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/).
         * @summary List volumes
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] 
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes: async (page?: string, pageSize?: string, search?: string, environment?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/core/volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update volume properties. Currently supports updating the environment by providing \'environment_name\'. The volume must not be attached to any instance when changing environments, and the target environment must be in the same region.
         * @summary Update volume fields
         * @param {number} volumeId 
         * @param {UpdateVolumePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolume: async (volumeId: number, payload: UpdateVolumePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeId' is not null or undefined
            assertParamExists('updateVolume', 'volumeId', volumeId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateVolume', 'payload', payload)
            const localVarPath = `/core/volumes/{volume_id}`
                .replace(`{${"volume_id"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VolumeApi - functional programming interface
 * @export
 */
export const VolumeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VolumeApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a volume that can be attached to a virtual machine, expanding its storage capacity. Specify the volume type and custom configuration in the request body. For additional details on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/create-volume).
         * @summary Create volume
         * @param {CreateVolumePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVolume(payload: CreateVolumePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVolume(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeApi.createVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a volume permanently. Provide the volume ID in the path to specify the volume to be deleted.
         * @summary Delete volume
         * @param {number} volumeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVolume(volumeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVolume(volumeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeApi.deleteVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if a Volume name is available
         * @summary Fetch volume name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchVolumeNameAvailability(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NameAvailableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchVolumeNameAvailability(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeApi.fetchVolumeNameAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch volume details for specific volume. This endpoint returns id, name, volume size, volume type, status, description, image_id, os_image, created_at, updated_at etc.
         * @summary Fetch Volume Details
         * @param {number} volumeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolume(volumeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolume(volumeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeApi.getVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of available volume types that can be used in the creation of a new volume.
         * @summary List volume types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolumeTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVolumeTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeApi.listVolumeTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of your existing volumes, providing details for each. For more information on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/).
         * @summary List volumes
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] 
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolumes(page?: string, pageSize?: string, search?: string, environment?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volumes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVolumes(page, pageSize, search, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeApi.listVolumes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update volume properties. Currently supports updating the environment by providing \'environment_name\'. The volume must not be attached to any instance when changing environments, and the target environment must be in the same region.
         * @summary Update volume fields
         * @param {number} volumeId 
         * @param {UpdateVolumePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVolume(volumeId: number, payload: UpdateVolumePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateVolumeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVolume(volumeId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeApi.updateVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VolumeApi - factory interface
 * @export
 */
export const VolumeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VolumeApiFp(configuration)
    return {
        /**
         * Creates a volume that can be attached to a virtual machine, expanding its storage capacity. Specify the volume type and custom configuration in the request body. For additional details on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/create-volume).
         * @summary Create volume
         * @param {CreateVolumePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVolume(payload: CreateVolumePayload, options?: RawAxiosRequestConfig): AxiosPromise<Volume> {
            return localVarFp.createVolume(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a volume permanently. Provide the volume ID in the path to specify the volume to be deleted.
         * @summary Delete volume
         * @param {number} volumeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVolume(volumeId: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponseModel> {
            return localVarFp.deleteVolume(volumeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a Volume name is available
         * @summary Fetch volume name availability
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchVolumeNameAvailability(name: string, options?: RawAxiosRequestConfig): AxiosPromise<NameAvailableModel> {
            return localVarFp.fetchVolumeNameAvailability(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch volume details for specific volume. This endpoint returns id, name, volume size, volume type, status, description, image_id, os_image, created_at, updated_at etc.
         * @summary Fetch Volume Details
         * @param {number} volumeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolume(volumeId: number, options?: RawAxiosRequestConfig): AxiosPromise<Volume> {
            return localVarFp.getVolume(volumeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of available volume types that can be used in the creation of a new volume.
         * @summary List volume types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes(options?: RawAxiosRequestConfig): AxiosPromise<VolumeTypes> {
            return localVarFp.listVolumeTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your existing volumes, providing details for each. For more information on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/).
         * @summary List volumes
         * @param {string} [page] Page Number
         * @param {string} [pageSize] Data Per Page
         * @param {string} [search] 
         * @param {string} [environment] Filter Environment ID or Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes(page?: string, pageSize?: string, search?: string, environment?: string, options?: RawAxiosRequestConfig): AxiosPromise<Volumes> {
            return localVarFp.listVolumes(page, pageSize, search, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * Update volume properties. Currently supports updating the environment by providing \'environment_name\'. The volume must not be attached to any instance when changing environments, and the target environment must be in the same region.
         * @summary Update volume fields
         * @param {number} volumeId 
         * @param {UpdateVolumePayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolume(volumeId: number, payload: UpdateVolumePayload, options?: RawAxiosRequestConfig): AxiosPromise<UpdateVolumeResponse> {
            return localVarFp.updateVolume(volumeId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VolumeApi - object-oriented interface
 * @export
 * @class VolumeApi
 * @extends {BaseAPI}
 */
export class VolumeApi extends BaseAPI {
    /**
     * Creates a volume that can be attached to a virtual machine, expanding its storage capacity. Specify the volume type and custom configuration in the request body. For additional details on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/create-volume).
     * @summary Create volume
     * @param {CreateVolumePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    public createVolume(payload: CreateVolumePayload, options?: RawAxiosRequestConfig) {
        return VolumeApiFp(this.configuration).createVolume(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a volume permanently. Provide the volume ID in the path to specify the volume to be deleted.
     * @summary Delete volume
     * @param {number} volumeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    public deleteVolume(volumeId: number, options?: RawAxiosRequestConfig) {
        return VolumeApiFp(this.configuration).deleteVolume(volumeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a Volume name is available
     * @summary Fetch volume name availability
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    public fetchVolumeNameAvailability(name: string, options?: RawAxiosRequestConfig) {
        return VolumeApiFp(this.configuration).fetchVolumeNameAvailability(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch volume details for specific volume. This endpoint returns id, name, volume size, volume type, status, description, image_id, os_image, created_at, updated_at etc.
     * @summary Fetch Volume Details
     * @param {number} volumeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    public getVolume(volumeId: number, options?: RawAxiosRequestConfig) {
        return VolumeApiFp(this.configuration).getVolume(volumeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of available volume types that can be used in the creation of a new volume.
     * @summary List volume types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    public listVolumeTypes(options?: RawAxiosRequestConfig) {
        return VolumeApiFp(this.configuration).listVolumeTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your existing volumes, providing details for each. For more information on volumes, [**click here**]({Config.INFRAHUB_DOCS_BASE}/docs/api-reference/core-resources/volumes/).
     * @summary List volumes
     * @param {string} [page] Page Number
     * @param {string} [pageSize] Data Per Page
     * @param {string} [search] 
     * @param {string} [environment] Filter Environment ID or Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    public listVolumes(page?: string, pageSize?: string, search?: string, environment?: string, options?: RawAxiosRequestConfig) {
        return VolumeApiFp(this.configuration).listVolumes(page, pageSize, search, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update volume properties. Currently supports updating the environment by providing \'environment_name\'. The volume must not be attached to any instance when changing environments, and the target environment must be in the same region.
     * @summary Update volume fields
     * @param {number} volumeId 
     * @param {UpdateVolumePayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    public updateVolume(volumeId: number, payload: UpdateVolumePayload, options?: RawAxiosRequestConfig) {
        return VolumeApiFp(this.configuration).updateVolume(volumeId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VolumeAttachmentApi - axios parameter creator
 * @export
 */
export const VolumeAttachmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attaches one or more volumes to an existing virtual machine, expanding its storage capacity by 2PB per attached volume. Include the VM ID in the path and the volume IDs in the request body to attach the specified volumes. For more detailson volume attachment, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-attachment/attach-volumes/).
         * @summary Attach volumes to virtual machine
         * @param {number} vmId 
         * @param {AttachVolumesPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachVolumesToVM: async (vmId: number, payload: AttachVolumesPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('attachVolumesToVM', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('attachVolumesToVM', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/attach-volumes`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches one or more volumes attached to an existing virtual machine. Include the VM ID in the path and volume IDs in the request body to detach the specified volumes from the virtual machine.
         * @summary Detach volumes from virtual machine
         * @param {number} vmId 
         * @param {DetachVolumesPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachVolumesFromVM: async (vmId: number, payload: DetachVolumesPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('detachVolumesFromVM', 'vmId', vmId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('detachVolumesFromVM', 'payload', payload)
            const localVarPath = `/core/virtual-machines/{vm_id}/detach-volumes`
                .replace(`{${"vm_id"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a volume attachment
         * @param {number} volumeAttachmentId 
         * @param {UpdateVolumeAttachmentPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolumeAttachment: async (volumeAttachmentId: number, payload: UpdateVolumeAttachmentPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeAttachmentId' is not null or undefined
            assertParamExists('updateVolumeAttachment', 'volumeAttachmentId', volumeAttachmentId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('updateVolumeAttachment', 'payload', payload)
            const localVarPath = `/core/volume-attachments/{volume_attachment_id}`
                .replace(`{${"volume_attachment_id"}}`, encodeURIComponent(String(volumeAttachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VolumeAttachmentApi - functional programming interface
 * @export
 */
export const VolumeAttachmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VolumeAttachmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Attaches one or more volumes to an existing virtual machine, expanding its storage capacity by 2PB per attached volume. Include the VM ID in the path and the volume IDs in the request body to attach the specified volumes. For more detailson volume attachment, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-attachment/attach-volumes/).
         * @summary Attach volumes to virtual machine
         * @param {number} vmId 
         * @param {AttachVolumesPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachVolumesToVM(vmId: number, payload: AttachVolumesPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachVolumes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachVolumesToVM(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeAttachmentApi.attachVolumesToVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detaches one or more volumes attached to an existing virtual machine. Include the VM ID in the path and volume IDs in the request body to detach the specified volumes from the virtual machine.
         * @summary Detach volumes from virtual machine
         * @param {number} vmId 
         * @param {DetachVolumesPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachVolumesFromVM(vmId: number, payload: DetachVolumesPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetachVolumes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachVolumesFromVM(vmId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeAttachmentApi.detachVolumesFromVM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a volume attachment
         * @param {number} volumeAttachmentId 
         * @param {UpdateVolumeAttachmentPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVolumeAttachment(volumeAttachmentId: number, payload: UpdateVolumeAttachmentPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachVolumes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVolumeAttachment(volumeAttachmentId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeAttachmentApi.updateVolumeAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VolumeAttachmentApi - factory interface
 * @export
 */
export const VolumeAttachmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VolumeAttachmentApiFp(configuration)
    return {
        /**
         * Attaches one or more volumes to an existing virtual machine, expanding its storage capacity by 2PB per attached volume. Include the VM ID in the path and the volume IDs in the request body to attach the specified volumes. For more detailson volume attachment, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-attachment/attach-volumes/).
         * @summary Attach volumes to virtual machine
         * @param {number} vmId 
         * @param {AttachVolumesPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachVolumesToVM(vmId: number, payload: AttachVolumesPayload, options?: RawAxiosRequestConfig): AxiosPromise<AttachVolumes> {
            return localVarFp.attachVolumesToVM(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches one or more volumes attached to an existing virtual machine. Include the VM ID in the path and volume IDs in the request body to detach the specified volumes from the virtual machine.
         * @summary Detach volumes from virtual machine
         * @param {number} vmId 
         * @param {DetachVolumesPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachVolumesFromVM(vmId: number, payload: DetachVolumesPayload, options?: RawAxiosRequestConfig): AxiosPromise<DetachVolumes> {
            return localVarFp.detachVolumesFromVM(vmId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a volume attachment
         * @param {number} volumeAttachmentId 
         * @param {UpdateVolumeAttachmentPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVolumeAttachment(volumeAttachmentId: number, payload: UpdateVolumeAttachmentPayload, options?: RawAxiosRequestConfig): AxiosPromise<AttachVolumes> {
            return localVarFp.updateVolumeAttachment(volumeAttachmentId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VolumeAttachmentApi - object-oriented interface
 * @export
 * @class VolumeAttachmentApi
 * @extends {BaseAPI}
 */
export class VolumeAttachmentApi extends BaseAPI {
    /**
     * Attaches one or more volumes to an existing virtual machine, expanding its storage capacity by 2PB per attached volume. Include the VM ID in the path and the volume IDs in the request body to attach the specified volumes. For more detailson volume attachment, [**click here**](https://docs.hyperstack.cloud/docs/api-reference/core-resources/volumes/volume-attachment/attach-volumes/).
     * @summary Attach volumes to virtual machine
     * @param {number} vmId 
     * @param {AttachVolumesPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeAttachmentApi
     */
    public attachVolumesToVM(vmId: number, payload: AttachVolumesPayload, options?: RawAxiosRequestConfig) {
        return VolumeAttachmentApiFp(this.configuration).attachVolumesToVM(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches one or more volumes attached to an existing virtual machine. Include the VM ID in the path and volume IDs in the request body to detach the specified volumes from the virtual machine.
     * @summary Detach volumes from virtual machine
     * @param {number} vmId 
     * @param {DetachVolumesPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeAttachmentApi
     */
    public detachVolumesFromVM(vmId: number, payload: DetachVolumesPayload, options?: RawAxiosRequestConfig) {
        return VolumeAttachmentApiFp(this.configuration).detachVolumesFromVM(vmId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a volume attachment
     * @param {number} volumeAttachmentId 
     * @param {UpdateVolumeAttachmentPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeAttachmentApi
     */
    public updateVolumeAttachment(volumeAttachmentId: number, payload: UpdateVolumeAttachmentPayload, options?: RawAxiosRequestConfig) {
        return VolumeAttachmentApiFp(this.configuration).updateVolumeAttachment(volumeAttachmentId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VouchersApi - axios parameter creator
 * @export
 */
export const VouchersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Request to redeem a voucher with a voucher code.
         * @summary Redeem a voucher with a voucher_code
         * @param {RedeemVoucherPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemAVoucher: async (payload: RedeemVoucherPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('redeemAVoucher', 'payload', payload)
            const localVarPath = `/billing/billing/vouchers/redeem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VouchersApi - functional programming interface
 * @export
 */
export const VouchersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VouchersApiAxiosParamCreator(configuration)
    return {
        /**
         * Request to redeem a voucher with a voucher code.
         * @summary Redeem a voucher with a voucher_code
         * @param {RedeemVoucherPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeemAVoucher(payload: RedeemVoucherPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherRedeemResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeemAVoucher(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VouchersApi.redeemAVoucher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VouchersApi - factory interface
 * @export
 */
export const VouchersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VouchersApiFp(configuration)
    return {
        /**
         * Request to redeem a voucher with a voucher code.
         * @summary Redeem a voucher with a voucher_code
         * @param {RedeemVoucherPayload} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemAVoucher(payload: RedeemVoucherPayload, options?: RawAxiosRequestConfig): AxiosPromise<VoucherRedeemResponseSchema> {
            return localVarFp.redeemAVoucher(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VouchersApi - object-oriented interface
 * @export
 * @class VouchersApi
 * @extends {BaseAPI}
 */
export class VouchersApi extends BaseAPI {
    /**
     * Request to redeem a voucher with a voucher code.
     * @summary Redeem a voucher with a voucher_code
     * @param {RedeemVoucherPayload} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchersApi
     */
    public redeemAVoucher(payload: RedeemVoucherPayload, options?: RawAxiosRequestConfig) {
        return VouchersApiFp(this.configuration).redeemAVoucher(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



